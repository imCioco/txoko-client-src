; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35217.0 

	TITLE	d:\_m2work\server client tmp4\clientvs22\vs_files\userinterface\distribute\pythonshop.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ ; `string'
PUBLIC	??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ ; `string'
PUBLIC	??_C@_06DKEIEPKC@IsOpen@			; `string'
PUBLIC	??_C@_04DNCDCIAE@Open@				; `string'
PUBLIC	??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@	; `string'
PUBLIC	??_C@_0O@EDCBOPPA@IsPrivateShop@		; `string'
PUBLIC	??_C@_0M@PGHDAHMM@GetTabCount@			; `string'
PUBLIC	??_C@_0N@OIFMMAOE@GetItemPrice@			; `string'
PUBLIC	??_C@_0P@CFALBIIJ@GetTabCoinType@		; `string'
PUBLIC	??_C@_0L@HEMHLKHB@GetTabName@			; `string'
PUBLIC	??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@	; `string'
PUBLIC	??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@	; `string'
PUBLIC	??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@	; `string'
PUBLIC	??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@	; `string'
PUBLIC	??_C@_04BFIJLIPK@shop@				; `string'
PUBLIC	??_C@_0BB@MDMPBIAN@BuildPrivateShop@		; `string'
PUBLIC	??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@		; `string'
PUBLIC	??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@		; `string'
PUBLIC	??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@ ; `string'
PUBLIC	??_R2CPythonShop@@8				; CPythonShop::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCPythonShop@@@@8		; CSingleton<CPythonShop>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8	; CSingleton<CPythonShop>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonShop@@8			; CPythonShop::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$CSingleton@VCPythonShop@@@@8		; CSingleton<CPythonShop>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3CPythonShop@@8				; CPythonShop::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CSingleton@VCPythonShop@@@@@8		; CSingleton<CPythonShop> `RTTI Type Descriptor'
PUBLIC	??_R0?AVCPythonShop@@@8				; CPythonShop `RTTI Type Descriptor'
PUBLIC	??_R4?$CSingleton@VCPythonShop@@@@6B@		; CSingleton<CPythonShop>::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonShop@@6B@				; CPythonShop::`RTTI Complete Object Locator'
PUBLIC	??_7?$CSingleton@VCPythonShop@@@@6B@		; CSingleton<CPythonShop>::`vftable'
PUBLIC	??_7CPythonShop@@6B@				; CPythonShop::`vftable'
;	COMDAT ??_7CPythonShop@@6B@
CONST	SEGMENT
??_7CPythonShop@@6B@ DD FLAT:??_R4CPythonShop@@6B@	; CPythonShop::`vftable'
	DD	FLAT:??_ECPythonShop@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?s_methods@?1??initshop@@YAXXZ@4PAUPyMethodDef@@A
_DATA	SEGMENT
?s_methods@?1??initshop@@YAXXZ@4PAUPyMethodDef@@A DD FLAT:??_C@_04DNCDCIAE@Open@ ; `initshop'::`2'::s_methods
	DD	FLAT:?shopOpen@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_05LGELBCGM@Close@
	DD	FLAT:?shopClose@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06DKEIEPKC@IsOpen@
	DD	FLAT:?shopIsOpen@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@EDCBOPPA@IsPrivateShop@
	DD	FLAT:?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@
	DD	FLAT:?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09GMBNEEAB@GetItemID@
	DD	FLAT:?shopGetItemID@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@LEKALLIG@GetItemCount@
	DD	FLAT:?shopGetItemCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@OIFMMAOE@GetItemPrice@
	DD	FLAT:?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@JBOBKHIE@GetItemMetinSocket@
	DD	FLAT:?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@GOKPPDHH@GetItemAttribute@
	DD	FLAT:?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@PGHDAHMM@GetTabCount@
	DD	FLAT:?shopGetTabCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@HEMHLKHB@GetTabName@
	DD	FLAT:?shopGetTabName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@CFALBIIJ@GetTabCoinType@
	DD	FLAT:?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@
	DD	FLAT:?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@
	DD	FLAT:?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@
	DD	FLAT:?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@
	DD	FLAT:?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@MDMPBIAN@BuildPrivateShop@
	DD	FLAT:?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonShop@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonShop@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonShop@@@@6B@ ; CSingleton<CPythonShop>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonShop@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CPythonShop@@6B@
rdata$r	SEGMENT
??_R4CPythonShop@@6B@ DD 00H				; CPythonShop::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonShop@@@8
	DD	FLAT:??_R3CPythonShop@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonShop@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonShop@@@@6B@ DD 00H		; CSingleton<CPythonShop>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonShop@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonShop@@@8
data$rs	SEGMENT
??_R0?AVCPythonShop@@@8 DD FLAT:??_7type_info@@6B@	; CPythonShop `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonShop@@', 00H
data$rs	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonShop@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCPythonShop@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonShop> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonShop@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CPythonShop@@8
rdata$r	SEGMENT
??_R3CPythonShop@@8 DD 00H				; CPythonShop::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPythonShop@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonShop@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonShop@@@@8 DD 00H		; CSingleton<CPythonShop>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonShop@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonShop@@8 DD FLAT:??_R0?AVCPythonShop@@@8 ; CPythonShop::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonShop@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonShop@@@@@8 ; CSingleton<CPythonShop>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonShop@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonShop@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8 ; CSingleton<CPythonShop>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CPythonShop@@8
rdata$r	SEGMENT
??_R2CPythonShop@@8 DD FLAT:??_R1A@?0A@EA@CPythonShop@@8 ; CPythonShop::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@
CONST	SEGMENT
??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@ DB 'SHOP_COIN_TYPE_SECO'
	DB	'NDARY_COIN', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@
CONST	SEGMENT
??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@ DB 'SHOP_SLOT_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@
CONST	SEGMENT
??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@ DB 'SHOP_COIN_TYPE_GOLD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MDMPBIAN@BuildPrivateShop@
CONST	SEGMENT
??_C@_0BB@MDMPBIAN@BuildPrivateShop@ DB 'BuildPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFIJLIPK@shop@
CONST	SEGMENT
??_C@_04BFIJLIPK@shop@ DB 'shop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@
CONST	SEGMENT
??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@ DB 'DelPrivateShopItemStock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@
CONST	SEGMENT
??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@ DB 'GetPrivateShopItemPrice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@
CONST	SEGMENT
??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@ DB 'ClearPrivateShopStock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@
CONST	SEGMENT
??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@ DB 'AddPrivateShopItemStock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HEMHLKHB@GetTabName@
CONST	SEGMENT
??_C@_0L@HEMHLKHB@GetTabName@ DB 'GetTabName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CFALBIIJ@GetTabCoinType@
CONST	SEGMENT
??_C@_0P@CFALBIIJ@GetTabCoinType@ DB 'GetTabCoinType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIFMMAOE@GetItemPrice@
CONST	SEGMENT
??_C@_0N@OIFMMAOE@GetItemPrice@ DB 'GetItemPrice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGHDAHMM@GetTabCount@
CONST	SEGMENT
??_C@_0M@PGHDAHMM@GetTabCount@ DB 'GetTabCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EDCBOPPA@IsPrivateShop@
CONST	SEGMENT
??_C@_0O@EDCBOPPA@IsPrivateShop@ DB 'IsPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@
CONST	SEGMENT
??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@ DB 'IsMainPlayerPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNCDCIAE@Open@
CONST	SEGMENT
??_C@_04DNCDCIAE@Open@ DB 'Open', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKEIEPKC@IsOpen@
CONST	SEGMENT
??_C@_06DKEIEPKC@IsOpen@ DB 'IsOpen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
CONST	SEGMENT
??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ DB 'Ou'
	DB	't of Index. tabIdx(%d) must be less than %d.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
CONST	SEGMENT
??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ DB 'Ou'
	DB	't of Index. tabIdx(%d) must be less than %d. dwSlotPos(%d) mu'
	DB	'st be less than %d', 00H			; `string'
PUBLIC	??MSItemPos@@QBE_NABU0@@Z			; SItemPos::operator<
PUBLIC	??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z ; std::forward<SItemPos>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
PUBLIC	??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::pair<SItemPos const ,SShopItemTable>::pair<SItemPos const ,SShopItemTable><SItemPos,SShopItemTable,0>
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::max_size
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Max
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Allocate
PUBLIC	??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
PUBLIC	??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
PUBLIC	??$construct_at@USShopItemTable@@U1@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z ; std::construct_at<SShopItemTable,SShopItemTable>
PUBLIC	??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
PUBLIC	??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z ; std::construct_at<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::max_size
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Get_size_of_n@$0N@@std@@YAII@Z		; std::_Get_size_of_n<13>
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
PUBLIC	??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z ; std::destroy_at<std::pair<SItemPos const ,SShopItemTable> >
PUBLIC	??$construct_at@USShopItemTable@@ABU1@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z ; std::construct_at<SShopItemTable,SShopItemTable const &>
PUBLIC	??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z ; std::addressof<SShopItemTable>
PUBLIC	??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable>
PUBLIC	??$_Copy_memmove_tail@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<SShopItemTable *>
PUBLIC	??$move@AAPAUSShopItemTable@@@std@@YA$$QAPAUSShopItemTable@@AAPAU1@@Z ; std::move<SShopItemTable * &>
PUBLIC	??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z ; std::to_address<SShopItemTable>
PUBLIC	??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z ; std::forward<SShopItemTable * &>
PUBLIC	??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_unchecked<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
PUBLIC	??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Push_heap_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
PUBLIC	??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ; std::forward<SShopItemTable>
PUBLIC	??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
PUBLIC	??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::construct<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >
PUBLIC	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Unchecked_begin
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Check_grow_by_1
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::deallocate
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Min
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator==
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Get_first
PUBLIC	?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z ; std::allocator<SShopItemTable>::allocate
PUBLIC	?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Calculate_growth
PUBLIC	?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Orphan_range
PUBLIC	??1_Reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
PUBLIC	?_Extract@?$_In_place_key_extract_map_impl@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z ; std::_In_place_key_extract_map_impl<SItemPos,std::pair<SItemPos,SShopItemTable> >::_Extract
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Uninitialized_backout_al<std::allocator<SShopItemTable> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::~_Uninitialized_backout_al<std::allocator<SShopItemTable> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Release
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z ; std::forward<std::less<SItemPos> const &>
PUBLIC	??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
PUBLIC	??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::destroy<std::pair<SItemPos const ,SShopItemTable> >
PUBLIC	??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable const &>
PUBLIC	??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z ; std::_Construct_in_place<SShopItemTable,SShopItemTable const &>
PUBLIC	??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Emplace_back<SShopItemTable>
PUBLIC	??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z ; std::_To_address<SShopItemTable *>
PUBLIC	??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
PUBLIC	??$_Unfancy@USShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ; std::_Unfancy<SShopItemTable>
PUBLIC	??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z ; std::pair<SShopItemTable *,SShopItemTable *>::pair<SShopItemTable *,SShopItemTable *><SShopItemTable * &,SShopItemTable * &,0>
PUBLIC	??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z ; std::swap<SShopItemTable,0>
PUBLIC	??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ; std::_Next_iter<SShopItemTable *>
PUBLIC	??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Guess_median_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ; std::_Prev_iter<SShopItemTable *>
PUBLIC	??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Pop_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
PUBLIC	??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Move_backward_unchecked<SShopItemTable *,SShopItemTable *>
PUBLIC	??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ; std::move<SShopItemTable &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > > >
PUBLIC	??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool,0>
PUBLIC	??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,bool,0>
PUBLIC	??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > ><std::pair<SItemPos,SShopItemTable> >
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1><>
PUBLIC	??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z ; std::less<SItemPos>::operator()
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getcomp
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
PUBLIC	??0?$allocator@USShopItemTable@@@std@@QAE@XZ	; std::allocator<SShopItemTable>::allocator<SShopItemTable>
PUBLIC	?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z ; std::allocator<SShopItemTable>::deallocate
PUBLIC	?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
PUBLIC	?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
PUBLIC	?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SShopItemTable> >::_Vector_val<std::_Simple_types<SShopItemTable> >
PUBLIC	??1_Simple_reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Simple_reallocation_guard::~_Simple_reallocation_guard
PUBLIC	??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1><std::less<SItemPos> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> &>
PUBLIC	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > const >
PUBLIC	??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z ; std::_Destroy_range<std::allocator<SShopItemTable> >
PUBLIC	??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z ; std::addressof<std::pair<SItemPos const ,SShopItemTable> >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Lower_bound_duplicate<SItemPos>
PUBLIC	??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
PUBLIC	??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_back_with_unused_capacity<SShopItemTable const &>
PUBLIC	??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z ; std::forward<SShopItemTable const &>
PUBLIC	??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z ; std::_Uninitialized_move<SShopItemTable *,std::allocator<SShopItemTable> >
PUBLIC	??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z ; std::_Get_unwrapped<SShopItemTable * const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<SShopItemTable> >
PUBLIC	??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Sort_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z ; std::_Insertion_sort_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool const &,0>
PUBLIC	??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Emplace<std::pair<SItemPos,SShopItemTable> >
PUBLIC	??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>
PUBLIC	??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ; std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0>::_Kfn<SItemPos const ,SShopItemTable>
PUBLIC	??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Orphan_ptr
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>
PUBLIC	?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::max_size
PUBLIC	?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::capacity
PUBLIC	?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Tidy
PUBLIC	?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z ; std::pointer_traits<std::pair<SItemPos const ,SShopItemTable> *>::pointer_to
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find<SItemPos>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1><>
PUBLIC	??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_one_at_back<SShopItemTable const &>
PUBLIC	??$_Reallocate@$0A@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXAAI@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate<0>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
PUBLIC	??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > >
PUBLIC	??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::emplace<std::pair<SItemPos,SShopItemTable> >
PUBLIC	??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z ; std::forward<std::pair<SItemPos,SShopItemTable> >
PUBLIC	??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z ; std::pair<SItemPos,SShopItemTable>::pair<SItemPos,SShopItemTable><SItemPos &,SShopItemTable &,0>
PUBLIC	??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z ; std::forward<SShopItemTable &>
PUBLIC	??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z ; std::forward<SItemPos &>
PUBLIC	??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Eqrange<SItemPos>
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z	; CSingleton<CPythonShop>::`scalar deleting destructor'
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??0?$CSingleton@VCPythonShop@@@@QAE@XZ		; CSingleton<CPythonShop>::CSingleton<CPythonShop>
PUBLIC	??1?$CSingleton@VCPythonShop@@@@UAE@XZ		; CSingleton<CPythonShop>::~CSingleton<CPythonShop>
PUBLIC	??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::~_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::find
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator==
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator->
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
PUBLIC	??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::vector<SShopItemTable,std::allocator<SShopItemTable> >
PUBLIC	??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >
PUBLIC	?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::push_back
PUBLIC	?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::reserve
PUBLIC	?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
PUBLIC	?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end
PUBLIC	??$_Pass_fn@UItemStockSortFunc@@@std@@YA?A_PAAUItemStockSortFunc@@@Z ; std::_Pass_fn<ItemStockSortFunc>
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Unwrapped
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,ItemStockSortFunc>
PUBLIC	??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::insert<std::pair<SItemPos,SShopItemTable>,0>
PUBLIC	??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z ; std::make_pair<SItemPos &,SShopItemTable &>
PUBLIC	?initshop@@YAXXZ				; initshop
PUBLIC	?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z	; shopGetTabCoinType
PUBLIC	?shopGetTabName@@YAPAU_object@@PAU1@0@Z		; shopGetTabName
PUBLIC	?shopGetTabCount@@YAPAU_object@@PAU1@0@Z	; shopGetTabCount
PUBLIC	?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z	; shopBuildPrivateShop
PUBLIC	?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z ; shopGetPrivateShopItemPrice
PUBLIC	?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ; shopDelPrivateShopItemStock
PUBLIC	?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ; shopAddPrivateShopItemStock
PUBLIC	?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z ; shopClearPrivateShopStock
PUBLIC	?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z	; shopGetItemAttribute
PUBLIC	?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z	; shopGetItemMetinSocket
PUBLIC	?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z	; shopGetItemPrice
PUBLIC	?shopGetItemCount@@YAPAU_object@@PAU1@0@Z	; shopGetItemCount
PUBLIC	?shopGetItemID@@YAPAU_object@@PAU1@0@Z		; shopGetItemID
PUBLIC	?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z ; shopIsMainPlayerPrivateShop
PUBLIC	?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z	; shopIsPrviateShop
PUBLIC	?shopIsOpen@@YAPAU_object@@PAU1@0@Z		; shopIsOpen
PUBLIC	?shopClose@@YAPAU_object@@PAU1@0@Z		; shopClose
PUBLIC	?shopOpen@@YAPAU_object@@PAU1@0@Z		; shopOpen
PUBLIC	??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::~map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
PUBLIC	??1ShopTab@CPythonShop@@QAE@XZ			; CPythonShop::ShopTab::~ShopTab
PUBLIC	??_GCPythonShop@@UAEPAXI@Z			; CPythonShop::`scalar deleting destructor'
PUBLIC	?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ	; CPythonShop::IsMainPlayerPrivateShop
PUBLIC	?IsPrivateShop@CPythonShop@@QAEHXZ		; CPythonShop::IsPrivateShop
PUBLIC	?Close@CPythonShop@@QAEXXZ			; CPythonShop::Close
PUBLIC	?Open@CPythonShop@@QAEXHH@Z			; CPythonShop::Open
PUBLIC	?BuildPrivateShop@CPythonShop@@QAEXPBD@Z	; CPythonShop::BuildPrivateShop
PUBLIC	??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z ; ItemStockSortFunc::operator()
PUBLIC	?GetPrivateShopItemPrice@CPythonShop@@QAEHUSItemPos@@@Z ; CPythonShop::GetPrivateShopItemPrice
PUBLIC	?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ; CPythonShop::DelPrivateShopItemStock
PUBLIC	??0SShopItemTable@@QAE@XZ			; SShopItemTable::SShopItemTable
PUBLIC	?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z ; CPythonShop::AddPrivateShopItemStock
PUBLIC	?ClearPrivateShopStock@CPythonShop@@QAEXXZ	; CPythonShop::ClearPrivateShopStock
PUBLIC	?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
PUBLIC	?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
PUBLIC	?GetTabName@CPythonShop@@QAEPBDE@Z		; CPythonShop::GetTabName
PUBLIC	?GetTabCoinType@CPythonShop@@QAEEE@Z		; CPythonShop::GetTabCoinType
PUBLIC	??0ShopTab@CPythonShop@@QAE@XZ			; CPythonShop::ShopTab::ShopTab
PUBLIC	?GetTabCount@CPythonShop@@QAEEXZ		; CPythonShop::GetTabCount
PUBLIC	?IsOpen@CPythonShop@@QAEHXZ			; CPythonShop::IsOpen
PUBLIC	?Clear@CPythonShop@@QAEXXZ			; CPythonShop::Clear
PUBLIC	?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
PUBLIC	?SetTabCoinType@CPythonShop@@QAEXEE@Z		; CPythonShop::SetTabCoinType
PUBLIC	?SetTabName@CPythonShop@@QAEXEPBD@Z		; CPythonShop::SetTabName
PUBLIC	?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
PUBLIC	??0CPythonShop@@QAE@XZ				; CPythonShop::CPythonShop
PUBLIC	??1CPythonShop@@UAE@XZ				; CPythonShop::~CPythonShop
EXTRN	??_ECPythonShop@@UAEPAXI@Z:PROC			; CPythonShop::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCPythonShop@@@@UAEPAXI@Z:PROC	; CSingleton<CPythonShop>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPythonShop@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonShop@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CPythonShop@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CPythonShop@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonShop@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonShop@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z$0
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ??1CPythonShop@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CPythonShop@@UAE@XZ PROC				; CPythonShop::~CPythonShop, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPythonShop@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 209  : }

  00026	8d b7 90 14 00
	00		 lea	 esi, DWORD PTR [edi+5264]
  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonShop@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 777  :         _Erase_tree(_Al, _Myhead->_Parent);

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b ce		 mov	 ecx, esi
  00036	ff 70 04	 push	 DWORD PTR [eax+4]
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003f	6a 20		 push	 32			; 00000020H
  00041	ff 36		 push	 DWORD PTR [esi]
  00043	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00048	83 c4 08	 add	 esp, 8
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 209  : }

  0004b	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  0004e	68 00 00 00 00	 push	 OFFSET ??1ShopTab@CPythonShop@@QAE@XZ
  00053	6a 03		 push	 3
  00055	68 d4 06 00 00	 push	 1748			; 000006d4H
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h

; 19   : 	{ 

  00060	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, 0 ; CSingleton<CPythonShop>::ms_singleton
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 209  : }

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
  00081	cc		 int	 3
  00082	cc		 int	 3
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CPythonShop@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPythonShop@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPythonShop@@UAE@XZ ENDP				; CPythonShop::~CPythonShop
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ??0CPythonShop@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CPythonShop@@QAE@XZ PROC				; CPythonShop::CPythonShop, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonShop@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, edi ; CSingleton<CPythonShop>::ms_singleton
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 203  : {

  00032	68 00 00 00 00	 push	 OFFSET ??1ShopTab@CPythonShop@@QAE@XZ
  00037	68 00 00 00 00	 push	 OFFSET ??0ShopTab@CPythonShop@@QAE@XZ ; CPythonShop::ShopTab::ShopTab
  0003c	6a 03		 push	 3
  0003e	68 d4 06 00 00	 push	 1748			; 000006d4H
  00043	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	50		 push	 eax
  0004e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonShop@@6B@
  00054	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00059	8d b7 90 14 00
	00		 lea	 esi, DWORD PTR [edi+5264]
  0005f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 345  :         const auto _Pnode = _Al.allocate(1);

  00063	6a 20		 push	 32			; 00000020H
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 203  : {

  00065	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00068	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0006e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 345  :         const auto _Pnode = _Al.allocate(1);

  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	83 c4 04	 add	 esp, 4
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 204  : 	Clear();

  0007d	8b cf		 mov	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0007f	89 00		 mov	 DWORD PTR [eax], eax

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00081	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00084	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 349  :         _Pnode->_Color = _Black;

  00087	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1957 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0008d	89 06		 mov	 DWORD PTR [esi], eax
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 204  : 	Clear();

  0008f	e8 00 00 00 00	 call	 ?Clear@CPythonShop@@QAEXXZ ; CPythonShop::Clear

; 205  : }

  00094	8b c7		 mov	 eax, edi
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonShop@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonShop@@@@UAE@XZ ; CSingleton<CPythonShop>::~CSingleton<CPythonShop>
__unwindfunclet$??0CPythonShop@@QAE@XZ$1:
  00008	68 00 00 00 00	 push	 OFFSET ??1ShopTab@CPythonShop@@QAE@XZ
  0000d	6a 03		 push	 3
  0000f	68 d4 06 00 00	 push	 1748			; 000006d4H
  00014	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 14	 add	 eax, 20			; 00000014H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$??0CPythonShop@@QAE@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonShop@@QAE@XZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonShop@@QAE@XZ ENDP				; CPythonShop::CPythonShop
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_dwSlotPos$ = 12					; size = 4
_c_rShopItemData$ = 16					; size = 4
?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z PROC ; CPythonShop::SetItemData, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	if (tabIdx >= SHOP_TAB_COUNT_MAX || dwSlotPos >= SHOP_HOST_ITEM_MAX_NUM)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _dwSlotPos$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3c 03		 cmp	 al, 3
  0000e	73 44		 jae	 SHORT $LN3@SetItemDat
  00010	83 fa 28	 cmp	 edx, 40			; 00000028H
  00013	73 3f		 jae	 SHORT $LN3@SetItemDat

; 78   : 		return;
; 79   : 	}
; 80   : 
; 81   : 	m_aShoptabs[tabIdx].items[dwSlotPos] = c_rShopItemData;

  00015	0f b6 c0	 movzx	 eax, al
  00018	69 c8 d4 06 00
	00		 imul	 ecx, eax, 1748
  0001e	6b d2 2b	 imul	 edx, edx, 43
  00021	03 ce		 add	 ecx, esi
  00023	03 d1		 add	 edx, ecx
  00025	8b 4d 10	 mov	 ecx, DWORD PTR _c_rShopItemData$[ebp]
  00028	5e		 pop	 esi
  00029	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0002c	0f 11 42 30	 movups	 XMMWORD PTR [edx+48], xmm0
  00030	0f 10 41 10	 movups	 xmm0, XMMWORD PTR [ecx+16]
  00034	0f 11 42 40	 movups	 XMMWORD PTR [edx+64], xmm0
  00038	f3 0f 7e 41 20	 movq	 xmm0, QWORD PTR [ecx+32]
  0003d	66 0f d6 42 50	 movq	 QWORD PTR [edx+80], xmm0
  00042	66 8b 41 28	 mov	 ax, WORD PTR [ecx+40]
  00046	66 89 42 58	 mov	 WORD PTR [edx+88], ax
  0004a	8a 41 2a	 mov	 al, BYTE PTR [ecx+42]
  0004d	88 42 5a	 mov	 BYTE PTR [edx+90], al

; 82   : }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SetItemDat:

; 76   : 	{
; 77   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d. dwSlotPos(%d) must be less than %d", tabIdx, SHOP_TAB_COUNT_MAX, dwSlotPos, SHOP_HOST_ITEM_MAX_NUM);

  00054	6a 28		 push	 40			; 00000028H
  00056	52		 push	 edx
  00057	6a 03		 push	 3
  00059	0f b6 c0	 movzx	 eax, al
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00062	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00067	83 c4 14	 add	 esp, 20			; 00000014H
  0006a	5e		 pop	 esi

; 82   : }

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ENDP ; CPythonShop::SetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetTabName@CPythonShop@@QAEXEPBD@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_name$ = 12						; size = 4
?SetTabName@CPythonShop@@QAEXEPBD@Z PROC		; CPythonShop::SetTabName, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	0f b6 d0	 movzx	 edx, al
  0000c	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
  0000f	72 15		 jb	 SHORT $LN2@SetTabName

; 39   : 	{	
; 40   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  00011	6a 03		 push	 3
  00013	52		 push	 edx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00019	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	5e		 pop	 esi

; 44   : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN2@SetTabName:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00029	53		 push	 ebx
  0002a	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
  0002d	0f 1f 00	 npad	 3
$LL11@SetTabName:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL11@SetTabName
  00037	2b cb		 sub	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	51		 push	 ecx
  0003a	ff 75 0c	 push	 DWORD PTR _name$[ebp]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 43   : 	m_aShoptabs[tabIdx].name = name;

  0003d	69 ca d4 06 00
	00		 imul	 ecx, edx, 1748
  00043	83 c1 18	 add	 ecx, 24			; 00000018H
  00046	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00048	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004d	5b		 pop	 ebx
  0004e	5e		 pop	 esi
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 44   : }

  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?SetTabName@CPythonShop@@QAEXEPBD@Z ENDP		; CPythonShop::SetTabName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetTabCoinType@CPythonShop@@QAEXEE@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_coinType$ = 12						; size = 1
?SetTabCoinType@CPythonShop@@QAEXEE@Z PROC		; CPythonShop::SetTabCoinType, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	0f b6 d0	 movzx	 edx, al
  0000c	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
  0000f	72 15		 jb	 SHORT $LN2@SetTabCoin

; 19   : 	{	
; 20   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  00011	6a 03		 push	 3
  00013	52		 push	 edx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00019	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	5e		 pop	 esi

; 24   : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN2@SetTabCoin:

; 21   : 		return;
; 22   : 	}
; 23   : 	m_aShoptabs[tabIdx].coinType = coinType;

  00026	8a 45 0c	 mov	 al, BYTE PTR _coinType$[ebp]
  00029	69 ca d4 06 00
	00		 imul	 ecx, edx, 1748
  0002f	88 44 31 14	 mov	 BYTE PTR [ecx+esi+20], al
  00033	5e		 pop	 esi

; 24   : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?SetTabCoinType@CPythonShop@@QAEXEE@Z ENDP		; CPythonShop::SetTabCoinType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
_c_rShopItemData$ = 12					; size = 4
?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z PROC ; CPythonShop::SetItemData, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 59   : 	BYTE tabIdx = dwIndex / SHOP_HOST_ITEM_MAX_NUM;
; 60   : 	DWORD dwSlotPos = dwIndex % SHOP_HOST_ITEM_MAX_NUM;

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwIndex$[ebp]
  00007	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH

; 61   : 	
; 62   : 	SetItemData(tabIdx, dwSlotPos, c_rShopItemData);

  0000c	ff 75 0c	 push	 DWORD PTR _c_rShopItemData$[ebp]
  0000f	f7 e6		 mul	 esi
  00011	c1 ea 05	 shr	 edx, 5
  00014	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00017	c1 e0 03	 shl	 eax, 3
  0001a	2b f0		 sub	 esi, eax
  0001c	56		 push	 esi
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
  00023	5e		 pop	 esi

; 63   : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z ENDP ; CPythonShop::SetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?Clear@CPythonShop@@QAEXXZ
_TEXT	SEGMENT
?Clear@CPythonShop@@QAEXXZ PROC				; CPythonShop::Clear, COMDAT
; _this$ = ecx

; 191  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 192  : 	m_isShoping = FALSE;

  00004	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 193  : 	m_isPrivateShop = FALSE;

  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 194  : 	m_isMainPlayerPrivateShop = FALSE;

  00012	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 195  : 	ClearPrivateShopStock();

  00019	e8 00 00 00 00	 call	 ?ClearPrivateShopStock@CPythonShop@@QAEXXZ ; CPythonShop::ClearPrivateShopStock

; 196  : 	m_bTabCount = 1;

  0001e	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
  00022	bf 03 00 00 00	 mov	 edi, 3
  00027	83 c6 30	 add	 esi, 48			; 00000030H
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Clear:

; 199  : 		memset (m_aShoptabs[i].items, 0, sizeof(TShopItemData) * SHOP_HOST_ITEM_MAX_NUM);

  00030	68 b8 06 00 00	 push	 1720			; 000006b8H
  00035	6a 00		 push	 0
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	81 c6 d4 06 00
	00		 add	 esi, 1748		; 000006d4H
  00046	83 ef 01	 sub	 edi, 1
  00049	75 e5		 jne	 SHORT $LL4@Clear

; 197  : 
; 198  : 	for (int i = 0; i < SHOP_TAB_COUNT_MAX; i++)

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 200  : }

  0004d	c3		 ret	 0
?Clear@CPythonShop@@QAEXXZ ENDP				; CPythonShop::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?IsOpen@CPythonShop@@QAEHXZ
_TEXT	SEGMENT
?IsOpen@CPythonShop@@QAEHXZ PROC			; CPythonShop::IsOpen, COMDAT
; _this$ = ecx

; 177  : 	return m_isShoping;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 178  : }

  00003	c3		 ret	 0
?IsOpen@CPythonShop@@QAEHXZ ENDP			; CPythonShop::IsOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.h
;	COMDAT ?GetTabCount@CPythonShop@@QAEEXZ
_TEXT	SEGMENT
?GetTabCount@CPythonShop@@QAEEXZ PROC			; CPythonShop::GetTabCount, COMDAT
; _this$ = ecx

; 35   : 		BYTE GetTabCount() { return m_bTabCount; }

  00000	8a 41 10	 mov	 al, BYTE PTR [ecx+16]
  00003	c3		 ret	 0
?GetTabCount@CPythonShop@@QAEEXZ ENDP			; CPythonShop::GetTabCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.h
;	COMDAT ??0ShopTab@CPythonShop@@QAE@XZ
_TEXT	SEGMENT
??0ShopTab@CPythonShop@@QAE@XZ PROC			; CPythonShop::ShopTab::ShopTab, COMDAT
; _this$ = ecx

; 68   : 			ShopTab()

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 71   : 			}

  00003	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0

; 860  :         _My_data._Mysize = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00010	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00017	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.h

; 70   : 				coinType = SHOP_COIN_TYPE_GOLD;

  0001b	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 71   : 			}

  0001e	c3		 ret	 0
??0ShopTab@CPythonShop@@QAE@XZ ENDP			; CPythonShop::ShopTab::ShopTab
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetTabCoinType@CPythonShop@@QAEEE@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
?GetTabCoinType@CPythonShop@@QAEEE@Z PROC		; CPythonShop::GetTabCoinType, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	0f b6 d0	 movzx	 edx, al
  00009	3a 41 10	 cmp	 al, BYTE PTR [ecx+16]
  0000c	72 16		 jb	 SHORT $LN2@GetTabCoin

; 29   : 	{
; 30   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  0000e	6a 03		 push	 3
  00010	52		 push	 edx
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00016	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 31   : 		return 0xff;

  0001e	0c ff		 or	 al, 255			; 000000ffH

; 34   : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN2@GetTabCoin:

; 32   : 	}
; 33   : 	return m_aShoptabs[tabIdx].coinType;

  00024	69 c2 d4 06 00
	00		 imul	 eax, edx, 1748
  0002a	8a 44 08 14	 mov	 al, BYTE PTR [eax+ecx+20]

; 34   : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?GetTabCoinType@CPythonShop@@QAEEE@Z ENDP		; CPythonShop::GetTabCoinType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetTabName@CPythonShop@@QAEPBDE@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
?GetTabName@CPythonShop@@QAEPBDE@Z PROC			; CPythonShop::GetTabName, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	0f b6 d0	 movzx	 edx, al
  00009	3a 41 10	 cmp	 al, BYTE PTR [ecx+16]
  0000c	72 16		 jb	 SHORT $LN2@GetTabName

; 49   : 	{
; 50   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  0000e	6a 03		 push	 3
  00010	52		 push	 edx
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00016	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 		return NULL;

  0001e	33 c0		 xor	 eax, eax

; 55   : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN2@GetTabName:

; 52   : 	}
; 53   : 
; 54   : 	return m_aShoptabs[tabIdx].name.c_str();

  00024	69 c2 d4 06 00
	00		 imul	 eax, edx, 1748
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2356 :         return _Mypair._Myval2._Myptr();

  0002a	83 c0 18	 add	 eax, 24			; 00000018H
  0002d	03 c1		 add	 eax, ecx

; 453  :         return _Myres > _Small_string_capacity;

  0002f	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 445  :         if (_Large_mode_engaged()) {

  00033	76 02		 jbe	 SHORT $LN1@GetTabName

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  00035	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@GetTabName:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 55   : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?GetTabName@CPythonShop@@QAEPBDE@Z ENDP			; CPythonShop::GetTabName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
_c_ppItemData$ = 12					; size = 4
?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z PROC ; CPythonShop::GetItemData, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 67   : 	BYTE tabIdx = dwIndex / SHOP_HOST_ITEM_MAX_NUM;
; 68   : 	DWORD dwSlotPos = dwIndex % SHOP_HOST_ITEM_MAX_NUM;

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwIndex$[ebp]
  00007	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH

; 69   : 
; 70   : 	return GetItemData(tabIdx, dwSlotPos, c_ppItemData);

  0000c	ff 75 0c	 push	 DWORD PTR _c_ppItemData$[ebp]
  0000f	f7 e6		 mul	 esi
  00011	c1 ea 05	 shr	 edx, 5
  00014	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00017	c1 e0 03	 shl	 eax, 3
  0001a	2b f0		 sub	 esi, eax
  0001c	56		 push	 esi
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  00023	5e		 pop	 esi

; 71   : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ENDP ; CPythonShop::GetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_dwSlotPos$ = 12					; size = 4
_c_ppItemData$ = 16					; size = 4
?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z PROC ; CPythonShop::GetItemData, COMDAT
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	if (tabIdx >= SHOP_TAB_COUNT_MAX || dwSlotPos >= SHOP_HOST_ITEM_MAX_NUM)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _dwSlotPos$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3c 03		 cmp	 al, 3
  0000e	73 27		 jae	 SHORT $LN3@GetItemDat
  00010	83 fa 28	 cmp	 edx, 40			; 00000028H
  00013	73 22		 jae	 SHORT $LN3@GetItemDat

; 90   : 	}
; 91   : 
; 92   : 	*c_ppItemData = &m_aShoptabs[tabIdx].items[dwSlotPos];

  00015	0f b6 c0	 movzx	 eax, al
  00018	69 c8 d4 06 00
	00		 imul	 ecx, eax, 1748
  0001e	6b c2 2b	 imul	 eax, edx, 43
  00021	03 ce		 add	 ecx, esi
  00023	83 c0 30	 add	 eax, 48			; 00000030H
  00026	03 c8		 add	 ecx, eax
  00028	8b 45 10	 mov	 eax, DWORD PTR _c_ppItemData$[ebp]
  0002b	5e		 pop	 esi
  0002c	89 08		 mov	 DWORD PTR [eax], ecx

; 93   : 
; 94   : 	return TRUE;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 95   : }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
$LN3@GetItemDat:

; 87   : 	{
; 88   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d. dwSlotPos(%d) must be less than %d", tabIdx, SHOP_TAB_COUNT_MAX, dwSlotPos, SHOP_HOST_ITEM_MAX_NUM);

  00037	6a 28		 push	 40			; 00000028H
  00039	52		 push	 edx
  0003a	6a 03		 push	 3
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00045	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0004a	83 c4 14	 add	 esp, 20			; 00000014H

; 89   : 		return FALSE;

  0004d	33 c0		 xor	 eax, eax
  0004f	5e		 pop	 esi

; 95   : }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z ENDP ; CPythonShop::GetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?ClearPrivateShopStock@CPythonShop@@QAEXXZ
_TEXT	SEGMENT
?ClearPrivateShopStock@CPythonShop@@QAEXXZ PROC		; CPythonShop::ClearPrivateShopStock, COMDAT
; _this$ = ecx

; 106  : {

  00000	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1373 :         auto _Head = _Scary->_Myhead;

  00001	8b b1 90 14 00
	00		 mov	 esi, DWORD PTR [ecx+5264]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 106  : {

  00007	57		 push	 edi

; 107  : 	m_PrivateShopItemStock.clear();

  00008	8d b9 90 14 00
	00		 lea	 edi, DWORD PTR [ecx+5264]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1374 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  0000e	8b cf		 mov	 ecx, edi
  00010	ff 76 04	 push	 DWORD PTR [esi+4]
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1375 :         _Head->_Parent  = _Head;

  00019	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1376 :         _Head->_Left    = _Head;

  0001c	89 36		 mov	 DWORD PTR [esi], esi

; 1377 :         _Head->_Right   = _Head;

  0001e	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1378 :         _Scary->_Mysize = 0;

  00021	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 108  : }

  0002a	c3		 ret	 0
?ClearPrivateShopStock@CPythonShop@@QAEXXZ ENDP		; CPythonShop::ClearPrivateShopStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z
_TEXT	SEGMENT
_SellingItem$ = -60					; size = 13
$T2 = -44						; size = 16
__Loc$3 = -40						; size = 12
$T4 = -28						; size = 12
$T5 = -24						; size = 8
$T6 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_ItemPos$ = 8						; size = 3
_dwDisplayPos$ = 12					; size = 1
_dwPrice$ = 16						; size = 4
?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z PROC ; CPythonShop::AddPrivateShopItemStock, COMDAT
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 111  : 	DelPrivateShopItemStock(ItemPos);

  0002a	66 8b 45 08	 mov	 ax, WORD PTR _ItemPos$[ebp]
  0002e	51		 push	 ecx
  0002f	8b d4		 mov	 edx, esp
  00031	66 89 02	 mov	 WORD PTR [edx], ax
  00034	8a 45 0a	 mov	 al, BYTE PTR _ItemPos$[ebp+2]
  00037	88 42 02	 mov	 BYTE PTR [edx+2], al
  0003a	e8 00 00 00 00	 call	 ?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ; CPythonShop::DelPrivateShopItemStock

; 116  : 	SellingItem.pos = ItemPos;

  0003f	8a 45 0a	 mov	 al, BYTE PTR _ItemPos$[ebp+2]

; 117  : 	SellingItem.price = dwPrice;
; 118  : 	SellingItem.display_pos = dwDisplayPos;
; 119  : 	m_PrivateShopItemStock.insert(std::make_pair(ItemPos, SellingItem));

  00042	8d be 90 14 00
	00		 lea	 edi, DWORD PTR [esi+5264]
  00048	66 8b 5d 08	 mov	 bx, WORD PTR _ItemPos$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  0004c	8b cf		 mov	 ecx, edi
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 116  : 	SellingItem.pos = ItemPos;

  0004e	88 45 cb	 mov	 BYTE PTR _SellingItem$[ebp+7], al
  00051	88 45 f3	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00054	88 45 d6	 mov	 BYTE PTR $T2[ebp+2], al
  00057	8b 45 10	 mov	 eax, DWORD PTR _dwPrice$[ebp]
  0005a	89 45 df	 mov	 DWORD PTR $T2[ebp+11], eax
  0005d	8a 45 0c	 mov	 al, BYTE PTR _dwDisplayPos$[ebp]
  00060	88 45 e3	 mov	 BYTE PTR $T2[ebp+15], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  00063	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  00066	50		 push	 eax
  00067	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 114  : 	SellingItem.vnum = 0;

  0006a	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _SellingItem$[ebp], 0

; 115  : 	SellingItem.count = 0;

  00071	c6 45 c8 00	 mov	 BYTE PTR _SellingItem$[ebp+4], 0

; 116  : 	SellingItem.pos = ItemPos;

  00075	66 89 5d c9	 mov	 WORD PTR _SellingItem$[ebp+5], bx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00079	f3 0f 7e 45 c4	 movq	 xmm0, QWORD PTR _SellingItem$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  0007e	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0007f	66 89 5d d4	 mov	 WORD PTR $T2[ebp], bx
  00083	66 0f d6 45 d7	 movq	 QWORD PTR $T2[ebp+3], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  00088	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  0008d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00090	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00094	66 0f d6 45 d8	 movq	 QWORD PTR __Loc$3[ebp], xmm0

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00099	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0009d	75 11		 jne	 SHORT $LN23@AddPrivate
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0009f	3a 59 0e	 cmp	 bl, BYTE PTR [ecx+14]
  000a2	72 0c		 jb	 SHORT $LN23@AddPrivate
  000a4	75 6c		 jne	 SHORT $LN107@AddPrivate
  000a6	66 8b 45 09	 mov	 ax, WORD PTR _ItemPos$[ebp+1]
  000aa	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  000ae	73 62		 jae	 SHORT $LN107@AddPrivate
$LN23@AddPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1648 :         if (max_size() == _Get_scary()->_Mysize) {

  000b0	81 7f 04 ff ff
	ff 07		 cmp	 DWORD PTR [edi+4], 134217727 ; 07ffffffH
  000b7	74 6d		 je	 SHORT $LN129@AddPrivate

; 1023 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000b9	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  000bb	89 7d e8	 mov	 DWORD PTR $T5[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  000c5	6a 20		 push	 32			; 00000020H
  000c7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0
  000ce	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000d3	8a 4d f3	 mov	 cl, BYTE PTR $T6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  000d6	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000d9	f3 0f 7e 45 c4	 movq	 xmm0, QWORD PTR _SellingItem$[ebp]
  000de	66 89 58 0e	 mov	 WORD PTR [eax+14], bx
  000e2	88 48 10	 mov	 BYTE PTR [eax+16], cl
  000e5	8b 4d 10	 mov	 ecx, DWORD PTR _dwPrice$[ebp]
  000e8	66 0f d6 40 11	 movq	 QWORD PTR [eax+17], xmm0
  000ed	89 48 19	 mov	 DWORD PTR [eax+25], ecx
  000f0	8a 4d 0c	 mov	 cl, BYTE PTR _dwDisplayPos$[ebp]
  000f3	88 48 1d	 mov	 BYTE PTR [eax+29], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000f6	8b cf		 mov	 ecx, edi
  000f8	50		 push	 eax
  000f9	ff 75 dc	 push	 DWORD PTR __Loc$3[ebp+4]

; 831  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000fc	89 30		 mov	 DWORD PTR [eax], esi

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000fe	ff 75 d8	 push	 DWORD PTR __Loc$3[ebp]

; 832  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00101	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 833  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00104	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 834  :         this->_Ptr->_Color = _Red;

  00107	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0010d	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
$LN107@AddPrivate:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 120  : }

  00112	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 0c 00	 ret	 12			; 0000000cH
$LN129@AddPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1649 :             _Throw_tree_length_error();

  00126	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN127@AddPrivate:
  0012b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z$2:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z ENDP ; CPythonShop::AddPrivateShopItemStock
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
;	COMDAT ??0SShopItemTable@@QAE@XZ
_TEXT	SEGMENT
??0SShopItemTable@@QAE@XZ PROC				; SShopItemTable::SShopItemTable, COMDAT
; _this$ = ecx

; 187  : 		cell = WORD_MAX;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00005	c6 41 05 01	 mov	 BYTE PTR [ecx+5], 1
  00009	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0SShopItemTable@@QAE@XZ ENDP				; SShopItemTable::SShopItemTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
_ItemPos$ = 8						; size = 3
?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z PROC ; CPythonShop::DelPrivateShopItemStock, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8d 45 08	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  0000a	50		 push	 eax

; 1152 :         return iterator(_Scary->_Myhead, _Scary);

  0000b	8d b1 90 14 00
	00		 lea	 esi, DWORD PTR [ecx+5264]

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00011	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00014	8b ce		 mov	 ecx, esi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001c	8b 55 fc	 mov	 edx, DWORD PTR __Loc$1[ebp+8]
  0001f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00023	75 23		 jne	 SHORT $LN1@DelPrivate
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00025	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  00028	38 45 08	 cmp	 BYTE PTR _ItemPos$[ebp], al
  0002b	72 1b		 jb	 SHORT $LN1@DelPrivate
  0002d	75 0a		 jne	 SHORT $LN45@DelPrivate
  0002f	66 8b 45 09	 mov	 ax, WORD PTR _ItemPos$[ebp+1]
  00033	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00037	72 0f		 jb	 SHORT $LN1@DelPrivate
$LN45@DelPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  00039	39 16		 cmp	 DWORD PTR [esi], edx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 123  : 	if (m_PrivateShopItemStock.end() == m_PrivateShopItemStock.find(ItemPos))

  0003b	74 0b		 je	 SHORT $LN1@DelPrivate

; 124  : 		return;
; 125  : 
; 126  : 	m_PrivateShopItemStock.erase(ItemPos);

  0003d	8d 45 08	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  00040	8b ce		 mov	 ecx, esi
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase
$LN1@DelPrivate:

; 127  : }

  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ENDP ; CPythonShop::DelPrivateShopItemStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetPrivateShopItemPrice@CPythonShop@@QAEHUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
_ItemPos$ = 8						; size = 3
?GetPrivateShopItemPrice@CPythonShop@@QAEHUSItemPos@@@Z PROC ; CPythonShop::GetPrivateShopItemPrice, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8d 45 08	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  0000a	50		 push	 eax
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 130  : 	TPrivateShopItemStock::iterator itor = m_PrivateShopItemStock.find(ItemPos);

  0000b	8d b1 90 14 00
	00		 lea	 esi, DWORD PTR [ecx+5264]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00011	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00014	8b ce		 mov	 ecx, esi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Loc$1[ebp+8]
  0001f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00023	75 22		 jne	 SHORT $LN55@GetPrivate
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00025	8a 48 0e	 mov	 cl, BYTE PTR [eax+14]
  00028	38 4d 08	 cmp	 BYTE PTR _ItemPos$[ebp], cl
  0002b	72 1a		 jb	 SHORT $LN55@GetPrivate
  0002d	75 0a		 jne	 SHORT $LN54@GetPrivate
  0002f	66 8b 4d 09	 mov	 cx, WORD PTR _ItemPos$[ebp+1]
  00033	66 3b 48 0f	 cmp	 cx, WORD PTR [eax+15]
  00037	72 0e		 jb	 SHORT $LN55@GetPrivate
$LN54@GetPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00039	39 06		 cmp	 DWORD PTR [esi], eax
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 132  : 	if (m_PrivateShopItemStock.end() == itor)

  0003b	74 0a		 je	 SHORT $LN55@GetPrivate

; 134  : 
; 135  : 	TShopItemTable & rShopItemTable = itor->second;
; 136  : 	return rShopItemTable.price;

  0003d	8b 40 19	 mov	 eax, DWORD PTR [eax+25]
  00040	5e		 pop	 esi

; 137  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN55@GetPrivate:

; 133  : 		return 0;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 137  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?GetPrivateShopItemPrice@CPythonShop@@QAEHUSItemPos@@@Z ENDP ; CPythonShop::GetPrivateShopItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z
_TEXT	SEGMENT
_rkLeft$ = 8						; size = 4
_rkRight$ = 12						; size = 4
??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z PROC	; ItemStockSortFunc::operator(), COMDAT
; _this$dead$ = ecx

; 141  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _rkLeft$[ebp]
  00006	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  00009	8b 45 0c	 mov	 eax, DWORD PTR _rkRight$[ebp]
  0000c	3a 48 0c	 cmp	 cl, BYTE PTR [eax+12]
  0000f	0f 92 c0	 setb	 al

; 143  : 	}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z ENDP	; ItemStockSortFunc::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
_TEXT	SEGMENT
_ItemStock$ = -32					; size = 12
_this$1$ = -20						; size = 4
_itor$ = -16						; size = 4
__Bytes$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szName$ = 8						; size = 4
$T4 = 8							; size = 1
?BuildPrivateShop@CPythonShop@@QAEXPBD@Z PROC		; CPythonShop::BuildPrivateShop, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d ec	 mov	 DWORD PTR _this$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002d	33 ff		 xor	 edi, edi
  0002f	33 f6		 xor	 esi, esi
  00031	33 d2		 xor	 edx, edx
  00033	89 7d e0	 mov	 DWORD PTR _ItemStock$[ebp], edi
  00036	89 75 e4	 mov	 DWORD PTR _ItemStock$[ebp+4], esi
  00039	89 55 e8	 mov	 DWORD PTR _ItemStock$[ebp+8], edx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 147  : 	std::vector<TShopItemTable> ItemStock;

  0003c	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx

; 148  : 	ItemStock.reserve(m_PrivateShopItemStock.size());

  0003f	8b 83 94 14 00
	00		 mov	 eax, DWORD PTR [ebx+5268]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1725 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00045	85 c0		 test	 eax, eax
  00047	0f 84 97 00 00
	00		 je	 $LN88@BuildPriva

; 1726 :             if (_Newcapacity > max_size()) {

  0004d	3d 13 3b b1 13	 cmp	 eax, 330382099		; 13b13b13H
  00052	0f 87 62 01 00
	00		 ja	 $LN218@BuildPriva
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00058	6b c0 0d	 imul	 eax, eax, 13
  0005b	89 45 f0	 mov	 DWORD PTR __Bytes$1$[ebp], eax

; 227  :     if (_Bytes == 0) {

  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN35@BuildPriva

; 228  :         return nullptr;

  00062	33 db		 xor	 ebx, ebx
  00064	eb 1f		 jmp	 SHORT $LN34@BuildPriva
$LN35@BuildPriva:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00066	50		 push	 eax
  00067	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0006c	72 07		 jb	 SHORT $LN37@BuildPriva

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0006e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00073	eb 05		 jmp	 SHORT $LN216@BuildPriva
$LN37@BuildPriva:

; 136  :         return ::operator new(_Bytes);

  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN216@BuildPriva:

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  0007a	8b 7d e0	 mov	 edi, DWORD PTR _ItemStock$[ebp]
  0007d	8b d8		 mov	 ebx, eax
  0007f	8b 75 e4	 mov	 esi, DWORD PTR _ItemStock$[ebp+4]
  00082	83 c4 04	 add	 esp, 4
$LN34@BuildPriva:
  00085	53		 push	 ebx
  00086	8b d6		 mov	 edx, esi
  00088	8b cf		 mov	 ecx, edi
  0008a	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  0008f	8b 4d e0	 mov	 ecx, DWORD PTR _ItemStock$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00092	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  00095	85 c9		 test	 ecx, ecx
  00097	74 36		 je	 SHORT $LN69@BuildPriva

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2071 :             _ASAN_VECTOR_REMOVE;
; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00099	8b 45 e8	 mov	 eax, DWORD PTR _ItemStock$[ebp+8]
  0009c	2b c1		 sub	 eax, ecx
  0009e	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a4	6b d0 0d	 imul	 edx, eax, 13
  000a7	8b c1		 mov	 eax, ecx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000a9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000af	72 14		 jb	 SHORT $LN77@BuildPriva

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b1	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  000b4	83 c2 23	 add	 edx, 35			; 00000023H
  000b7	2b c1		 sub	 eax, ecx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b9	83 c0 fc	 add	 eax, -4			; fffffffcH
  000bc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000bf	0f 87 fa 00 00
	00		 ja	 $LN196@BuildPriva
$LN77@BuildPriva:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000c5	52		 push	 edx
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000cc	83 c4 08	 add	 esp, 8
$LN69@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  000cf	8b 55 f0	 mov	 edx, DWORD PTR __Bytes$1$[ebp]
  000d2	8b fb		 mov	 edi, ebx
  000d4	8b f3		 mov	 esi, ebx
  000d6	89 7d e0	 mov	 DWORD PTR _ItemStock$[ebp], edi
  000d9	03 d3		 add	 edx, ebx
  000db	89 75 e4	 mov	 DWORD PTR _ItemStock$[ebp+4], esi
  000de	8b 5d ec	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000e1	89 55 e8	 mov	 DWORD PTR _ItemStock$[ebp+8], edx
$LN88@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1142 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  000e4	8b 8b 90 14 00
	00		 mov	 ecx, DWORD PTR [ebx+5264]

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  000ea	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ec	89 45 f0	 mov	 DWORD PTR _itor$[ebp], eax
  000ef	3b c1		 cmp	 eax, ecx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 151  : 	for (; itor != m_PrivateShopItemStock.end(); ++itor)

  000f1	74 4e		 je	 SHORT $LN3@BuildPriva
$LL4@BuildPriva:

; 152  : 	{
; 153  : 		ItemStock.push_back(itor->second);

  000f3	8d 48 11	 lea	 ecx, DWORD PTR [eax+17]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

  000f6	3b f2		 cmp	 esi, edx
  000f8	74 1f		 je	 SHORT $LN147@BuildPriva
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  000fa	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  000fe	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00102	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00105	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00108	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  0010b	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

  0010e	8b 75 e4	 mov	 esi, DWORD PTR _ItemStock$[ebp+4]
  00111	83 c6 0d	 add	 esi, 13			; 0000000dH
  00114	89 75 e4	 mov	 DWORD PTR _ItemStock$[ebp+4], esi

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00117	eb 0d		 jmp	 SHORT $LN2@BuildPriva
$LN147@BuildPriva:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00119	51		 push	 ecx
  0011a	56		 push	 esi
  0011b	8d 4d e0	 lea	 ecx, DWORD PTR _ItemStock$[ebp]
  0011e	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
  00123	8b 75 e4	 mov	 esi, DWORD PTR _ItemStock$[ebp+4]
$LN2@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 198  :         _Mybase::operator++();

  00126	8d 4d f0	 lea	 ecx, DWORD PTR _itor$[ebp]
  00129	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 232  :         return this->_Ptr == _Right._Ptr;

  0012e	8b 45 f0	 mov	 eax, DWORD PTR _itor$[ebp]
  00131	3b 83 90 14 00
	00		 cmp	 eax, DWORD PTR [ebx+5264]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 151  : 	for (; itor != m_PrivateShopItemStock.end(); ++itor)

  00137	74 05		 je	 SHORT $LN213@BuildPriva
  00139	8b 55 e8	 mov	 edx, DWORD PTR _ItemStock$[ebp+8]
  0013c	eb b5		 jmp	 SHORT $LL4@BuildPriva
$LN213@BuildPriva:
  0013e	8b 7d e0	 mov	 edi, DWORD PTR _ItemStock$[ebp]
$LN3@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8403 :     _STD _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _STD _Pass_fn(_Pred));

  00141	ff 75 08	 push	 DWORD PTR $T4[ebp]
  00144	8b c6		 mov	 eax, esi
  00146	8b d6		 mov	 edx, esi
  00148	2b c7		 sub	 eax, edi
  0014a	8b cf		 mov	 ecx, edi
  0014c	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 158  : 	CPythonNetworkStream::Instance().SendBuildPrivateShopPacket(c_szName, ItemStock);

  00158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0015e	8d 45 e0	 lea	 eax, DWORD PTR _ItemStock$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8403 :     _STD _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _STD _Pass_fn(_Pred));

  00161	83 c4 08	 add	 esp, 8
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 158  : 	CPythonNetworkStream::Instance().SendBuildPrivateShopPacket(c_szName, ItemStock);

  00164	50		 push	 eax
  00165	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  00168	e8 00 00 00 00	 call	 ?SendBuildPrivateShopPacket@CPythonNetworkStream@@QAE_NPBDABV?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@@Z ; CPythonNetworkStream::SendBuildPrivateShopPacket
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  0016d	8b 4d e0	 mov	 ecx, DWORD PTR _ItemStock$[ebp]
  00170	85 c9		 test	 ecx, ecx
  00172	74 32		 je	 SHORT $LN189@BuildPriva

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00174	8b 45 e8	 mov	 eax, DWORD PTR _ItemStock$[ebp+8]
  00177	2b c1		 sub	 eax, ecx
  00179	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0017f	6b d0 0d	 imul	 edx, eax, 13
  00182	8b c1		 mov	 eax, ecx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00184	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0018a	72 10		 jb	 SHORT $LN197@BuildPriva

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0018c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0018f	83 c2 23	 add	 edx, 35			; 00000023H
  00192	2b c1		 sub	 eax, ecx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00194	83 c0 fc	 add	 eax, -4			; fffffffcH
  00197	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0019a	77 23		 ja	 SHORT $LN196@BuildPriva
$LN197@BuildPriva:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0019c	52		 push	 edx
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001a3	83 c4 08	 add	 esp, 8
$LN189@BuildPriva:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 159  : }

  001a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b0	59		 pop	 ecx
  001b1	5f		 pop	 edi
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c2 04 00	 ret	 4
$LN218@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1727 :                 _Xlength();

  001ba	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
$LN196@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001bf	6a 00		 push	 0
  001c1	6a 00		 push	 0
  001c3	6a 00		 push	 0
  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 __invoke_watson
$LN215@BuildPriva:
  001ce	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _ItemStock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?BuildPrivateShop@CPythonShop@@QAEXPBD@Z ENDP		; CPythonShop::BuildPrivateShop
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?Open@CPythonShop@@QAEXHH@Z
_TEXT	SEGMENT
_isPrivateShop$ = 8					; size = 4
_isMainPrivateShop$ = 12				; size = 4
?Open@CPythonShop@@QAEXHH@Z PROC			; CPythonShop::Open, COMDAT
; _this$ = ecx

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	m_isShoping = TRUE;
; 164  : 	m_isPrivateShop = isPrivateShop;

  00003	8b 45 08	 mov	 eax, DWORD PTR _isPrivateShop$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 165  : 	m_isMainPlayerPrivateShop = isMainPrivateShop;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _isMainPrivateShop$[ebp]
  0000c	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00013	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 166  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?Open@CPythonShop@@QAEXHH@Z ENDP			; CPythonShop::Open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?Close@CPythonShop@@QAEXXZ
_TEXT	SEGMENT
?Close@CPythonShop@@QAEXXZ PROC				; CPythonShop::Close, COMDAT
; _this$ = ecx

; 170  : 	m_isShoping = FALSE;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 171  : 	m_isPrivateShop = FALSE;

  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 172  : 	m_isMainPlayerPrivateShop = FALSE;

  0000e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 173  : }

  00015	c3		 ret	 0
?Close@CPythonShop@@QAEXXZ ENDP				; CPythonShop::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?IsPrivateShop@CPythonShop@@QAEHXZ
_TEXT	SEGMENT
?IsPrivateShop@CPythonShop@@QAEHXZ PROC			; CPythonShop::IsPrivateShop, COMDAT
; _this$ = ecx

; 182  : 	return m_isPrivateShop;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 183  : }

  00003	c3		 ret	 0
?IsPrivateShop@CPythonShop@@QAEHXZ ENDP			; CPythonShop::IsPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ
_TEXT	SEGMENT
?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ PROC	; CPythonShop::IsMainPlayerPrivateShop, COMDAT
; _this$ = ecx

; 187  : 	return m_isMainPlayerPrivateShop;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 188  : }

  00003	c3		 ret	 0
?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ ENDP	; CPythonShop::IsMainPlayerPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonShop@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonShop@@UAEPAXI@Z PROC				; CPythonShop::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonShop@@UAE@XZ	; CPythonShop::~CPythonShop
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 98 14 00 00	 push	 5272			; 00001498H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCPythonShop@@UAEPAXI@Z ENDP				; CPythonShop::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1ShopTab@CPythonShop@@QAE@XZ
_TEXT	SEGMENT
??1ShopTab@CPythonShop@@QAE@XZ PROC			; CPythonShop::ShopTab::~ShopTab, COMDAT
; _this$ = ecx
  00000	83 c1 04	 add	 ecx, 4

; 1383 :         _Tidy_deallocate();

  00003	e9 00 00 00 00	 jmp	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1ShopTab@CPythonShop@@QAE@XZ ENDP			; CPythonShop::ShopTab::~ShopTab
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ PROC ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::~map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 777  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 20		 push	 32			; 00000020H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::~map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopOpen@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_isPrivateShop$ = -8					; size = 4
_isMainPrivateShop$ = -4				; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopOpen@@YAPAU_object@@PAU1@0@Z PROC			; shopOpen, COMDAT

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 213  : 	int isPrivateShop = false;
; 214  : 	PyTuple_GetInteger(poArgs, 0, &isPrivateShop);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _isPrivateShop$[ebp]
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _isPrivateShop$[ebp], 0
  00010	50		 push	 eax
  00011	6a 00		 push	 0
  00013	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00016	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger

; 215  : 	int isMainPrivateShop = false;
; 216  : 	PyTuple_GetInteger(poArgs, 1, &isMainPrivateShop);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _isMainPrivateShop$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _isMainPrivateShop$[ebp], 0
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0002b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger

; 217  : 
; 218  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 219  : 	rkShop.Open(isPrivateShop, isMainPrivateShop);

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00036	83 c4 18	 add	 esp, 24			; 00000018H
  00039	ff 75 fc	 push	 DWORD PTR _isMainPrivateShop$[ebp]
  0003c	ff 75 f8	 push	 DWORD PTR _isPrivateShop$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Open@CPythonShop@@QAEXHH@Z ; CPythonShop::Open

; 220  : 	return Py_BuildNone();

  00044	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 221  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?shopOpen@@YAPAU_object@@PAU1@0@Z ENDP			; shopOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopClose@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopClose@@YAPAU_object@@PAU1@0@Z PROC			; shopClose, COMDAT

; 225  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 226  : 	rkShop.Close();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Close@CPythonShop@@QAEXXZ ; CPythonShop::Close

; 227  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?shopClose@@YAPAU_object@@PAU1@0@Z ENDP			; shopClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopIsOpen@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopIsOpen@@YAPAU_object@@PAU1@0@Z PROC		; shopIsOpen, COMDAT

; 232  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 233  : 	return Py_BuildValue("i", rkShop.IsOpen());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsOpen@CPythonShop@@QAEHXZ ; CPythonShop::IsOpen
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 234  : }

  0001a	c3		 ret	 0
?shopIsOpen@@YAPAU_object@@PAU1@0@Z ENDP		; shopIsOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z PROC		; shopIsPrviateShop, COMDAT

; 238  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 239  : 	return Py_BuildValue("i", rkShop.IsPrivateShop());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsPrivateShop@CPythonShop@@QAEHXZ ; CPythonShop::IsPrivateShop
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 240  : }

  0001a	c3		 ret	 0
?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z ENDP		; shopIsPrviateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z PROC ; shopIsMainPlayerPrivateShop, COMDAT

; 244  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 245  : 	return Py_BuildValue("i", rkShop.IsMainPlayerPrivateShop());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ ; CPythonShop::IsMainPlayerPrivateShop
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 246  : }

  0001a	c3		 ret	 0
?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z ENDP ; shopIsMainPlayerPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemID@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -8					; size = 4
_nPos$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemID@@YAPAU_object@@PAU1@0@Z PROC		; shopGetItemID, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 250  : 	int nPos;
; 251  : 	if (!PyTuple_GetInteger(poArgs, 0, &nPos))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _nPos$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte

; 252  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 259  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 253  : 
; 254  : 	const TShopItemData * c_pItemData;
; 255  : 	if (CPythonShop::Instance().GetItemData(nPos, &c_pItemData))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _nPos$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  0003b	85 c0		 test	 eax, eax
  0003d	74 17		 je	 SHORT $LN3@shopGetIte

; 256  : 		return Py_BuildValue("i", c_pItemData->vnum);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  00042	ff 30		 push	 DWORD PTR [eax]

; 259  : }

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004f	83 c4 08	 add	 esp, 8
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN3@shopGetIte:

; 257  : 
; 258  : 	return Py_BuildValue("i", 0);

  00056	6a 00		 push	 0

; 259  : }

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00063	83 c4 08	 add	 esp, 8
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?shopGetItemID@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetItemID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -8					; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemCount@@YAPAU_object@@PAU1@0@Z PROC		; shopGetItemCount, COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 263  : 	int iIndex;
; 264  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte

; 265  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 272  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 266  : 
; 267  : 	const TShopItemData * c_pItemData;
; 268  : 	if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  0003b	85 c0		 test	 eax, eax
  0003d	74 1a		 je	 SHORT $LN3@shopGetIte

; 269  : 		return Py_BuildValue("i", c_pItemData->count);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  00042	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00046	50		 push	 eax

; 272  : }

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00052	83 c4 08	 add	 esp, 8
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN3@shopGetIte:

; 270  : 
; 271  : 	return Py_BuildValue("i", 0);

  00059	6a 00		 push	 0

; 272  : }

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00066	83 c4 08	 add	 esp, 8
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?shopGetItemCount@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetItemCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -8					; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z PROC		; shopGetItemPrice, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 276  : 	int iIndex;
; 277  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte

; 278  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 285  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 279  : 
; 280  : 	const TShopItemData * c_pItemData;
; 281  : 	if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  0003b	85 c0		 test	 eax, eax
  0003d	74 18		 je	 SHORT $LN3@shopGetIte

; 282  : 		return Py_BuildValue("i", c_pItemData->price);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  00042	ff 70 04	 push	 DWORD PTR [eax+4]

; 285  : }

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00050	83 c4 08	 add	 esp, 8
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN3@shopGetIte:

; 283  : 
; 284  : 	return Py_BuildValue("i", 0);

  00057	6a 00		 push	 0

; 285  : }

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00064	83 c4 08	 add	 esp, 8
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -12					; size = 4
_iMetinSocketIndex$ = -8				; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z PROC	; shopGetItemMetinSocket, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 289  : 	int iIndex;
; 290  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte
$LN7@shopGetIte:

; 301  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 291  : 		return Py_BuildException();
; 292  : 	int iMetinSocketIndex;
; 293  : 	if (!PyTuple_GetInteger(poArgs, 1, &iMetinSocketIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _iMetinSocketIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@shopGetIte

; 294  : 		return Py_BuildException();
; 295  : 
; 296  : 	const TShopItemData * c_pItemData;
; 297  : 	if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00044	8d 45 f4	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00047	50		 push	 eax
  00048	ff 75 fc	 push	 DWORD PTR _iIndex$[ebp]
  0004b	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  00050	85 c0		 test	 eax, eax
  00052	74 1c		 je	 SHORT $LN4@shopGetIte

; 298  : 		return Py_BuildValue("i", c_pItemData->alSockets[iMetinSocketIndex]);

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _iMetinSocketIndex$[ebp]
  00057	8b 45 f4	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  0005a	ff 74 88 0a	 push	 DWORD PTR [eax+ecx*4+10]

; 301  : }

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00069	83 c4 08	 add	 esp, 8
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN4@shopGetIte:

; 299  : 
; 300  : 	return Py_BuildValue("i", 0);

  00070	6a 00		 push	 0

; 301  : }

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007d	83 c4 08	 add	 esp, 8
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z ENDP	; shopGetItemMetinSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$1 = -12					; size = 4
_iIndex$ = -8						; size = 4
_iAttrSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z PROC	; shopGetItemAttribute, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 305  : 	int iIndex;
; 306  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte
$LN8@shopGetIte:

; 320  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 307  : 		return Py_BuildException();
; 308  : 	int iAttrSlotIndex;
; 309  : 	if (!PyTuple_GetInteger(poArgs, 1, &iAttrSlotIndex))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iAttrSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN8@shopGetIte

; 310  : 		return Py_BuildException();
; 311  : 
; 312  : 	if (iAttrSlotIndex >= 0 && iAttrSlotIndex < ITEM_ATTRIBUTE_SLOT_MAX_NUM)

  0003e	83 7d fc 06	 cmp	 DWORD PTR _iAttrSlotIndex$[ebp], 6
  00042	77 3d		 ja	 SHORT $LN5@shopGetIte

; 313  : 	{
; 314  : 		const TShopItemData * c_pItemData;
; 315  : 		if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0004a	8d 45 f4	 lea	 eax, DWORD PTR _c_pItemData$1[ebp]
  0004d	50		 push	 eax
  0004e	ff 75 f8	 push	 DWORD PTR _iIndex$[ebp]
  00051	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  00056	85 c0		 test	 eax, eax
  00058	74 27		 je	 SHORT $LN5@shopGetIte

; 316  : 			return Py_BuildValue("ii", c_pItemData->aAttr[iAttrSlotIndex].bType, c_pItemData->aAttr[iAttrSlotIndex].sValue);

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _iAttrSlotIndex$[ebp]
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _c_pItemData$1[ebp]
  00060	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00063	03 c8		 add	 ecx, eax
  00065	0f bf 41 17	 movsx	 eax, WORD PTR [ecx+23]
  00069	50		 push	 eax
  0006a	0f b6 41 16	 movzx	 eax, BYTE PTR [ecx+22]
  0006e	50		 push	 eax

; 320  : }

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN5@shopGetIte:

; 317  : 	}
; 318  : 
; 319  : 	return Py_BuildValue("ii", 0, 0);

  00081	6a 00		 push	 0
  00083	6a 00		 push	 0

; 320  : }

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii@
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z ENDP	; shopGetItemAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z PROC	; shopClearPrivateShopStock, COMDAT

; 324  : 	CPythonShop::Instance().ClearPrivateShopStock();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ClearPrivateShopStock@CPythonShop@@QAEXXZ ; CPythonShop::ClearPrivateShopStock

; 325  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z ENDP	; shopClearPrivateShopStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDisplaySlotIndex$ = -20				; size = 4
_iPrice$ = -16						; size = 4
$T1 = -12						; size = 3
_wItemSlotIndex$ = -8					; size = 2
_bItemWindowType$ = -1					; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z PROC ; shopAddPrivateShopItemStock, COMDAT

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 329  : 	BYTE bItemWindowType;
; 330  : 	if (!PyTuple_GetInteger(poArgs, 0, &bItemWindowType))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bItemWindowType$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN2@shopAddPri
$LN13@shopAddPri:

; 344  : }

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@shopAddPri:

; 331  : 		return Py_BuildException();
; 332  : 	WORD wItemSlotIndex;
; 333  : 	if (!PyTuple_GetInteger(poArgs, 1, &wItemSlotIndex))

  0002c	8d 45 f8	 lea	 eax, DWORD PTR _wItemSlotIndex$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN13@shopAddPri

; 334  : 		return Py_BuildException();
; 335  : 	int iDisplaySlotIndex;
; 336  : 	if (!PyTuple_GetInteger(poArgs, 2, &iDisplaySlotIndex))

  0003f	8d 45 ec	 lea	 eax, DWORD PTR _iDisplaySlotIndex$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN13@shopAddPri

; 337  : 		return Py_BuildException();
; 338  : 	int iPrice;
; 339  : 	if (!PyTuple_GetInteger(poArgs, 3, &iPrice))

  00052	8d 45 f0	 lea	 eax, DWORD PTR _iPrice$[ebp]
  00055	50		 push	 eax
  00056	6a 03		 push	 3
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	84 c0		 test	 al, al
  00063	74 b8		 je	 SHORT $LN13@shopAddPri

; 340  : 		return Py_BuildException();
; 341  : 
; 342  : 	CPythonShop::Instance().AddPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex), iDisplaySlotIndex, iPrice);

  00065	ff 75 f0	 push	 DWORD PTR _iPrice$[ebp]
  00068	8a 45 ff	 mov	 al, BYTE PTR _bItemWindowType$[ebp]
  0006b	ff 75 ec	 push	 DWORD PTR _iDisplaySlotIndex$[ebp]
  0006e	88 45 f4	 mov	 BYTE PTR $T1[ebp], al
  00071	0f b7 45 f8	 movzx	 eax, WORD PTR _wItemSlotIndex$[ebp]
  00075	51		 push	 ecx
  00076	8b cc		 mov	 ecx, esp
  00078	66 89 45 f5	 mov	 WORD PTR $T1[ebp+1], ax
  0007c	0f b7 45 f4	 movzx	 eax, WORD PTR $T1[ebp]
  00080	66 89 01	 mov	 WORD PTR [ecx], ax
  00083	8a 45 f6	 mov	 al, BYTE PTR $T1[ebp+2]
  00086	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0008f	e8 00 00 00 00	 call	 ?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@EK@Z ; CPythonShop::AddPrivateShopItemStock

; 343  : 	return Py_BuildNone();

  00094	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 344  : }

  00099	5e		 pop	 esi
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ENDP ; shopAddPrivateShopItemStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 3
_wItemSlotIndex$ = -8					; size = 2
_bItemWindowType$ = -1					; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z PROC ; shopDelPrivateShopItemStock, COMDAT

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 347  : 	BYTE bItemWindowType;
; 348  : 	if (!PyTuple_GetInteger(poArgs, 0, &bItemWindowType))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bItemWindowType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopDelPri
$LN7@shopDelPri:

; 356  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopDelPri:

; 349  : 		return Py_BuildException();
; 350  : 	WORD wItemSlotIndex;
; 351  : 	if (!PyTuple_GetInteger(poArgs, 1, &wItemSlotIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _wItemSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@shopDelPri

; 352  : 		return Py_BuildException();
; 353  : 
; 354  : 	CPythonShop::Instance().DelPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex));

  0003e	8a 45 ff	 mov	 al, BYTE PTR _bItemWindowType$[ebp]
  00041	88 45 f4	 mov	 BYTE PTR $T1[ebp], al
  00044	0f b7 45 f8	 movzx	 eax, WORD PTR _wItemSlotIndex$[ebp]
  00048	51		 push	 ecx
  00049	8b cc		 mov	 ecx, esp
  0004b	66 89 45 f5	 mov	 WORD PTR $T1[ebp+1], ax
  0004f	0f b7 45 f4	 movzx	 eax, WORD PTR $T1[ebp]
  00053	66 89 01	 mov	 WORD PTR [ecx], ax
  00056	8a 45 f6	 mov	 al, BYTE PTR $T1[ebp+2]
  00059	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00062	e8 00 00 00 00	 call	 ?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ; CPythonShop::DelPrivateShopItemStock

; 355  : 	return Py_BuildNone();

  00067	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 356  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ENDP ; shopDelPrivateShopItemStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 3
_wItemSlotIndex$ = -8					; size = 2
_bItemWindowType$ = -1					; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z PROC ; shopGetPrivateShopItemPrice, COMDAT

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 359  : 	BYTE bItemWindowType;
; 360  : 	if (!PyTuple_GetInteger(poArgs, 0, &bItemWindowType))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bItemWindowType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetPri
$LN7@shopGetPri:

; 368  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetPri:

; 361  : 		return Py_BuildException();
; 362  : 	WORD wItemSlotIndex;
; 363  : 	if (!PyTuple_GetInteger(poArgs, 1, &wItemSlotIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _wItemSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@shopGetPri

; 364  : 		return Py_BuildException();
; 365  : 
; 366  : 	int iValue = CPythonShop::Instance().GetPrivateShopItemPrice(TItemPos(bItemWindowType, wItemSlotIndex));

  0003e	8a 45 ff	 mov	 al, BYTE PTR _bItemWindowType$[ebp]
  00041	88 45 f4	 mov	 BYTE PTR $T1[ebp], al
  00044	0f b7 45 f8	 movzx	 eax, WORD PTR _wItemSlotIndex$[ebp]
  00048	51		 push	 ecx
  00049	8b cc		 mov	 ecx, esp
  0004b	66 89 45 f5	 mov	 WORD PTR $T1[ebp+1], ax
  0004f	0f b7 45 f4	 movzx	 eax, WORD PTR $T1[ebp]
  00053	66 89 01	 mov	 WORD PTR [ecx], ax
  00056	8a 45 f6	 mov	 al, BYTE PTR $T1[ebp+2]
  00059	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00062	e8 00 00 00 00	 call	 ?GetPrivateShopItemPrice@CPythonShop@@QAEHUSItemPos@@@Z ; CPythonShop::GetPrivateShopItemPrice

; 367  : 	return Py_BuildValue("i", iValue);

  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00073	83 c4 08	 add	 esp, 8

; 368  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z ENDP ; shopGetPrivateShopItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szName$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z PROC	; shopBuildPrivateShop, COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 371  : 	char * szName;
; 372  : 	if (!PyTuple_GetString(poArgs, 0, &szName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@shopBuildP

; 373  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 377  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@shopBuildP:

; 374  : 
; 375  : 	CPythonShop::Instance().BuildPrivateShop(szName);

  00027	ff 75 fc	 push	 DWORD PTR _szName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?BuildPrivateShop@CPythonShop@@QAEXPBD@Z ; CPythonShop::BuildPrivateShop

; 376  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 377  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z ENDP	; shopBuildPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetTabCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetTabCount@@YAPAU_object@@PAU1@0@Z PROC		; shopGetTabCount, COMDAT

; 381  : 	return Py_BuildValue("i", CPythonShop::instance().GetTabCount());

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00005	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00009	50		 push	 eax
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00015	83 c4 08	 add	 esp, 8

; 382  : }

  00018	c3		 ret	 0
?shopGetTabCount@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetTabCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetTabName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_bTabIdx$ = -1						; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetTabName@@YAPAU_object@@PAU1@0@Z PROC		; shopGetTabName, COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 386  : 	BYTE bTabIdx;
; 387  : 	if (!PyTuple_GetInteger(poArgs, 0, &bTabIdx))

  00004	8d 45 ff	 lea	 eax, DWORD PTR _bTabIdx$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@shopGetTab

; 388  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 391  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@shopGetTab:

; 389  : 
; 390  : 	return Py_BuildValue("s", CPythonShop::instance().GetTabName(bTabIdx));

  00027	8a 45 ff	 mov	 al, BYTE PTR _bTabIdx$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?GetTabName@CPythonShop@@QAEPBDE@Z ; CPythonShop::GetTabName
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00042	83 c4 08	 add	 esp, 8

; 391  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?shopGetTabName@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetTabName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_bTabIdx$ = -1						; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z PROC	; shopGetTabCoinType, COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 395  : 	BYTE bTabIdx;
; 396  : 	if (!PyTuple_GetInteger(poArgs, 0, &bTabIdx))

  00004	8d 45 ff	 lea	 eax, DWORD PTR _bTabIdx$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@shopGetTab

; 397  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 400  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@shopGetTab:

; 398  : 
; 399  : 	return Py_BuildValue("i", CPythonShop::instance().GetTabCoinType(bTabIdx));

  00027	8a 45 ff	 mov	 al, BYTE PTR _bTabIdx$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?GetTabCoinType@CPythonShop@@QAEEE@Z ; CPythonShop::GetTabCoinType
  00036	0f b6 c0	 movzx	 eax, al
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00045	83 c4 08	 add	 esp, 8

; 400  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z ENDP	; shopGetTabCoinType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?initshop@@YAXXZ
_TEXT	SEGMENT
?initshop@@YAXXZ PROC					; initshop, COMDAT

; 403  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 404  : 	static PyMethodDef s_methods[] =
; 405  : 	{
; 406  : 		// Shop
; 407  : 		{ "Open",						shopOpen,						METH_VARARGS },
; 408  : 		{ "Close",						shopClose,						METH_VARARGS },
; 409  : 		{ "IsOpen",						shopIsOpen,						METH_VARARGS },
; 410  : 		{ "IsPrivateShop",				shopIsPrviateShop,				METH_VARARGS },
; 411  : 		{ "IsMainPlayerPrivateShop",	shopIsMainPlayerPrivateShop,	METH_VARARGS },
; 412  : 		{ "GetItemID",					shopGetItemID,					METH_VARARGS },
; 413  : 		{ "GetItemCount",				shopGetItemCount,				METH_VARARGS },
; 414  : 		{ "GetItemPrice",				shopGetItemPrice,				METH_VARARGS },
; 415  : 		{ "GetItemMetinSocket",			shopGetItemMetinSocket,			METH_VARARGS },
; 416  : 		{ "GetItemAttribute",			shopGetItemAttribute,			METH_VARARGS },
; 417  : 		{ "GetTabCount",				shopGetTabCount,				METH_VARARGS },
; 418  : 		{ "GetTabName",					shopGetTabName,					METH_VARARGS },
; 419  : 		{ "GetTabCoinType",				shopGetTabCoinType,				METH_VARARGS },
; 420  : 
; 421  : 		// Private Shop
; 422  : 		{ "ClearPrivateShopStock",		shopClearPrivateShopStock,		METH_VARARGS },
; 423  : 		{ "AddPrivateShopItemStock",	shopAddPrivateShopItemStock,	METH_VARARGS },
; 424  : 		{ "DelPrivateShopItemStock",	shopDelPrivateShopItemStock,	METH_VARARGS },
; 425  : 		{ "GetPrivateShopItemPrice",	shopGetPrivateShopItemPrice,	METH_VARARGS },
; 426  : 		{ "BuildPrivateShop",			shopBuildPrivateShop,			METH_VARARGS },
; 427  : 		{ NULL,							NULL,							NULL },
; 428  : 	};
; 429  : 	PyObject * poModule = Py_InitModule("shop", s_methods);

  00002	68 f5 03 00 00	 push	 1013			; 000003f5H
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET ?s_methods@?1??initshop@@YAXXZ@4PAUPyMethodDef@@A
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_InitModule4

; 430  : 
; 431  : 	PyModule_AddIntConstant(poModule, "SHOP_SLOT_COUNT", SHOP_HOST_ITEM_MAX_NUM);

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyModule_AddIntConstant
  00021	8b f8		 mov	 edi, eax
  00023	6a 28		 push	 40			; 00000028H
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@
  0002a	57		 push	 edi
  0002b	ff d6		 call	 esi

; 432  : 	PyModule_AddIntConstant(poModule, "SHOP_COIN_TYPE_GOLD", SHOP_COIN_TYPE_GOLD);

  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@
  00034	57		 push	 edi
  00035	ff d6		 call	 esi

; 433  : 	PyModule_AddIntConstant(poModule, "SHOP_COIN_TYPE_SECONDARY_COIN", SHOP_COIN_TYPE_SECONDARY_COIN);

  00037	6a 01		 push	 1
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@
  0003e	57		 push	 edi
  0003f	ff d6		 call	 esi
  00041	83 c4 38	 add	 esp, 56			; 00000038H
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 434  : }

  00046	c3		 ret	 0
?initshop@@YAXXZ ENDP					; initshop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z PROC ; std::make_pair<SItemPos &,SShopItemTable &>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val1$ = edx

; 578  :              && is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00003	66 8b 02	 mov	 ax, WORD PTR [edx]
  00006	66 89 01	 mov	 WORD PTR [ecx], ax
  00009	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0000d	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  00010	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00013	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00017	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001a	66 0f d6 41 03	 movq	 QWORD PTR [ecx+3], xmm0
  0001f	89 41 0b	 mov	 DWORD PTR [ecx+11], eax
  00022	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00026	88 41 0f	 mov	 BYTE PTR [ecx+15], al

; 579  :     // return pair composed from arguments
; 580  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 581  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  00029	8b c1		 mov	 eax, ecx

; 582  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z ENDP ; std::make_pair<SItemPos &,SShopItemTable &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
;	COMDAT ??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Loc$3 = -36						; size = 12
$T4 = -24						; size = 12
$T5 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::insert<std::pair<SItemPos,SShopItemTable>,0>, COMDAT
; _this$ = ecx

; 185  :     pair<iterator, bool> insert(_Valty&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  0002a	8b 7d 0c	 mov	 edi, DWORD PTR __Val$[ebp]
  0002d	8d 45 e8	 lea	 eax, DWORD PTR $T4[ebp]
  00030	57		 push	 edi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0003e	66 0f d6 45 dc	 movq	 QWORD PTR __Loc$3[ebp], xmm0

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00043	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00047	75 17		 jne	 SHORT $LN6@insert
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00049	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  0004c	38 17		 cmp	 BYTE PTR [edi], dl
  0004e	72 10		 jb	 SHORT $LN6@insert
  00050	75 0a		 jne	 SHORT $LN112@insert
  00052	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  00056	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  0005a	72 04		 jb	 SHORT $LN6@insert
$LN112@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0005c	32 d2		 xor	 dl, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1019 :                 return {_Loc._Bound, false};

  0005e	eb 6b		 jmp	 SHORT $LN95@insert
$LN6@insert:

; 1648 :         if (max_size() == _Get_scary()->_Mysize) {

  00060	81 7b 04 ff ff
	ff 07		 cmp	 DWORD PTR [ebx+4], 134217727 ; 07ffffffH
  00067	74 7e		 je	 SHORT $LN116@insert

; 1023 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00069	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0006b	89 5d ec	 mov	 DWORD PTR $T5[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00075	6a 20		 push	 32			; 00000020H
  00077	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0
  0007e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00083	66 8b 0f	 mov	 cx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00086	8b d0		 mov	 edx, eax
  00088	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0008b	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  0008f	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  00092	88 4a 10	 mov	 BYTE PTR [edx+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00095	8b cb		 mov	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00097	f3 0f 7e 47 03	 movq	 xmm0, QWORD PTR [edi+3]
  0009c	66 0f d6 42 11	 movq	 QWORD PTR [edx+17], xmm0
  000a1	8b 47 0b	 mov	 eax, DWORD PTR [edi+11]
  000a4	89 42 19	 mov	 DWORD PTR [edx+25], eax
  000a7	8a 47 0f	 mov	 al, BYTE PTR [edi+15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000aa	52		 push	 edx
  000ab	ff 75 e0	 push	 DWORD PTR __Loc$3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000ae	88 42 1d	 mov	 BYTE PTR [edx+29], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000b1	ff 75 dc	 push	 DWORD PTR __Loc$3[ebp]

; 831  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000b4	89 32		 mov	 DWORD PTR [edx], esi

; 832  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000b6	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 833  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000b9	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 834  :         this->_Ptr->_Color = _Red;

  000bc	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000c2	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000c7	8b c8		 mov	 ecx, eax
  000c9	b2 01		 mov	 dl, 1
$LN95@insert:
  000cb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ce	89 08		 mov	 DWORD PTR [eax], ecx
  000d0	88 50 04	 mov	 BYTE PTR [eax+4], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map

; 187  :     }

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
$LN116@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1649 :             _Throw_tree_length_error();

  000e7	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN114@insert:
  000ec	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::insert<std::pair<SItemPos,SShopItemTable>,0>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,ItemStockSortFunc>, COMDAT

; 8399 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8400 :     _STD _Adl_verify_range(_First, _Last);
; 8401 :     const auto _UFirst = _STD _Get_unwrapped(_First);
; 8402 :     const auto _ULast  = _STD _Get_unwrapped(_Last);
; 8403 :     _STD _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _STD _Pass_fn(_Pred));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	2b c1		 sub	 eax, ecx
  0000d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00010	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
  0001c	83 c4 08	 add	 esp, 8

; 8404 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > const &>, COMDAT
; __It$ = ecx

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;
; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 345  :         return _STD _Unfancy_maybe_null(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 346  :     }

  00002	c3		 ret	 0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Pass_fn@UItemStockSortFunc@@@std@@YA?A_PAAUItemStockSortFunc@@@Z
_TEXT	SEGMENT
??$_Pass_fn@UItemStockSortFunc@@@std@@YA?A_PAAUItemStockSortFunc@@@Z PROC ; std::_Pass_fn<ItemStockSortFunc>, COMDAT
; __Func$ = ecx

; 772  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 773  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 774  :     if constexpr (_Pass_by_value) {
; 775  :         return _Func;

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 776  :     } else {
; 777  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 778  :     }
; 779  : }

  00002	c3		 ret	 0
??$_Pass_fn@UItemStockSortFunc@@@std@@YA?A_PAAUItemStockSortFunc@@@Z ENDP ; std::_Pass_fn<ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end, COMDAT
; _this$ = ecx

; 1850 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1851 :         auto& _My_data = _Mypair._Myval2;
; 1852 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1853 :     }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin, COMDAT
; _this$ = ecx

; 1840 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1841 :         auto& _My_data = _Mypair._Myval2;
; 1842 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1843 :     }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
__Size$1$ = 8						; size = 4
?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::reserve, COMDAT
; _this$ = ecx

; 1723 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1724 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1725 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Newcapacity$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000f	2b c1		 sub	 eax, ecx
  00011	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299

; 1724 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1725 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00017	3b d8		 cmp	 ebx, eax
  00019	76 56		 jbe	 SHORT $LN54@reserve

; 1726 :             if (_Newcapacity > max_size()) {

  0001b	81 fb 13 3b b1
	13		 cmp	 ebx, 330382099		; 13b13b13H
  00021	77 54		 ja	 SHORT $LN78@reserve

; 1649 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	2b c1		 sub	 eax, ecx
  00028	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  0002e	57		 push	 edi
  0002f	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 122  :     return _Count * _Ty_size;

  00032	6b c3 0d	 imul	 eax, ebx, 13

; 227  :     if (_Bytes == 0) {

  00035	85 c0		 test	 eax, eax
  00037	75 04		 jne	 SHORT $LN20@reserve

; 228  :         return nullptr;

  00039	33 ff		 xor	 edi, edi
  0003b	eb 19		 jmp	 SHORT $LN19@reserve
$LN20@reserve:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0003d	50		 push	 eax
  0003e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00043	72 07		 jb	 SHORT $LN22@reserve

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00045	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0004a	eb 05		 jmp	 SHORT $LN76@reserve
$LN22@reserve:

; 136  :         return ::operator new(_Bytes);

  0004c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN76@reserve:

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00051	8b f8		 mov	 edi, eax
  00053	83 c4 04	 add	 esp, 4
$LN19@reserve:
  00056	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00059	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005b	57		 push	 edi
  0005c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
  00061	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1668 :         _Change_array(_Newvec, _Size, _Newcapacity);

  00064	8b ce		 mov	 ecx, esi
  00066	53		 push	 ebx
  00067	ff 75 08	 push	 DWORD PTR __Size$1$[ebp]
  0006a	57		 push	 edi
  0006b	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
  00070	5f		 pop	 edi
$LN54@reserve:
  00071	5e		 pop	 esi

; 1728 :             }
; 1729 : 
; 1730 :             _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
; 1731 :         }
; 1732 :     }

  00072	5b		 pop	 ebx
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
$LN78@reserve:

; 1727 :                 _Xlength();

  00077	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
$LN75@reserve:
  0007c	cc		 int	 3
?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::push_back, COMDAT
; _this$ = ecx

; 932  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 844  :         if (_Mylast != _My_data._Myend) {

  00006	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00009	3b 72 08	 cmp	 esi, DWORD PTR [edx+8]
  0000c	74 20		 je	 SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00011	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00015	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001f	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00022	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

  00025	83 42 04 0d	 add	 DWORD PTR [edx+4], 13	; 0000000dH
  00029	5e		 pop	 esi

; 933  :         _Emplace_one_at_back(_Val);
; 934  :     }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN4@push_back:

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002e	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
  00037	5e		 pop	 esi

; 933  :         _Emplace_one_at_back(_Val);
; 934  :     }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 48		 je	 SHORT $LN5@vector

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00014	6b c8 0d	 imul	 ecx, eax, 13

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00017	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001d	72 14		 jb	 SHORT $LN19@vector
  0001f	57		 push	 edi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b d7		 sub	 edx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 23		 ja	 SHORT $LN18@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b d7		 mov	 edx, edi
  00032	5f		 pop	 edi
$LN19@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2097 :             _Myend   = nullptr;

  0004a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00051	5e		 pop	 esi

; 835  :     }

  00052	c3		 ret	 0
$LN18@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 __invoke_watson
$LN27@vector:
  00062	cc		 int	 3
??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::vector<SShopItemTable,std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 671  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 672  :     }

  00006	8b c1		 mov	 eax, ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 671  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 672  :     }

  00016	c3		 ret	 0
??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::vector<SShopItemTable,std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++, COMDAT
; _this$ = ecx

; 281  :     _Tree_iterator& operator++() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 198  :         _Mybase::operator++();

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 282  :         _Mybase::operator++();
; 283  :         return *this;

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 284  :     }

  0000b	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator->, COMDAT
; _this$ = ecx

; 185  :         return this->_Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0e	 add	 eax, 14			; 0000000eH

; 278  :         return pointer_traits<pointer>::pointer_to(**this);
; 279  :     }

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator==, COMDAT
; _this$ = ecx

; 227  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 228  : #if _ITERATOR_DEBUG_LEVEL == 2
; 229  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 230  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 231  : 
; 232  :         return this->_Ptr == _Right._Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 233  :     }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::find, COMDAT
; _this$ = ecx

; 1393 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8b 75 0c	 mov	 esi, DWORD PTR __Keyval$[ebp]
  0000a	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]

; 1393 :     _NODISCARD iterator find(const key_type& _Keyval) {

  0000d	57		 push	 edi

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000e	56		 push	 esi
  0000f	50		 push	 eax

; 1393 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00010	8b f9		 mov	 edi, ecx

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00012	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00017	8b 55 fc	 mov	 edx, DWORD PTR __Loc$1[ebp+8]
  0001a	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0001e	75 20		 jne	 SHORT $LN4@find
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00020	8a 06		 mov	 al, BYTE PTR [esi]
  00022	3a 42 0e	 cmp	 al, BYTE PTR [edx+14]
  00025	72 19		 jb	 SHORT $LN4@find
  00027	75 0a		 jne	 SHORT $LN27@find
  00029	66 8b 46 01	 mov	 ax, WORD PTR [esi+1]
  0002d	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00031	72 0d		 jb	 SHORT $LN4@find
$LN27@find:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00036	5f		 pop	 edi

; 1394 :         return iterator(_Find(_Keyval), _Get_scary());
; 1395 :     }

  00037	5e		 pop	 esi

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00038	89 10		 mov	 DWORD PTR [eax], edx

; 1394 :         return iterator(_Find(_Keyval), _Get_scary());
; 1395 :     }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN4@find:

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1389 :         return _Get_scary()->_Myhead;

  00043	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00045	5f		 pop	 edi

; 1394 :         return iterator(_Find(_Keyval), _Get_scary());
; 1395 :     }

  00046	5e		 pop	 esi

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00047	89 08		 mov	 DWORD PTR [eax], ecx

; 1394 :         return iterator(_Find(_Keyval), _Get_scary());
; 1395 :     }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::clear, COMDAT
; _this$ = ecx

; 1370 :     void clear() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1371 :         const auto _Scary = _Get_scary();
; 1372 :         _Scary->_Orphan_ptr(nullptr);
; 1373 :         auto _Head = _Scary->_Myhead;

  00004	8b 37		 mov	 esi, DWORD PTR [edi]

; 1374 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00006	ff 76 04	 push	 DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1375 :         _Head->_Parent  = _Head;

  0000f	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1376 :         _Head->_Left    = _Head;

  00012	89 36		 mov	 DWORD PTR [esi], esi

; 1377 :         _Head->_Right   = _Head;

  00014	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1378 :         _Scary->_Mysize = 0;

  00017	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1379 :     }

  00020	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
__Off$1$ = -8						; size = 4
__First$ = -4						; size = 4
__First$1$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase, COMDAT
; _this$ = ecx

; 1357 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	8b c1		 mov	 eax, ecx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 1709 :         _Nodeptr _Pnode   = _Scary->_Myhead->_Parent;

  0000e	8b 38		 mov	 edi, DWORD PTR [eax]

; 1710 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails
; 1711 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails

  00010	8b f7		 mov	 esi, edi

; 1357 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {

  00012	89 44 24 0c	 mov	 DWORD PTR _this$1$[esp+24], eax

; 1713 :         while (!_Pnode->_Isnil) {

  00016	8b c7		 mov	 eax, edi
  00018	89 7c 24 14	 mov	 DWORD PTR __First$1$[esp+24], edi
  0001c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0001f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00023	75 5a		 jne	 SHORT $LN5@erase
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00025	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00028	8a 38		 mov	 bh, BYTE PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1713 :         while (!_Pnode->_Isnil) {

  0002a	eb 07		 jmp	 SHORT $LN4@erase
  0002c	0f 1f 40 00	 npad	 4
$LL175@erase:
  00030	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
$LN4@erase:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00033	8a 5a 0e	 mov	 bl, BYTE PTR [edx+14]
  00036	3a df		 cmp	 bl, bh
  00038	72 38		 jb	 SHORT $LN162@erase
  0003a	75 14		 jne	 SHORT $LN172@erase
  0003c	8b 7d 08	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0003f	66 8b 42 0f	 mov	 ax, WORD PTR [edx+15]
  00043	66 3b 47 01	 cmp	 ax, WORD PTR [edi+1]
  00047	8b 7c 24 14	 mov	 edi, DWORD PTR __First$1$[esp+24]
  0004b	72 25		 jb	 SHORT $LN162@erase
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
$LN172@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1718 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

  00050	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00054	74 12		 je	 SHORT $LN10@erase
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00056	3a fb		 cmp	 bh, bl
  00058	72 0c		 jb	 SHORT $LN160@erase
  0005a	75 0c		 jne	 SHORT $LN10@erase
  0005c	66 8b 40 01	 mov	 ax, WORD PTR [eax+1]
  00060	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00064	73 02		 jae	 SHORT $LN10@erase
$LN160@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1719 :                     _Hinode = _Pnode; // _Pnode greater, remember it

  00066	8b f2		 mov	 esi, edx
$LN10@erase:

; 1720 :                 }
; 1721 : 
; 1722 :                 _Lonode = _Pnode;

  00068	8b fa		 mov	 edi, edx

; 1723 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  0006a	8b 12		 mov	 edx, DWORD PTR [edx]
  0006c	89 7c 24 14	 mov	 DWORD PTR __First$1$[esp+24], edi
  00070	eb 03		 jmp	 SHORT $LN9@erase
$LN162@erase:

; 1714 :             const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);
; 1715 :             if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {
; 1716 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00072	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
$LN9@erase:

; 1713 :         while (!_Pnode->_Isnil) {

  00075	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00079	74 b5		 je	 SHORT $LL175@erase
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0007b	8b d9		 mov	 ebx, ecx
  0007d	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN5@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1728 :         while (!_Pnode->_Isnil) {

  0007f	83 c0 04	 add	 eax, 4
  00082	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00086	0f 44 c6	 cmove	 eax, esi
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0008f	75 25		 jne	 SHORT $LN7@erase
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00091	8b 5d 08	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  00094	8a 13		 mov	 dl, BYTE PTR [ebx]
$LL6@erase:
  00096	3a 51 0e	 cmp	 dl, BYTE PTR [ecx+14]
  00099	72 11		 jb	 SHORT $LN35@erase
  0009b	75 0a		 jne	 SHORT $LN11@erase
  0009d	66 8b 43 01	 mov	 ax, WORD PTR [ebx+1]
  000a1	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  000a5	72 05		 jb	 SHORT $LN35@erase
$LN11@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1734 :                 _Pnode = _Pnode->_Right; // descend right subtree

  000a7	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000aa	eb 04		 jmp	 SHORT $LN12@erase
$LN35@erase:

; 1729 :             if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode->_Myval))) {
; 1730 :                 // _Pnode greater than _Keyval, remember it
; 1731 :                 _Hinode = _Pnode;

  000ac	8b f1		 mov	 esi, ecx

; 1732 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  000ae	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN12@erase:

; 1728 :         while (!_Pnode->_Isnil) {

  000b0	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000b4	74 e0		 je	 SHORT $LL6@erase
$LN7@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1665 :         auto _UFirst             = _STD _Get_unwrapped(_First);

  000b6	8b c7		 mov	 eax, edi

; 1666 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1667 :         _Iter_diff_t<_InIt> _Off = 0;

  000b8	33 c9		 xor	 ecx, ecx
  000ba	89 4c 24 10	 mov	 DWORD PTR __Off$1$[esp+24], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  000be	3b c6		 cmp	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {

  000c0	74 4f		 je	 SHORT $LN51@erase
  000c2	33 ff		 xor	 edi, edi
$LL52@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  000c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1669 :             ++_Off;

  000c7	47		 inc	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  000c8	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000cc	74 1d		 je	 SHORT $LN57@erase

; 51   :             _Nodeptr _Pnode;
; 52   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  000ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d1	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000d5	75 10		 jne	 SHORT $LN56@erase
$LL55@erase:
  000d7	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000da	75 0b		 jne	 SHORT $LN56@erase

; 53   :                 _Ptr = _Pnode; // ==> parent while right subtree

  000dc	8b c1		 mov	 eax, ecx
  000de	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000e1	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e5	74 f0		 je	 SHORT $LL55@erase
$LN56@erase:

; 54   :             }
; 55   : 
; 56   :             _Ptr = _Pnode; // ==> parent (head if end())

  000e7	8b c1		 mov	 eax, ecx

; 57   :         } else {

  000e9	eb 16		 jmp	 SHORT $LN151@erase
$LN57@erase:

; 58   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  000eb	8b c1		 mov	 eax, ecx

; 476  :         while (!_Pnode->_Left->_Isnil) {

  000ed	8b 10		 mov	 edx, DWORD PTR [eax]
  000ef	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  000f3	75 0c		 jne	 SHORT $LN151@erase
$LL62@erase:
  000f5	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 477  :             _Pnode = _Pnode->_Left;

  000f7	8b c2		 mov	 eax, edx
  000f9	8b d1		 mov	 edx, ecx
  000fb	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000ff	74 f4		 je	 SHORT $LL62@erase
$LN151@erase:

; 96   :         return _Ptr == _Right._Ptr;

  00101	3b c6		 cmp	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {

  00103	75 bf		 jne	 SHORT $LL52@erase
  00105	89 7c 24 10	 mov	 DWORD PTR __Off$1$[esp+24], edi
  00109	8b 7c 24 14	 mov	 edi, DWORD PTR __First$1$[esp+24]
  0010d	8b 4c 24 10	 mov	 ecx, DWORD PTR __Off$1$[esp+24]
$LN51@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1161 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00111	8b 44 24 0c	 mov	 eax, DWORD PTR _this$1$[esp+24]

; 1329 :         _Erase_unchecked(_First, _Last);

  00115	89 7c 24 14	 mov	 DWORD PTR __First$[esp+24], edi

; 1161 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00119	8b 18		 mov	 ebx, DWORD PTR [eax]

; 96   :         return _Ptr == _Right._Ptr;

  0011b	3b 3b		 cmp	 edi, DWORD PTR [ebx]

; 1311 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  0011d	75 31		 jne	 SHORT $LN146@erase
  0011f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00123	74 2b		 je	 SHORT $LN146@erase

; 1374 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00125	ff 73 04	 push	 DWORD PTR [ebx+4]
  00128	8b c8		 mov	 ecx, eax
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1358 :         return _Erase(_Eqrange(_Keyval));

  00130	8b 44 24 10	 mov	 eax, DWORD PTR __Off$1$[esp+24]

; 1375 :         _Head->_Parent  = _Head;

  00134	89 5b 04	 mov	 DWORD PTR [ebx+4], ebx

; 1376 :         _Head->_Left    = _Head;

  00137	89 1b		 mov	 DWORD PTR [ebx], ebx

; 1377 :         _Head->_Right   = _Head;

  00139	89 5b 08	 mov	 DWORD PTR [ebx+8], ebx

; 1378 :         _Scary->_Mysize = 0;

  0013c	8b 5c 24 0c	 mov	 ebx, DWORD PTR _this$1$[esp+24]
  00140	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1359 :     }

  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 04 00	 ret	 4
$LN146@erase:

; 96   :         return _Ptr == _Right._Ptr;

  00150	3b fe		 cmp	 edi, esi

; 1318 :         while (_First != _Last) {

  00152	74 33		 je	 SHORT $LN173@erase
  00154	8b d8		 mov	 ebx, eax
$LL70@erase:

; 66   :         ++*this;

  00156	8d 4c 24 14	 lea	 ecx, DWORD PTR __First$[esp+24]
  0015a	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1303 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  0015f	57		 push	 edi
  00160	8b cb		 mov	 ecx, ebx
  00162	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00167	6a 20		 push	 32			; 00000020H
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  0016f	8b 7c 24 1c	 mov	 edi, DWORD PTR __First$[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00173	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  00176	3b fe		 cmp	 edi, esi

; 1318 :         while (_First != _Last) {

  00178	75 dc		 jne	 SHORT $LL70@erase

; 1358 :         return _Erase(_Eqrange(_Keyval));

  0017a	8b 44 24 10	 mov	 eax, DWORD PTR __Off$1$[esp+24]

; 1359 :     }

  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 04 00	 ret	 4
$LN173@erase:
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	8b c1		 mov	 eax, ecx
  0018b	5b		 pop	 ebx
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 04 00	 ret	 4
?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::size, COMDAT
; _this$ = ecx

; 1209 :         return _Get_scary()->_Mysize;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1210 :     }

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::end, COMDAT
; _this$ = ecx

; 1150 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1151 :         const auto _Scary = _Get_scary();
; 1152 :         return iterator(_Scary->_Myhead, _Scary);
; 1153 :     }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::begin, COMDAT
; _this$ = ecx

; 1140 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1141 :         const auto _Scary = _Get_scary();
; 1142 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1143 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::~_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >, COMDAT
; _this$ = ecx

; 1095 :     ~_Tree() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 777  :         _Erase_tree(_Al, _Myhead->_Parent);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 20		 push	 32			; 00000020H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1102 :     }

  0001b	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::~_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
;	COMDAT ??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ PROC ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >, COMDAT
; _this$ = ecx

; 106  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 345  :         const auto _Pnode = _Al.allocate(1);

  00007	6a 20		 push	 32			; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map

; 106  :     map() : _Mybase(key_compare()) {}

  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00012	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 345  :         const auto _Pnode = _Al.allocate(1);

  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	83 c4 04	 add	 esp, 4

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00026	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 349  :         _Pnode->_Color = _Black;

  00029	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1957 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0002f	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map

; 106  :     map() : _Mybase(key_compare()) {}

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCPythonShop@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCPythonShop@@@@UAE@XZ PROC		; CSingleton<CPythonShop>::~CSingleton<CPythonShop>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, 0 ; CSingleton<CPythonShop>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCPythonShop@@@@UAE@XZ ENDP		; CSingleton<CPythonShop>::~CSingleton<CPythonShop>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ??0?$CSingleton@VCPythonShop@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCPythonShop@@@@QAE@XZ PROC		; CSingleton<CPythonShop>::CSingleton<CPythonShop>, COMDAT
; _this$ = ecx

; 12   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);
; 16   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, ecx ; CSingleton<CPythonShop>::ms_singleton
  0000e	c3		 ret	 0
??0?$CSingleton@VCPythonShop@@@@QAE@XZ ENDP		; CSingleton<CPythonShop>::CSingleton<CPythonShop>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z PROC		; CSingleton<CPythonShop>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1

; 19   : 	{ 

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, 0 ; CSingleton<CPythonShop>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@
  0001a	74 0b		 je	 SHORT $LN8@scalar
  0001c	6a 04		 push	 4
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z ENDP		; CSingleton<CPythonShop>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Lonode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Eqrange<SItemPos>, COMDAT
; _this$ = ecx

; 1705 :         noexcept(_Nothrow_compare<key_compare, key_type, _Other> && _Nothrow_compare<key_compare, _Other, key_type>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1706 :         // find range of nodes equivalent to _Keyval
; 1707 :         const auto _Scary = _Get_scary();
; 1708 :         const auto& _Comp = _Getcomp();
; 1709 :         _Nodeptr _Pnode   = _Scary->_Myhead->_Parent;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1710 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails
; 1711 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails
; 1712 : 
; 1713 :         while (!_Pnode->_Isnil) {

  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000d	8b f0		 mov	 esi, eax
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	89 45 fc	 mov	 DWORD PTR __Lonode$1$[ebp], eax
  00015	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00019	75 41		 jne	 SHORT $LN3@Eqrange
  0001b	53		 push	 ebx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0001c	8a 3f		 mov	 bh, BYTE PTR [edi]
  0001e	66 90		 npad	 2
$LL2@Eqrange:
  00020	8a 5a 0e	 mov	 bl, BYTE PTR [edx+14]
  00023	3a df		 cmp	 bl, bh
  00025	72 2b		 jb	 SHORT $LN52@Eqrange
  00027	75 0a		 jne	 SHORT $LN51@Eqrange
  00029	66 8b 42 0f	 mov	 ax, WORD PTR [edx+15]
  0002d	66 3b 47 01	 cmp	 ax, WORD PTR [edi+1]
  00031	72 1f		 jb	 SHORT $LN52@Eqrange
$LN51@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1718 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

  00033	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00037	74 12		 je	 SHORT $LN8@Eqrange
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00039	3a fb		 cmp	 bh, bl
  0003b	72 0c		 jb	 SHORT $LN43@Eqrange
  0003d	75 0c		 jne	 SHORT $LN8@Eqrange
  0003f	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  00043	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00047	73 02		 jae	 SHORT $LN8@Eqrange
$LN43@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1719 :                     _Hinode = _Pnode; // _Pnode greater, remember it

  00049	8b f2		 mov	 esi, edx
$LN8@Eqrange:

; 1720 :                 }
; 1721 : 
; 1722 :                 _Lonode = _Pnode;

  0004b	89 55 fc	 mov	 DWORD PTR __Lonode$1$[ebp], edx

; 1723 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  0004e	8b 12		 mov	 edx, DWORD PTR [edx]
  00050	eb 03		 jmp	 SHORT $LN7@Eqrange
$LN52@Eqrange:

; 1714 :             const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);
; 1715 :             if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {
; 1716 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00052	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
$LN7@Eqrange:

; 1710 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails
; 1711 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails
; 1712 : 
; 1713 :         while (!_Pnode->_Isnil) {

  00055	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00059	74 c5		 je	 SHORT $LL2@Eqrange
  0005b	5b		 pop	 ebx
$LN3@Eqrange:

; 1724 :             }
; 1725 :         }
; 1726 : 
; 1727 :         _Pnode = _Hinode->_Isnil ? _Scary->_Myhead->_Parent : _Hinode->_Left; // continue scan for upper bound

  0005c	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00060	74 07		 je	 SHORT $LN12@Eqrange
  00062	8b 01		 mov	 eax, DWORD PTR [ecx]
  00064	83 c0 04	 add	 eax, 4
  00067	eb 02		 jmp	 SHORT $LN13@Eqrange
$LN12@Eqrange:
  00069	8b c6		 mov	 eax, esi
$LN13@Eqrange:

; 1728 :         while (!_Pnode->_Isnil) {

  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00071	75 22		 jne	 SHORT $LN5@Eqrange
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00073	8a 17		 mov	 dl, BYTE PTR [edi]
$LL4@Eqrange:
  00075	3a 50 0e	 cmp	 dl, BYTE PTR [eax+14]
  00078	72 11		 jb	 SHORT $LN33@Eqrange
  0007a	75 0a		 jne	 SHORT $LN9@Eqrange
  0007c	66 8b 4f 01	 mov	 cx, WORD PTR [edi+1]
  00080	66 3b 48 0f	 cmp	 cx, WORD PTR [eax+15]
  00084	72 05		 jb	 SHORT $LN33@Eqrange
$LN9@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1734 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00086	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00089	eb 04		 jmp	 SHORT $LN10@Eqrange
$LN33@Eqrange:

; 1729 :             if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode->_Myval))) {
; 1730 :                 // _Pnode greater than _Keyval, remember it
; 1731 :                 _Hinode = _Pnode;

  0008b	8b f0		 mov	 esi, eax

; 1732 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  0008d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@Eqrange:

; 1728 :         while (!_Pnode->_Isnil) {

  0008f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00093	74 e0		 je	 SHORT $LL4@Eqrange
$LN5@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d fc	 mov	 ecx, DWORD PTR __Lonode$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1738 :         return {_Lonode, _Hinode};

  0009b	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0009c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0009f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1738 :         return {_Lonode, _Hinode};

  000a1	5e		 pop	 esi

; 1739 :     }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Eqrange<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z
_TEXT	SEGMENT
??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z PROC ; std::forward<SItemPos &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z ENDP ; std::forward<SItemPos &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z PROC ; std::forward<SShopItemTable &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z ENDP ; std::forward<SShopItemTable &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z PROC ; std::pair<SItemPos,SShopItemTable>::pair<SItemPos,SShopItemTable><SItemPos &,SShopItemTable &,0>, COMDAT
; _this$ = ecx

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00006	66 8b 02	 mov	 ax, WORD PTR [edx]
  00009	66 89 01	 mov	 WORD PTR [ecx], ax
  0000c	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00010	8b 55 0c	 mov	 edx, DWORD PTR __Val2$[ebp]
  00013	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00016	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0001a	66 0f d6 41 03	 movq	 QWORD PTR [ecx+3], xmm0
  0001f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00022	89 41 0b	 mov	 DWORD PTR [ecx+11], eax
  00025	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00029	88 41 0f	 mov	 BYTE PTR [ecx+15], al

; 275  :     }

  0002c	8b c1		 mov	 eax, ecx
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z ENDP ; std::pair<SItemPos,SShopItemTable>::pair<SItemPos,SShopItemTable><SItemPos &,SShopItemTable &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z PROC ; std::forward<std::pair<SItemPos,SShopItemTable> >, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z ENDP ; std::forward<std::pair<SItemPos,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Loc$2 = -36						; size = 12
$T3 = -24						; size = 12
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::emplace<std::pair<SItemPos,SShopItemTable> >, COMDAT
; _this$ = ecx

; 1047 :     pair<iterator, bool> emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx

; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  0002a	8b 7d 0c	 mov	 edi, DWORD PTR _<_Vals_0>$[ebp]
  0002d	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00030	57		 push	 edi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0003e	66 0f d6 45 dc	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00043	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00047	75 17		 jne	 SHORT $LN4@emplace
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00049	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  0004c	38 17		 cmp	 BYTE PTR [edi], dl
  0004e	72 10		 jb	 SHORT $LN4@emplace
  00050	75 0a		 jne	 SHORT $LN109@emplace
  00052	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  00056	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  0005a	72 04		 jb	 SHORT $LN4@emplace
$LN109@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0005c	32 d2		 xor	 dl, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1019 :                 return {_Loc._Bound, false};

  0005e	eb 6b		 jmp	 SHORT $LN93@emplace
$LN4@emplace:

; 1648 :         if (max_size() == _Get_scary()->_Mysize) {

  00060	81 7b 04 ff ff
	ff 07		 cmp	 DWORD PTR [ebx+4], 134217727 ; 07ffffffH
  00067	74 7e		 je	 SHORT $LN113@emplace

; 1023 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00069	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0006b	89 5d ec	 mov	 DWORD PTR $T4[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00075	6a 20		 push	 32			; 00000020H
  00077	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0
  0007e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00083	66 8b 0f	 mov	 cx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00086	8b d0		 mov	 edx, eax
  00088	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0008b	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  0008f	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  00092	88 4a 10	 mov	 BYTE PTR [edx+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00095	8b cb		 mov	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00097	f3 0f 7e 47 03	 movq	 xmm0, QWORD PTR [edi+3]
  0009c	66 0f d6 42 11	 movq	 QWORD PTR [edx+17], xmm0
  000a1	8b 47 0b	 mov	 eax, DWORD PTR [edi+11]
  000a4	89 42 19	 mov	 DWORD PTR [edx+25], eax
  000a7	8a 47 0f	 mov	 al, BYTE PTR [edi+15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000aa	52		 push	 edx
  000ab	ff 75 e0	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000ae	88 42 1d	 mov	 BYTE PTR [edx+29], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000b1	ff 75 dc	 push	 DWORD PTR __Loc$2[ebp]

; 831  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000b4	89 32		 mov	 DWORD PTR [edx], esi

; 832  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000b6	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 833  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000b9	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 834  :         this->_Ptr->_Color = _Red;

  000bc	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000c2	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000c7	8b c8		 mov	 ecx, eax
  000c9	b2 01		 mov	 dl, 1
$LN93@emplace:
  000cb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ce	89 08		 mov	 DWORD PTR [eax], ecx
  000d0	88 50 04	 mov	 BYTE PTR [eax+4], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1050 :     }

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
$LN113@emplace:

; 1649 :             _Throw_tree_length_error();

  000e7	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN111@emplace:
  000ec	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::emplace<std::pair<SItemPos,SShopItemTable> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

  00000	c2 00 00	 ret	 0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1$ = -45						; size = 1
__Val$1$ = -45						; size = 1
__Hole$1$ = -44						; size = 4
__Last$1$ = -40						; size = 4
__Max_sequence_non_leaf$1$ = -36			; size = 4
__Bottom$1$ = -32					; size = 4
__Val$3$ = -32						; size = 4
tv742 = -28						; size = 4
__Val$3$ = -24						; size = 4
tv731 = -20						; size = 4
__Mid$1 = -16						; size = 8
__Val$2 = -16						; size = 13
tv721 = -16						; size = 4
__Val$2$ = -16						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z PROC ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 8369 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx
  0000a	8b da		 mov	 ebx, edx
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	89 5c 24 14	 mov	 DWORD PTR __Last$1$[esp+60], ebx

; 8370 :     // order [_First, _Last)
; 8371 :     for (;;) {
; 8372 :         if (_Last - _First <= _ISORT_MAX) { // small

  00013	8b c3		 mov	 eax, ebx
  00015	2b c6		 sub	 eax, esi
  00017	57		 push	 edi
  00018	3d ad 01 00 00	 cmp	 eax, 429		; 000001adH
  0001d	7c 7b		 jl	 SHORT $LN69@Sort_unche
  0001f	8b 55 0c	 mov	 edx, DWORD PTR __Pred$[ebp]
  00022	8b 7d 08	 mov	 edi, DWORD PTR __Ideal$[ebp]
$LL4@Sort_unche:

; 8373 :             _STD _Insertion_sort_unchecked(_First, _Last, _Pred);
; 8374 :             return;
; 8375 :         }
; 8376 : 
; 8377 :         if (_Ideal <= 0) { // heap sort if too many divisions

  00025	85 ff		 test	 edi, edi
  00027	0f 8e d1 00 00
	00		 jle	 $LN70@Sort_unche

; 8380 :             return;
; 8381 :         }
; 8382 : 
; 8383 :         // divide and conquer by quicksort
; 8384 :         auto _Mid = _STD _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0002d	52		 push	 edx
  0002e	53		 push	 ebx
  0002f	8b d6		 mov	 edx, esi
  00031	8d 4c 24 38	 lea	 ecx, DWORD PTR __Mid$1[esp+72]
  00035	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8385 : 
; 8386 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 8387 : 
; 8388 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0003a	8b 54 24 38	 mov	 edx, DWORD PTR __Mid$1[esp+72]
  0003e	8b c7		 mov	 eax, edi
  00040	c1 f8 02	 sar	 eax, 2
  00043	83 c4 08	 add	 esp, 8
  00046	d1 ff		 sar	 edi, 1
  00048	03 f8		 add	 edi, eax
  0004a	8b c3		 mov	 eax, ebx
  0004c	2b 44 24 34	 sub	 eax, DWORD PTR __Mid$1[esp+68]
  00050	69 c8 c5 4e ec
	c4		 imul	 ecx, eax, -991146299
  00056	8b c2		 mov	 eax, edx
  00058	2b c6		 sub	 eax, esi
  0005a	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00060	3b c1		 cmp	 eax, ecx
  00062	8b 45 0c	 mov	 eax, DWORD PTR __Pred$[ebp]
  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	7d 0d		 jge	 SHORT $LN7@Sort_unche

; 8389 :             _STD _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8390 :             _First = _Mid.second;

  00070	8b 74 24 3c	 mov	 esi, DWORD PTR __Mid$1[esp+76]

; 8391 :         } else { // loop on first half

  00074	eb 13		 jmp	 SHORT $LN99@Sort_unche
$LN7@Sort_unche:

; 8392 :             _STD _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  00076	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Mid$1[esp+76]
  0007a	8b d3		 mov	 edx, ebx
  0007c	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8393 :             _Last = _Mid.first;

  00081	8b 5c 24 38	 mov	 ebx, DWORD PTR __Mid$1[esp+72]
  00085	89 5c 24 20	 mov	 DWORD PTR __Last$1$[esp+72], ebx
$LN99@Sort_unche:

; 8370 :     // order [_First, _Last)
; 8371 :     for (;;) {
; 8372 :         if (_Last - _First <= _ISORT_MAX) { // small

  00089	8b 55 0c	 mov	 edx, DWORD PTR __Pred$[ebp]
  0008c	8b c3		 mov	 eax, ebx
  0008e	2b c6		 sub	 eax, esi
  00090	83 c4 08	 add	 esp, 8
  00093	3d ad 01 00 00	 cmp	 eax, 429		; 000001adH
  00098	7d 8b		 jge	 SHORT $LL4@Sort_unche
$LN69@Sort_unche:

; 8243 :     if (_First != _Last) {

  0009a	3b f3		 cmp	 esi, ebx
  0009c	0f 84 80 02 00
	00		 je	 $LN12@Sort_unche

; 8244 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  000a2	8d 7e 0d	 lea	 edi, DWORD PTR [esi+13]
  000a5	3b fb		 cmp	 edi, ebx
  000a7	0f 84 75 02 00
	00		 je	 $LN12@Sort_unche
  000ad	0f 1f 00	 npad	 3
$LL13@Sort_unche:

; 8245 :             _BidIt _Hole = _Mid;
; 8246 :             _Iter_value_t<_BidIt> _Val(_STD move(*_Mid));

  000b0	8a 4f 0c	 mov	 cl, BYTE PTR [edi+12]
  000b3	8b d7		 mov	 edx, edi
  000b5	f3 0f 7e 0f	 movq	 xmm1, QWORD PTR [edi]
  000b9	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000bc	66 0f d6 4c 24
	30		 movq	 QWORD PTR __Val$2$[esp+64], xmm1
  000c2	89 44 24 20	 mov	 DWORD PTR __Val$3$[esp+64], eax
  000c6	88 4c 24 13	 mov	 BYTE PTR __Val$1$[esp+64], cl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000ca	3a 4e 0c	 cmp	 cl, BYTE PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8248 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  000cd	0f 83 fb 01 00
	00		 jae	 $LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 5190 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

  000d3	8d 47 0d	 lea	 eax, DWORD PTR [edi+13]
  000d6	8b ce		 mov	 ecx, esi
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8250 :                 *_First = _STD move(_Val);

  000de	f3 0f 7e 44 24
	34		 movq	 xmm0, QWORD PTR __Val$2$[esp+68]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 5190 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

  000e4	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8250 :                 *_First = _STD move(_Val);

  000e7	8b 44 24 20	 mov	 eax, DWORD PTR __Val$3$[esp+64]
  000eb	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  000ef	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000f2	8a 44 24 13	 mov	 al, BYTE PTR __Val$1$[esp+64]
  000f6	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 8251 :             } else { // look for insertion point after first

  000f9	e9 19 02 00 00	 jmp	 $LN11@Sort_unche
$LN70@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 124  :     _Diff _Bottom = _Last - _First;

  000fe	8b c3		 mov	 eax, ebx
  00100	2b c6		 sub	 eax, esi
  00102	69 f8 c5 4e ec
	c4		 imul	 edi, eax, -991146299
  00108	89 44 24 30	 mov	 DWORD PTR tv721[esp+64], eax

; 125  :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  0010c	8b cf		 mov	 ecx, edi
  0010e	89 7c 24 20	 mov	 DWORD PTR __Bottom$1$[esp+64], edi
  00112	d1 f9		 sar	 ecx, 1
  00114	85 c9		 test	 ecx, ecx
  00116	0f 8e 32 01 00
	00		 jle	 $LN32@Sort_unche
  0011c	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0011f	8b d0		 mov	 edx, eax
  00121	89 44 24 24	 mov	 DWORD PTR tv742[esp+64], eax

; 124  :     _Diff _Bottom = _Last - _First;

  00125	6b c1 0d	 imul	 eax, ecx, 13
  00128	d1 fa		 sar	 edx, 1
  0012a	89 54 24 1c	 mov	 DWORD PTR __Max_sequence_non_leaf$1$[esp+64], edx
  0012e	03 c6		 add	 eax, esi
$LL33@Sort_unche:

; 126  :         // reheap top half, bottom to top
; 127  :         --_Hole;
; 128  :         _Iter_value_t<_RanIt> _Val(_STD move(*(_First + _Hole)));

  00130	8b 58 fb	 mov	 ebx, DWORD PTR [eax-5]
  00133	83 e8 0d	 sub	 eax, 13			; 0000000dH
  00136	49		 dec	 ecx
  00137	89 44 24 2c	 mov	 DWORD PTR tv731[esp+64], eax
  0013b	89 5c 24 28	 mov	 DWORD PTR __Val$3$[esp+64], ebx

; 129  :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  0013f	8b d9		 mov	 ebx, ecx
  00141	89 4c 24 14	 mov	 DWORD PTR __Hole$1$[esp+64], ecx

; 64   :     _Diff _Idx       = _Hole;

  00145	8b f9		 mov	 edi, ecx

; 128  :         _Iter_value_t<_RanIt> _Val(_STD move(*(_First + _Hole)));

  00147	f3 0f 7e 08	 movq	 xmm1, QWORD PTR [eax]
  0014b	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  0014e	88 44 24 13	 mov	 BYTE PTR __Val$1$[esp+64], al

; 69   :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  00152	3b ca		 cmp	 ecx, edx
  00154	7d 4f		 jge	 SHORT $LN37@Sort_unche
  00156	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL36@Sort_unche:

; 70   :         _Idx = 2 * _Idx + 2;

  00160	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]

; 71   :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00163	6b ca 0d	 imul	 ecx, edx, 13

; 72   :             --_Idx;
; 73   :         }
; 74   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00166	0f b6 44 31 26	 movzx	 eax, BYTE PTR [ecx+esi+38]
  0016b	3a 44 31 19	 cmp	 al, BYTE PTR [ecx+esi+25]
  0016f	1b c0		 sbb	 eax, eax
  00171	6b cb 0d	 imul	 ecx, ebx, 13
  00174	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  00177	03 fa		 add	 edi, edx
  00179	6b d7 0d	 imul	 edx, edi, 13

; 75   :         _Hole             = _Idx;

  0017c	8b df		 mov	 ebx, edi
  0017e	f3 0f 7e 04 32	 movq	 xmm0, QWORD PTR [edx+esi]
  00183	66 0f d6 04 31	 movq	 QWORD PTR [ecx+esi], xmm0
  00188	8b 44 32 08	 mov	 eax, DWORD PTR [edx+esi+8]
  0018c	89 44 31 08	 mov	 DWORD PTR [ecx+esi+8], eax
  00190	0f b6 44 32 0c	 movzx	 eax, BYTE PTR [edx+esi+12]
  00195	8b 54 24 1c	 mov	 edx, DWORD PTR __Max_sequence_non_leaf$1$[esp+64]
  00199	88 44 31 0c	 mov	 BYTE PTR [ecx+esi+12], al
  0019d	3b fa		 cmp	 edi, edx
  0019f	7c bf		 jl	 SHORT $LL36@Sort_unche
  001a1	8b 4c 24 14	 mov	 ecx, DWORD PTR __Hole$1$[esp+64]
$LN37@Sort_unche:

; 76   :     }
; 77   : 
; 78   :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  001a5	3b da		 cmp	 ebx, edx
  001a7	75 31		 jne	 SHORT $LN39@Sort_unche
  001a9	8b 44 24 20	 mov	 eax, DWORD PTR __Bottom$1$[esp+64]
  001ad	a8 01		 test	 al, 1
  001af	75 29		 jne	 SHORT $LN39@Sort_unche

; 79   :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  001b1	6b c8 0d	 imul	 ecx, eax, 13
  001b4	6b d3 0d	 imul	 edx, ebx, 13

; 80   :         _Hole             = _Bottom - 1;

  001b7	8b 5c 24 24	 mov	 ebx, DWORD PTR tv742[esp+64]
  001bb	f3 0f 7e 44 31
	f3		 movq	 xmm0, QWORD PTR [ecx+esi-13]
  001c1	66 0f d6 04 32	 movq	 QWORD PTR [edx+esi], xmm0
  001c6	8b 44 31 fb	 mov	 eax, DWORD PTR [ecx+esi-5]
  001ca	89 44 32 08	 mov	 DWORD PTR [edx+esi+8], eax
  001ce	8a 44 31 ff	 mov	 al, BYTE PTR [ecx+esi-1]
  001d2	8b 4c 24 14	 mov	 ecx, DWORD PTR __Hole$1$[esp+64]

; 79   :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  001d6	88 44 32 0c	 mov	 BYTE PTR [edx+esi+12], al
$LN39@Sort_unche:

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  001da	3b cb		 cmp	 ecx, ebx
  001dc	7d 39		 jge	 SHORT $LN45@Sort_unche
  001de	66 90		 npad	 2
$LL46@Sort_unche:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  001e0	8a 44 24 13	 mov	 al, BYTE PTR __Val$1$[esp+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 26   :     for (_Diff _Idx                                                         = (_Hole - 1) >> 1; // shift for codegen

  001e4	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  001e7	d1 fa		 sar	 edx, 1

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  001e9	6b fa 0d	 imul	 edi, edx, 13
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  001ec	03 fe		 add	 edi, esi
  001ee	38 47 0c	 cmp	 BYTE PTR [edi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  001f1	73 24		 jae	 SHORT $LN45@Sort_unche

; 28   :         // move _Hole up to parent
; 29   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  001f3	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  001f7	6b cb 0d	 imul	 ecx, ebx, 13

; 30   :         _Hole             = _Idx;

  001fa	8b da		 mov	 ebx, edx
  001fc	66 0f d6 04 31	 movq	 QWORD PTR [ecx+esi], xmm0
  00201	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00204	89 44 31 08	 mov	 DWORD PTR [ecx+esi+8], eax
  00208	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  0020b	88 44 31 0c	 mov	 BYTE PTR [ecx+esi+12], al
  0020f	8b 4c 24 14	 mov	 ecx, DWORD PTR __Hole$1$[esp+64]
  00213	3b ca		 cmp	 ecx, edx
  00215	7c c9		 jl	 SHORT $LL46@Sort_unche
$LN45@Sort_unche:

; 31   :     }
; 32   : 
; 33   :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00217	8b 54 24 28	 mov	 edx, DWORD PTR __Val$3$[esp+64]
  0021b	6b c3 0d	 imul	 eax, ebx, 13
  0021e	66 0f d6 0c 30	 movq	 QWORD PTR [eax+esi], xmm1
  00223	89 54 30 08	 mov	 DWORD PTR [eax+esi+8], edx
  00227	8a 54 24 13	 mov	 dl, BYTE PTR __Val$1$[esp+64]
  0022b	88 54 30 0c	 mov	 BYTE PTR [eax+esi+12], dl

; 125  :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  0022f	8b 44 24 2c	 mov	 eax, DWORD PTR tv731[esp+64]
  00233	8b 54 24 1c	 mov	 edx, DWORD PTR __Max_sequence_non_leaf$1$[esp+64]
  00237	85 c9		 test	 ecx, ecx
  00239	0f 8f f1 fe ff
	ff		 jg	 $LL33@Sort_unche
  0023f	8b 5c 24 18	 mov	 ebx, DWORD PTR __Last$1$[esp+64]
  00243	8b 44 24 30	 mov	 eax, DWORD PTR tv721[esp+64]
  00247	8b 55 0c	 mov	 edx, DWORD PTR __Pred$[ebp]
  0024a	8b 7c 24 20	 mov	 edi, DWORD PTR __Bottom$1$[esp+64]
$LN32@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 7148 :     for (; _Last - _First >= 2; --_Last) {

  0024e	83 ff 02	 cmp	 edi, 2
  00251	0f 8c cb 00 00
	00		 jl	 $LN12@Sort_unche

; 8378 :             _STD _Make_heap_unchecked(_First, _Last, _Pred);
; 8379 :             _STD _Sort_heap_unchecked(_First, _Last, _Pred);

  00257	8d 7b f3	 lea	 edi, DWORD PTR [ebx-13]
  0025a	66 0f 1f 44 00
	00		 npad	 6
$LL53@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 100  :     if (2 <= _Last - _First) {

  00260	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00266	8b df		 mov	 ebx, edi
  00268	83 f8 02	 cmp	 eax, 2
  0026b	7c 4b		 jl	 SHORT $LN51@Sort_unche

; 101  :         --_Last;
; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  0026d	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]

; 93   :     _STD _Pop_heap_hole_by_index(

  00271	8b ce		 mov	 ecx, esi

; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00273	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00276	89 44 24 38	 mov	 DWORD PTR __Val$2[esp+72], eax
  0027a	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  0027e	88 44 24 3c	 mov	 BYTE PTR __Val$2[esp+76], al
  00282	66 0f d6 44 24
	30		 movq	 QWORD PTR __Val$2[esp+64], xmm0

; 91   :     *_Dest      = _STD move(*_First);

  00288	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  0028c	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  00290	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00293	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00296	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  0029a	88 47 0c	 mov	 BYTE PTR [edi+12], al

; 92   :     using _Diff = _Iter_diff_t<_RanIt>;
; 93   :     _STD _Pop_heap_hole_by_index(

  0029d	8d 44 24 30	 lea	 eax, DWORD PTR __Val$2[esp+64]
  002a1	52		 push	 edx
  002a2	50		 push	 eax
  002a3	8b c7		 mov	 eax, edi
  002a5	33 d2		 xor	 edx, edx
  002a7	2b c6		 sub	 eax, esi
  002a9	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
  002b5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN51@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 7148 :     for (; _Last - _First >= 2; --_Last) {

  002b8	8b 55 0c	 mov	 edx, DWORD PTR __Pred$[ebp]
  002bb	8b c3		 mov	 eax, ebx
  002bd	2b c6		 sub	 eax, esi
  002bf	83 ef 0d	 sub	 edi, 13			; 0000000dH
  002c2	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  002c5	7d 99		 jge	 SHORT $LL53@Sort_unche

; 8394 :         }
; 8395 :     }
; 8396 : }

  002c7	5f		 pop	 edi
  002c8	5e		 pop	 esi
  002c9	5b		 pop	 ebx
  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c3		 ret	 0
$LN18@Sort_unche:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  002ce	0f b6 d9	 movzx	 ebx, cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8252 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  002d1	8d 47 f3	 lea	 eax, DWORD PTR [edi-13]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  002d4	0f b6 4f ff	 movzx	 ecx, BYTE PTR [edi-1]
  002d8	3b d9		 cmp	 ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8252 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  002da	73 25		 jae	 SHORT $LN15@Sort_unche
  002dc	0f 1f 40 00	 npad	 4
$LL16@Sort_unche:

; 8253 :                     *_Hole = _STD move(*_Prev); // move hole down

  002e0	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  002e4	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  002e8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002eb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  002ee	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  002f1	88 4a 0c	 mov	 BYTE PTR [edx+12], cl
  002f4	8b d0		 mov	 edx, eax
  002f6	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  002fa	83 e8 0d	 sub	 eax, 13			; 0000000dH
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  002fd	3b d9		 cmp	 ebx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8252 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  002ff	72 df		 jb	 SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 8254 :                 }
; 8255 : 
; 8256 :                 *_Hole = _STD move(_Val); // insert element in hole

  00301	8b 44 24 20	 mov	 eax, DWORD PTR __Val$3$[esp+64]
  00305	8b 5c 24 18	 mov	 ebx, DWORD PTR __Last$1$[esp+64]
  00309	66 0f d6 0a	 movq	 QWORD PTR [edx], xmm1
  0030d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00310	8a 44 24 13	 mov	 al, BYTE PTR __Val$1$[esp+64]
  00314	88 42 0c	 mov	 BYTE PTR [edx+12], al
$LN11@Sort_unche:

; 8244 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00317	83 c7 0d	 add	 edi, 13			; 0000000dH
  0031a	3b fb		 cmp	 edi, ebx
  0031c	0f 85 8e fd ff
	ff		 jne	 $LL13@Sort_unche
$LN12@Sort_unche:

; 8394 :         }
; 8395 :     }
; 8396 : }

  00322	5f		 pop	 edi
  00323	5e		 pop	 esi
  00324	5b		 pop	 ebx
  00325	8b e5		 mov	 esp, ebp
  00327	5d		 pop	 ebp
  00328	c3		 ret	 0
??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ENDP ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<SShopItemTable> > >, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Reallocate@$0A@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXAAI@Z
_TEXT	SEGMENT
__Size$1$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
??$_Reallocate@$0A@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXAAI@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate<0>, COMDAT
; _this$ = ecx

; 1642 :     _CONSTEXPR20 void _Reallocate(size_type& _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 2303 :         return _Al.allocate(_Count);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1642 :     _CONSTEXPR20 void _Reallocate(size_type& _Newcapacity) {

  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 1643 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1644 :         auto& _Al         = _Getal();
; 1645 :         auto& _My_data    = _Mypair._Myval2;
; 1646 :         pointer& _Myfirst = _My_data._Myfirst;
; 1647 :         pointer& _Mylast  = _My_data._Mylast;
; 1648 : 
; 1649 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  0000b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000e	2b 07		 sub	 eax, DWORD PTR [edi]
  00010	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00016	89 45 fc	 mov	 DWORD PTR __Size$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 2303 :         return _Al.allocate(_Count);

  00019	8b 03		 mov	 eax, DWORD PTR [ebx]

; 117  :         if (_Count > _Max_possible) {

  0001b	3d 13 3b b1 13	 cmp	 eax, 330382099		; 13b13b13H
  00020	77 49		 ja	 SHORT $LN69@Reallocate

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00022	6b c0 0d	 imul	 eax, eax, 13
  00025	56		 push	 esi

; 227  :     if (_Bytes == 0) {

  00026	85 c0		 test	 eax, eax
  00028	75 04		 jne	 SHORT $LN13@Reallocate

; 228  :         return nullptr;

  0002a	33 f6		 xor	 esi, esi
  0002c	eb 19		 jmp	 SHORT $LN12@Reallocate
$LN13@Reallocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0002e	50		 push	 eax
  0002f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00034	72 07		 jb	 SHORT $LN15@Reallocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00036	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003b	eb 05		 jmp	 SHORT $LN67@Reallocate
$LN15@Reallocate:

; 136  :         return ::operator new(_Bytes);

  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN67@Reallocate:

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00042	8b f0		 mov	 esi, eax
  00044	83 c4 04	 add	 esp, 4
$LN12@Reallocate:
  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
  00052	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 1668 :         _Change_array(_Newvec, _Size, _Newcapacity);

  00055	8b cf		 mov	 ecx, edi
  00057	ff 33		 push	 DWORD PTR [ebx]
  00059	ff 75 fc	 push	 DWORD PTR __Size$1$[ebp]
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
  00062	5e		 pop	 esi

; 1669 :     }

  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN69@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0006b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN66@Reallocate:
  00070	cc		 int	 3
??$_Reallocate@$0A@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXAAI@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate<0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_one_at_back<SShopItemTable const &>, COMDAT
; _this$ = ecx

; 839  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 840  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 841  :         auto& _My_data   = _Mypair._Myval2;
; 842  :         pointer& _Mylast = _My_data._Mylast;
; 843  : 
; 844  :         if (_Mylast != _My_data._Myend) {

  00006	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00009	3b 72 08	 cmp	 esi, DWORD PTR [edx+8]
  0000c	74 25		 je	 SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  00011	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00015	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001f	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00022	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 868  :         _Ty& _Result = *_Mylast;

  00025	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00028	5e		 pop	 esi

; 869  :         ++_Mylast;

  00029	8d 48 0d	 lea	 ecx, DWORD PTR [eax+13]
  0002c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 849  :     }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN2@Emplace_on:

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00033	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
  0003c	5e		 pop	 esi

; 849  :     }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_one_at_back<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find<SItemPos>, COMDAT
; _this$ = ecx

; 1383 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1384 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Keyval$[ebp]
  0000a	8d 45 f4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000d	57		 push	 edi
  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	8b f9		 mov	 edi, ecx
  00012	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00017	8b 45 fc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001e	75 13		 jne	 SHORT $LN2@Find
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00020	8a 0e		 mov	 cl, BYTE PTR [esi]
  00022	3a 48 0e	 cmp	 cl, BYTE PTR [eax+14]
  00025	72 0c		 jb	 SHORT $LN2@Find
  00027	75 0c		 jne	 SHORT $LN1@Find
  00029	66 8b 4e 01	 mov	 cx, WORD PTR [esi+1]
  0002d	66 3b 48 0f	 cmp	 cx, WORD PTR [eax+15]
  00031	73 02		 jae	 SHORT $LN1@Find
$LN2@Find:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1389 :         return _Get_scary()->_Myhead;

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
$LN1@Find:
  00035	5f		 pop	 edi

; 1390 :     }

  00036	5e		 pop	 esi
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 767  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 768  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000e	75 25		 jne	 SHORT $LN51@Erase_tree
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR __Al$[ebp]
$LL2@Erase_tree:

; 769  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	ff 76 08	 push	 DWORD PTR [esi+8]
  00017	8b cb		 mov	 ecx, ebx
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001f	8b c6		 mov	 eax, esi

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  00021	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00023	6a 20		 push	 32			; 00000020H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 768  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00032	74 e0		 je	 SHORT $LL2@Erase_tree
  00034	5f		 pop	 edi
$LN51@Erase_tree:
  00035	5e		 pop	 esi

; 770  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 771  :         }
; 772  :     }

  00036	5b		 pop	 ebx
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 775  :     void _Erase_head(_Alnode& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 776  :         this->_Orphan_all();
; 777  :         _Erase_tree(_Al, _Myhead->_Parent);

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	ff 70 04	 push	 DWORD PTR [eax+4]
  0000b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00013	6a 20		 push	 32			; 00000020H
  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
  0001f	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 779  :     }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<SItemPos const ,SShopItemTable> *>::pointer_to, COMDAT
; __Val$ = ecx

; 528  :         return _STD addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 529  :     }

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<SItemPos const ,SShopItemTable> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength, COMDAT

; 2184 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Tidy, COMDAT
; _this$ = ecx

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2082 :         auto& _Al         = _Getal();
; 2083 :         auto& _My_data    = _Mypair._Myval2;
; 2084 :         pointer& _Myfirst = _My_data._Myfirst;
; 2085 :         pointer& _Mylast  = _My_data._Mylast;
; 2086 :         pointer& _Myend   = _My_data._Myend;
; 2087 : 
; 2088 :         _My_data._Orphan_all();
; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 48		 je	 SHORT $LN2@Tidy

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00014	6b c8 0d	 imul	 ecx, eax, 13

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00017	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001d	72 14		 jb	 SHORT $LN16@Tidy
  0001f	57		 push	 edi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b d7		 sub	 edx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 23		 ja	 SHORT $LN15@Tidy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b d7		 mov	 edx, edi
  00032	5f		 pop	 edi
$LN16@Tidy:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2097 :             _Myend   = nullptr;

  0004a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 2099 :     }

  00051	5e		 pop	 esi
  00052	c3		 ret	 0
$LN15@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 __invoke_watson
$LN23@Tidy:
  00062	cc		 int	 3
?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::capacity, COMDAT
; _this$ = ecx

; 1923 :         auto& _My_data = _Mypair._Myval2;
; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299

; 1925 :     }

  0000b	c3		 ret	 0
?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::max_size, COMDAT
; _this$dead$ = ecx

; 1919 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

  00000	b8 13 3b b1 13	 mov	 eax, 330382099		; 13b13b13H

; 1920 :     }

  00005	c3		 ret	 0
?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 38   :         this->_Adopt(_Plist);
; 39   :     }

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*, COMDAT
; _this$ = ecx

; 185  :         return this->_Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0e	 add	 eax, 14			; 0000000eH

; 274  :         return const_cast<reference>(_Mybase::operator*());
; 275  :     }

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++, COMDAT
; _this$ = ecx

; 192  :     _Tree_const_iterator& operator++() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 195  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 196  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 197  : 
; 198  :         _Mybase::operator++();

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 199  :         return *this;

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 200  :     }

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Orphan_ptr, COMDAT
; _this$dead$ = ecx

; 739  : #if _ITERATOR_DEBUG_LEVEL == 2
; 740  :         _Lockit _Lock(_LOCK_DEBUG);
; 741  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 742  :         while (*_Pnext) {
; 743  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 744  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 745  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 746  :             } else { // orphan the iterator
; 747  :                 (*_Pnext)->_Myproxy = nullptr;
; 748  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 749  :             }
; 750  :         }
; 751  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 752  :         (void) _Ptr;
; 753  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 754  :     }

  00000	c2 04 00	 ret	 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1987 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 1988 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1983 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 1984 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1975 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1976 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z
_TEXT	SEGMENT
__First$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Off$1$ = -4						; size = 4
__Where$ = 8						; size = 8
?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1325 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1667 :         _Iter_diff_t<_InIt> _Off = 0;

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1325 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

  0000b	8b d1		 mov	 edx, ecx
  0000d	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1665 :         auto _UFirst             = _STD _Get_unwrapped(_First);

  0000e	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]

; 1667 :         _Iter_diff_t<_InIt> _Off = 0;

  00011	33 c9		 xor	 ecx, ecx
  00013	8b c7		 mov	 eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1325 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

  00015	89 55 f8	 mov	 DWORD PTR _this$1$[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1667 :         _Iter_diff_t<_InIt> _Off = 0;

  00018	89 4d fc	 mov	 DWORD PTR __Off$1$[ebp], ecx
  0001b	3b c6		 cmp	 eax, esi

; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {

  0001d	74 4f		 je	 SHORT $LN12@Erase
  0001f	33 ff		 xor	 edi, edi
$LL13@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00021	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1669 :             ++_Off;

  00024	47		 inc	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00025	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00029	74 1d		 je	 SHORT $LN18@Erase

; 51   :             _Nodeptr _Pnode;
; 52   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00032	75 10		 jne	 SHORT $LN120@Erase
$LL16@Erase:
  00034	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00037	75 0b		 jne	 SHORT $LN120@Erase

; 53   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00039	8b c1		 mov	 eax, ecx
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00042	74 f0		 je	 SHORT $LL16@Erase
$LN120@Erase:

; 54   :             }
; 55   : 
; 56   :             _Ptr = _Pnode; // ==> parent (head if end())

  00044	8b c1		 mov	 eax, ecx

; 57   :         } else {

  00046	eb 16		 jmp	 SHORT $LN24@Erase
$LN18@Erase:

; 58   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00048	8b c1		 mov	 eax, ecx

; 476  :         while (!_Pnode->_Left->_Isnil) {

  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00050	75 0c		 jne	 SHORT $LN24@Erase
$LL23@Erase:
  00052	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 477  :             _Pnode = _Pnode->_Left;

  00054	8b c2		 mov	 eax, edx
  00056	8b d1		 mov	 edx, ecx
  00058	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0005c	74 f4		 je	 SHORT $LL23@Erase
$LN24@Erase:

; 96   :         return _Ptr == _Right._Ptr;

  0005e	3b c6		 cmp	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {

  00060	75 bf		 jne	 SHORT $LL13@Erase
  00062	8b 55 f8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00065	89 7d fc	 mov	 DWORD PTR __Off$1$[ebp], edi
  00068	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Off$1$[ebp]
$LN12@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1161 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  0006e	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 1326 :         const _Unchecked_const_iterator _First(_Where.first, nullptr);
; 1327 :         const _Unchecked_const_iterator _Last(_Where.second, nullptr);
; 1328 :         const auto _Num = static_cast<size_type>(_STD distance(_First, _Last));
; 1329 :         _Erase_unchecked(_First, _Last);

  00070	89 7d f4	 mov	 DWORD PTR __First$[ebp], edi

; 96   :         return _Ptr == _Right._Ptr;

  00073	3b 3b		 cmp	 edi, DWORD PTR [ebx]

; 1311 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00075	75 2f		 jne	 SHORT $LN104@Erase
  00077	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0007b	74 29		 je	 SHORT $LN104@Erase

; 1374 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  0007d	ff 73 04	 push	 DWORD PTR [ebx+4]
  00080	8b ca		 mov	 ecx, edx
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1330 :         return _Num;

  00088	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]

; 1375 :         _Head->_Parent  = _Head;

  0008b	89 5b 04	 mov	 DWORD PTR [ebx+4], ebx

; 1376 :         _Head->_Left    = _Head;

  0008e	89 1b		 mov	 DWORD PTR [ebx], ebx

; 1377 :         _Head->_Right   = _Head;

  00090	89 5b 08	 mov	 DWORD PTR [ebx+8], ebx

; 1378 :         _Scary->_Mysize = 0;

  00093	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00096	5f		 pop	 edi

; 1331 :     }

  00097	5e		 pop	 esi

; 1378 :         _Scary->_Mysize = 0;

  00098	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1331 :     }

  0009f	5b		 pop	 ebx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
$LN104@Erase:

; 96   :         return _Ptr == _Right._Ptr;

  000a6	3b fe		 cmp	 edi, esi

; 1318 :         while (_First != _Last) {

  000a8	74 34		 je	 SHORT $LN119@Erase
  000aa	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000ad	0f 1f 00	 npad	 3
$LL31@Erase:

; 66   :         ++*this;

  000b0	8d 4d f4	 lea	 ecx, DWORD PTR __First$[ebp]
  000b3	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1303 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  000b8	57		 push	 edi
  000b9	8b cb		 mov	 ecx, ebx
  000bb	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000c0	6a 20		 push	 32			; 00000020H
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  000c8	8b 7d f4	 mov	 edi, DWORD PTR __First$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000cb	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  000ce	3b fe		 cmp	 edi, esi

; 1318 :         while (_First != _Last) {

  000d0	75 de		 jne	 SHORT $LL31@Erase

; 1331 :     }

  000d2	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 08 00	 ret	 8
$LN119@Erase:
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	8b c1		 mov	 eax, ecx
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >, COMDAT
; _this$ = ecx

; 904  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 345  :         const auto _Pnode = _Al.allocate(1);

  00003	6a 20		 push	 32			; 00000020H

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 345  :         const auto _Pnode = _Al.allocate(1);

  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 349  :         _Pnode->_Color = _Black;

  00022	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1957 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00028	89 06		 mov	 DWORD PTR [esi], eax

; 905  :         _Alloc_sentinel_and_proxy();
; 906  :     }

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map
;	COMDAT ??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0>::_Kfn<SItemPos const ,SShopItemTable>, COMDAT
; __Val$ = ecx

; 67   :         return _Val.first;

  00000	8b c1		 mov	 eax, ecx

; 68   :     }

  00002	c3		 ret	 0
??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0>::_Kfn<SItemPos const ,SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z PROC ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>, COMDAT
; _this$ = ecx

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 275  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z ENDP ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Loc$ = -36						; size = 12
$T2 = -24						; size = 12
$T3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Emplace<std::pair<SItemPos,SShopItemTable> >, COMDAT
; _this$ = ecx

; 1010 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx

; 1011 :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Valtys...>;
; 1012 :         const auto _Scary             = _Get_scary();
; 1013 :         _Tree_find_result<_Nodeptr> _Loc;
; 1014 :         _Nodeptr _Inserted;
; 1015 :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1016 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 1017 :             _Loc                = _Find_lower_bound(_Keyval);

  0002a	8b 7d 0c	 mov	 edi, DWORD PTR _<_Vals_0>$[ebp]
  0002d	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  00030	57		 push	 edi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0003e	66 0f d6 45 dc	 movq	 QWORD PTR __Loc$[ebp], xmm0

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00043	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00047	75 30		 jne	 SHORT $LN2@Emplace
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00049	8a 07		 mov	 al, BYTE PTR [edi]
  0004b	3a 41 0e	 cmp	 al, BYTE PTR [ecx+14]
  0004e	72 29		 jb	 SHORT $LN2@Emplace
  00050	75 0a		 jne	 SHORT $LN94@Emplace
  00052	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  00056	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  0005a	72 1d		 jb	 SHORT $LN2@Emplace
$LN94@Emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0005c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1043 :     }

  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
$LN2@Emplace:

; 1648 :         if (max_size() == _Get_scary()->_Mysize) {

  00079	81 7b 04 ff ff
	ff 07		 cmp	 DWORD PTR [ebx+4], 134217727 ; 07ffffffH
  00080	74 7d		 je	 SHORT $LN98@Emplace

; 1018 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1019 :                 return {_Loc._Bound, false};
; 1020 :             }
; 1021 : 
; 1022 :             _Check_grow_by_1();
; 1023 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00082	8b 33		 mov	 esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00084	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  0008e	6a 20		 push	 32			; 00000020H
  00090	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0
  00097	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0009c	66 8b 0f	 mov	 cx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  0009f	8b d0		 mov	 edx, eax
  000a1	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000a4	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  000a8	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  000ab	88 4a 10	 mov	 BYTE PTR [edx+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000ae	8b cb		 mov	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000b0	f3 0f 7e 47 03	 movq	 xmm0, QWORD PTR [edi+3]
  000b5	66 0f d6 42 11	 movq	 QWORD PTR [edx+17], xmm0
  000ba	8b 47 0b	 mov	 eax, DWORD PTR [edi+11]
  000bd	89 42 19	 mov	 DWORD PTR [edx+25], eax
  000c0	8a 47 0f	 mov	 al, BYTE PTR [edi+15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000c3	52		 push	 edx
  000c4	ff 75 e0	 push	 DWORD PTR __Loc$[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000c7	88 42 1d	 mov	 BYTE PTR [edx+29], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000ca	ff 75 dc	 push	 DWORD PTR __Loc$[ebp]

; 831  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000cd	89 32		 mov	 DWORD PTR [edx], esi

; 832  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000cf	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 833  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000d2	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 834  :         this->_Ptr->_Color = _Red;

  000d5	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000db	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000e0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000e3	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1042 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000e5	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000e7	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1043 :     }

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 08 00	 ret	 8
$LN98@Emplace:

; 1649 :             _Throw_tree_length_error();

  000ff	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN96@Emplace:
  00104	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Emplace<std::pair<SItemPos,SShopItemTable> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool const &,0>, COMDAT
; _this$ = ecx

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 275  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1$ = -20						; size = 8
__Last$1$ = -12						; size = 4
__Val$3$ = -8						; size = 4
__Val$2$ = -1						; size = 1
__Pred$ = 8						; size = 1
??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z PROC ; std::_Insertion_sort_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 8241 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	8b c2		 mov	 eax, edx
  00009	8b d9		 mov	 ebx, ecx
  0000b	89 45 f4	 mov	 DWORD PTR __Last$1$[ebp], eax

; 8242 :     // insertion sort [_First, _Last)
; 8243 :     if (_First != _Last) {

  0000e	3b d8		 cmp	 ebx, eax
  00010	0f 84 9c 00 00
	00		 je	 $LN3@Insertion_

; 8244 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00016	8d 53 0d	 lea	 edx, DWORD PTR [ebx+13]
  00019	3b d0		 cmp	 edx, eax
  0001b	0f 84 91 00 00
	00		 je	 $LN3@Insertion_
  00021	56		 push	 esi
  00022	57		 push	 edi
$LL4@Insertion_:

; 8245 :             _BidIt _Hole = _Mid;
; 8246 :             _Iter_value_t<_BidIt> _Val(_STD move(*_Mid));

  00023	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]
  00026	8b f2		 mov	 esi, edx
  00028	f3 0f 7e 0a	 movq	 xmm1, QWORD PTR [edx]
  0002c	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  0002f	66 0f d6 4d ec	 movq	 QWORD PTR __Val$1$[ebp], xmm1
  00034	89 7d f8	 mov	 DWORD PTR __Val$3$[ebp], edi
  00037	88 4d ff	 mov	 BYTE PTR __Val$2$[ebp], cl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0003a	3a 4b 0c	 cmp	 cl, BYTE PTR [ebx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8248 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0003d	73 24		 jae	 SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 5190 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

  0003f	8d 72 0d	 lea	 esi, DWORD PTR [edx+13]
  00042	8b cb		 mov	 ecx, ebx
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8250 :                 *_First = _STD move(_Val);

  0004a	f3 0f 7e 45 ec	 movq	 xmm0, QWORD PTR __Val$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 5190 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

  0004f	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8250 :                 *_First = _STD move(_Val);

  00052	8a 45 ff	 mov	 al, BYTE PTR __Val$2$[ebp]
  00055	8b d6		 mov	 edx, esi
  00057	66 0f d6 03	 movq	 QWORD PTR [ebx], xmm0
  0005b	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  0005e	88 43 0c	 mov	 BYTE PTR [ebx+12], al

; 8251 :             } else { // look for insertion point after first

  00061	eb 42		 jmp	 SHORT $LN2@Insertion_
$LN9@Insertion_:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00063	0f b6 f9	 movzx	 edi, cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8252 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00066	8d 42 f3	 lea	 eax, DWORD PTR [edx-13]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00069	0f b6 4a ff	 movzx	 ecx, BYTE PTR [edx-1]
  0006d	3b f9		 cmp	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8252 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  0006f	73 21		 jae	 SHORT $LN6@Insertion_
$LL7@Insertion_:

; 8253 :                     *_Hole = _STD move(*_Prev); // move hole down

  00071	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00075	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00079	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0007f	8a 48 0c	 mov	 cl, BYTE PTR [eax+12]
  00082	88 4e 0c	 mov	 BYTE PTR [esi+12], cl
  00085	8b f0		 mov	 esi, eax
  00087	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  0008b	83 e8 0d	 sub	 eax, 13			; 0000000dH
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0008e	3b f9		 cmp	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8252 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00090	72 df		 jb	 SHORT $LL7@Insertion_
$LN6@Insertion_:

; 8254 :                 }
; 8255 : 
; 8256 :                 *_Hole = _STD move(_Val); // insert element in hole

  00092	8b 45 f8	 mov	 eax, DWORD PTR __Val$3$[ebp]
  00095	83 c2 0d	 add	 edx, 13			; 0000000dH
  00098	66 0f d6 0e	 movq	 QWORD PTR [esi], xmm1
  0009c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009f	8a 45 ff	 mov	 al, BYTE PTR __Val$2$[ebp]
  000a2	88 46 0c	 mov	 BYTE PTR [esi+12], al
$LN2@Insertion_:

; 8244 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  000a5	8b 45 f4	 mov	 eax, DWORD PTR __Last$1$[ebp]
  000a8	3b d0		 cmp	 edx, eax
  000aa	0f 85 73 ff ff
	ff		 jne	 $LL4@Insertion_
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
$LN3@Insertion_:
  000b2	5b		 pop	 ebx

; 8257 :             }
; 8258 :         }
; 8259 :     }
; 8260 : 
; 8261 :     return _Last;
; 8262 : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z ENDP ; std::_Insertion_sort_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
;	COMDAT ??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
tv414 = -28						; size = 4
__Val$3$ = -24						; size = 4
tv428 = -20						; size = 4
__Bottom$1$ = -16					; size = 4
__Max_sequence_non_leaf$1$ = -12			; size = 4
__Hole$1$ = -8						; size = 4
__Val$1$ = -1						; size = 1
__Pred$ = 8						; size = 1
??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 121  : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 122  :     // make [_First, _Last) into a heap
; 123  :     using _Diff   = _Iter_diff_t<_RanIt>;
; 124  :     _Diff _Bottom = _Last - _First;

  00009	2b d3		 sub	 edx, ebx
  0000b	69 c2 c5 4e ec
	c4		 imul	 eax, edx, -991146299

; 125  :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00011	8b d0		 mov	 edx, eax
  00013	89 45 f0	 mov	 DWORD PTR __Bottom$1$[ebp], eax
  00016	d1 fa		 sar	 edx, 1
  00018	85 d2		 test	 edx, edx
  0001a	0f 8e 0b 01 00
	00		 jle	 $LN3@Make_heap_

; 122  :     // make [_First, _Last) into a heap
; 123  :     using _Diff   = _Iter_diff_t<_RanIt>;
; 124  :     _Diff _Bottom = _Last - _First;

  00020	48		 dec	 eax
  00021	8b c8		 mov	 ecx, eax
  00023	89 45 ec	 mov	 DWORD PTR tv428[ebp], eax
  00026	6b c2 0d	 imul	 eax, edx, 13
  00029	d1 f9		 sar	 ecx, 1
  0002b	56		 push	 esi
  0002c	89 4d f4	 mov	 DWORD PTR __Max_sequence_non_leaf$1$[ebp], ecx
  0002f	57		 push	 edi
  00030	03 c3		 add	 eax, ebx
$LL4@Make_heap_:

; 126  :         // reheap top half, bottom to top
; 127  :         --_Hole;
; 128  :         _Iter_value_t<_RanIt> _Val(_STD move(*(_First + _Hole)));

  00032	8b 70 fb	 mov	 esi, DWORD PTR [eax-5]
  00035	83 e8 0d	 sub	 eax, 13			; 0000000dH
  00038	4a		 dec	 edx
  00039	89 45 e4	 mov	 DWORD PTR tv414[ebp], eax
  0003c	89 75 e8	 mov	 DWORD PTR __Val$3$[ebp], esi

; 129  :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  0003f	8b fa		 mov	 edi, edx
  00041	89 55 f8	 mov	 DWORD PTR __Hole$1$[ebp], edx

; 64   :     _Diff _Idx       = _Hole;

  00044	8b f2		 mov	 esi, edx

; 126  :         // reheap top half, bottom to top
; 127  :         --_Hole;
; 128  :         _Iter_value_t<_RanIt> _Val(_STD move(*(_First + _Hole)));

  00046	f3 0f 7e 08	 movq	 xmm1, QWORD PTR [eax]
  0004a	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  0004d	88 45 ff	 mov	 BYTE PTR __Val$1$[ebp], al

; 69   :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  00050	3b d1		 cmp	 edx, ecx
  00052	7d 43		 jge	 SHORT $LN8@Make_heap_
$LL7@Make_heap_:

; 70   :         _Idx = 2 * _Idx + 2;

  00054	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]

; 71   :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00057	6b ca 0d	 imul	 ecx, edx, 13

; 72   :             --_Idx;
; 73   :         }
; 74   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0005a	0f b6 44 19 26	 movzx	 eax, BYTE PTR [ecx+ebx+38]
  0005f	3a 44 19 19	 cmp	 al, BYTE PTR [ecx+ebx+25]
  00063	1b c0		 sbb	 eax, eax
  00065	6b cf 0d	 imul	 ecx, edi, 13
  00068	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0006b	03 f2		 add	 esi, edx
  0006d	6b d6 0d	 imul	 edx, esi, 13

; 75   :         _Hole             = _Idx;

  00070	8b fe		 mov	 edi, esi
  00072	f3 0f 7e 04 1a	 movq	 xmm0, QWORD PTR [edx+ebx]
  00077	66 0f d6 04 19	 movq	 QWORD PTR [ecx+ebx], xmm0
  0007c	8b 44 1a 08	 mov	 eax, DWORD PTR [edx+ebx+8]
  00080	89 44 19 08	 mov	 DWORD PTR [ecx+ebx+8], eax
  00084	0f b6 44 1a 0c	 movzx	 eax, BYTE PTR [edx+ebx+12]
  00089	88 44 19 0c	 mov	 BYTE PTR [ecx+ebx+12], al
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  00090	3b f1		 cmp	 esi, ecx
  00092	7c c0		 jl	 SHORT $LL7@Make_heap_
  00094	8b 55 f8	 mov	 edx, DWORD PTR __Hole$1$[ebp]
$LN8@Make_heap_:

; 76   :     }
; 77   : 
; 78   :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00097	3b f9		 cmp	 edi, ecx
  00099	75 2e		 jne	 SHORT $LN10@Make_heap_
  0009b	8b 45 f0	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
  0009e	a8 01		 test	 al, 1
  000a0	75 27		 jne	 SHORT $LN10@Make_heap_

; 79   :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a2	6b c8 0d	 imul	 ecx, eax, 13
  000a5	6b d7 0d	 imul	 edx, edi, 13

; 80   :         _Hole             = _Bottom - 1;

  000a8	8b 7d ec	 mov	 edi, DWORD PTR tv428[ebp]
  000ab	f3 0f 7e 44 19
	f3		 movq	 xmm0, QWORD PTR [ecx+ebx-13]
  000b1	66 0f d6 04 1a	 movq	 QWORD PTR [edx+ebx], xmm0
  000b6	8b 44 19 fb	 mov	 eax, DWORD PTR [ecx+ebx-5]
  000ba	89 44 1a 08	 mov	 DWORD PTR [edx+ebx+8], eax
  000be	8a 44 19 ff	 mov	 al, BYTE PTR [ecx+ebx-1]
  000c2	88 44 1a 0c	 mov	 BYTE PTR [edx+ebx+12], al
  000c6	8b 55 f8	 mov	 edx, DWORD PTR __Hole$1$[ebp]
$LN10@Make_heap_:

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000c9	3b d7		 cmp	 edx, edi
  000cb	7d 38		 jge	 SHORT $LN33@Make_heap_
  000cd	0f 1f 00	 npad	 3
$LL17@Make_heap_:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000d0	8a 4d ff	 mov	 cl, BYTE PTR __Val$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 26   :     for (_Diff _Idx                                                         = (_Hole - 1) >> 1; // shift for codegen

  000d3	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000d6	d1 f8		 sar	 eax, 1

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000d8	6b f0 0d	 imul	 esi, eax, 13
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000db	03 f3		 add	 esi, ebx
  000dd	38 4e 0c	 cmp	 BYTE PTR [esi+12], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000e0	73 23		 jae	 SHORT $LN33@Make_heap_

; 28   :         // move _Hole up to parent
; 29   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  000e2	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  000e6	6b d7 0d	 imul	 edx, edi, 13

; 30   :         _Hole             = _Idx;

  000e9	8b f8		 mov	 edi, eax
  000eb	66 0f d6 04 1a	 movq	 QWORD PTR [edx+ebx], xmm0
  000f0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000f3	89 4c 1a 08	 mov	 DWORD PTR [edx+ebx+8], ecx
  000f7	8a 4e 0c	 mov	 cl, BYTE PTR [esi+12]
  000fa	88 4c 1a 0c	 mov	 BYTE PTR [edx+ebx+12], cl
  000fe	8b 55 f8	 mov	 edx, DWORD PTR __Hole$1$[ebp]
  00101	3b d0		 cmp	 edx, eax
  00103	7c cb		 jl	 SHORT $LL17@Make_heap_
$LN33@Make_heap_:

; 31   :     }
; 32   : 
; 33   :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00105	8b 4d e8	 mov	 ecx, DWORD PTR __Val$3$[ebp]
  00108	6b c7 0d	 imul	 eax, edi, 13
  0010b	66 0f d6 0c 18	 movq	 QWORD PTR [eax+ebx], xmm1
  00110	89 4c 18 08	 mov	 DWORD PTR [eax+ebx+8], ecx
  00114	8a 4d ff	 mov	 cl, BYTE PTR __Val$1$[ebp]
  00117	88 4c 18 0c	 mov	 BYTE PTR [eax+ebx+12], cl

; 125  :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  0011b	8b 45 e4	 mov	 eax, DWORD PTR tv414[ebp]
  0011e	8b 4d f4	 mov	 ecx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  00121	85 d2		 test	 edx, edx
  00123	0f 8f 09 ff ff
	ff		 jg	 $LL4@Make_heap_
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
$LN3@Make_heap_:
  0012b	5b		 pop	 ebx

; 130  :     }
; 131  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1 = -16						; size = 13
__Pred$ = 8						; size = 1
??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Sort_heap_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7146 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx

; 7148 :     for (; _Last - _First >= 2; --_Last) {

  0000a	8b f2		 mov	 esi, edx
  0000c	2b f3		 sub	 esi, ebx
  0000e	83 fe 1a	 cmp	 esi, 26			; 0000001aH
  00011	7c 65		 jl	 SHORT $LN3@Sort_heap_
  00013	57		 push	 edi
  00014	8d 7a f3	 lea	 edi, DWORD PTR [edx-13]
$LL4@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 100  :     if (2 <= _Last - _First) {

  00017	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0001c	f7 e6		 mul	 esi
  0001e	8b f7		 mov	 esi, edi
  00020	c1 ea 02	 shr	 edx, 2
  00023	2b f3		 sub	 esi, ebx
  00025	83 fa 02	 cmp	 edx, 2
  00028	7c 45		 jl	 SHORT $LN2@Sort_heap_

; 101  :         --_Last;
; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  0002a	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]

; 93   :     _STD _Pop_heap_hole_by_index(

  0002e	33 d2		 xor	 edx, edx

; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00030	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 93   :     _STD _Pop_heap_hole_by_index(

  00033	8b cb		 mov	 ecx, ebx
  00035	ff 75 08	 push	 DWORD PTR __Pred$[ebp]

; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00038	89 45 f8	 mov	 DWORD PTR __Val$1[ebp+8], eax
  0003b	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  0003f	66 0f d6 45 f0	 movq	 QWORD PTR __Val$1[ebp], xmm0

; 91   :     *_Dest      = _STD move(*_First);

  00044	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]

; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00048	88 45 fc	 mov	 BYTE PTR __Val$1[ebp+12], al

; 91   :     *_Dest      = _STD move(*_First);

  0004b	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  0004f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00052	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00055	0f b6 43 0c	 movzx	 eax, BYTE PTR [ebx+12]
  00059	88 47 0c	 mov	 BYTE PTR [edi+12], al

; 92   :     using _Diff = _Iter_diff_t<_RanIt>;
; 93   :     _STD _Pop_heap_hole_by_index(

  0005c	8d 45 f0	 lea	 eax, DWORD PTR __Val$1[ebp]
  0005f	50		 push	 eax
  00060	69 c6 c5 4e ec
	c4		 imul	 eax, esi, -991146299
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Sort_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 7148 :     for (; _Last - _First >= 2; --_Last) {

  0006f	83 ef 0d	 sub	 edi, 13			; 0000000dH
  00072	83 fe 1a	 cmp	 esi, 26			; 0000001aH
  00075	7d a0		 jge	 SHORT $LL4@Sort_heap_
  00077	5f		 pop	 edi
$LN3@Sort_heap_:
  00078	5e		 pop	 esi

; 7149 :         _STD _Pop_heap_unchecked(_First, _Last, _Pred);
; 7150 :     }
; 7151 : }

  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Sort_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -20					; size = 4
tv653 = -16						; size = 4
tv659 = -16						; size = 4
tv574 = -12						; size = 4
__Gfirst$1$ = -12					; size = 4
tv654 = -8						; size = 4
__Plast$1$ = -8						; size = 4
__First$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
__Glast$1$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 8298 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8299 :     // partition [_First, _Last)
; 8300 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  00009	8b 7d 08	 mov	 edi, DWORD PTR __Last$[ebp]
  0000c	8b c7		 mov	 eax, edi
  0000e	2b c2		 sub	 eax, edx
  00010	89 4d ec	 mov	 DWORD PTR ___$ReturnUdt$1$[ebp], ecx
  00013	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00019	89 55 fc	 mov	 DWORD PTR __First$1$[ebp], edx

; 8301 :     _STD _Guess_median_unchecked(_First, _Mid, _STD _Prev_iter(_Last), _Pred);

  0001c	8d 4f f3	 lea	 ecx, DWORD PTR [edi-13]

; 8284 :     const _Diff _Count = _Last - _First;

  0001f	8b fa		 mov	 edi, edx

; 8301 :     _STD _Guess_median_unchecked(_First, _Mid, _STD _Prev_iter(_Last), _Pred);

  00021	89 4d f4	 mov	 DWORD PTR tv574[ebp], ecx
  00024	d1 f8		 sar	 eax, 1
  00026	6b f0 0d	 imul	 esi, eax, 13

; 8284 :     const _Diff _Count = _Last - _First;

  00029	8b c1		 mov	 eax, ecx
  0002b	2b c7		 sub	 eax, edi
  0002d	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299

; 8299 :     // partition [_First, _Last)
; 8300 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  00033	03 f2		 add	 esi, edx

; 8285 :     if (40 < _Count) { // Tukey's ninther

  00035	83 f8 28	 cmp	 eax, 40			; 00000028H
  00038	7e 61		 jle	 SHORT $LN75@Partition_

; 8286 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0003a	40		 inc	 eax
  0003b	c1 f8 03	 sar	 eax, 3

; 8287 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 8288 :         _STD _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0003e	6b d8 0d	 imul	 ebx, eax, 13
  00041	6b c8 1a	 imul	 ecx, eax, 26
  00044	8b 45 fc	 mov	 eax, DWORD PTR __First$1$[ebp]
  00047	03 c1		 add	 eax, ecx
  00049	89 4d f8	 mov	 DWORD PTR tv654[ebp], ecx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __First$1$[ebp]
  0004f	8d 14 3b	 lea	 edx, DWORD PTR [ebx+edi]
  00052	8b 7d 0c	 mov	 edi, DWORD PTR __Pred$[ebp]
  00055	57		 push	 edi
  00056	50		 push	 eax
  00057	89 55 f0	 mov	 DWORD PTR tv653[ebp], edx
  0005a	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8289 :         _STD _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0005f	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  00062	8b ce		 mov	 ecx, esi
  00064	57		 push	 edi
  00065	50		 push	 eax
  00066	2b cb		 sub	 ecx, ebx
  00068	8b d6		 mov	 edx, esi
  0006a	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8290 :         _STD _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  0006f	8b 45 f4	 mov	 eax, DWORD PTR tv574[ebp]
  00072	8b f8		 mov	 edi, eax
  00074	2b fb		 sub	 edi, ebx
  00076	8b 5d 0c	 mov	 ebx, DWORD PTR __Pred$[ebp]
  00079	53		 push	 ebx
  0007a	50		 push	 eax
  0007b	2b 45 f8	 sub	 eax, DWORD PTR tv654[ebp]
  0007e	8b d7		 mov	 edx, edi
  00080	8b c8		 mov	 ecx, eax
  00082	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8291 :         _STD _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR tv653[ebp]
  0008a	8b d6		 mov	 edx, esi
  0008c	53		 push	 ebx
  0008d	57		 push	 edi
  0008e	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8292 :     } else {

  00093	8b 7d fc	 mov	 edi, DWORD PTR __First$1$[ebp]
  00096	83 c4 20	 add	 esp, 32			; 00000020H
  00099	eb 10		 jmp	 SHORT $LN76@Partition_
$LN75@Partition_:

; 8293 :         _STD _Med3_unchecked(_First, _Mid, _Last, _Pred);

  0009b	ff 75 0c	 push	 DWORD PTR __Pred$[ebp]
  0009e	8b d6		 mov	 edx, esi
  000a0	51		 push	 ecx
  000a1	8b cf		 mov	 ecx, edi
  000a3	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  000a8	83 c4 08	 add	 esp, 8
$LN76@Partition_:

; 8302 :     _RanIt _Pfirst = _Mid;
; 8303 :     _RanIt _Plast  = _STD _Next_iter(_Pfirst);

  000ab	8d 5e 0d	 lea	 ebx, DWORD PTR [esi+13]
  000ae	89 5d f8	 mov	 DWORD PTR __Plast$1$[ebp], ebx

; 8306 :            && !_Pred(*_Pfirst, *_STD _Prev_iter(_Pfirst))) {

  000b1	3b fe		 cmp	 edi, esi
  000b3	73 11		 jae	 SHORT $LN105@Partition_
$LL2@Partition_:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000b5	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  000b8	3a 46 0c	 cmp	 al, BYTE PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8306 :            && !_Pred(*_Pfirst, *_STD _Prev_iter(_Pfirst))) {

  000bb	72 09		 jb	 SHORT $LN105@Partition_
  000bd	77 07		 ja	 SHORT $LN105@Partition_

; 8307 :         --_Pfirst;

  000bf	83 ee 0d	 sub	 esi, 13			; 0000000dH
  000c2	3b fe		 cmp	 edi, esi
  000c4	72 ef		 jb	 SHORT $LL2@Partition_
$LN105@Partition_:

; 8310 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000c6	8b 55 08	 mov	 edx, DWORD PTR __Last$[ebp]
  000c9	3b da		 cmp	 ebx, edx
  000cb	73 14		 jae	 SHORT $LN5@Partition_
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000cd	8a 4e 0c	 mov	 cl, BYTE PTR [esi+12]
$LL4@Partition_:
  000d0	38 4b 0c	 cmp	 BYTE PTR [ebx+12], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8310 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000d3	72 09		 jb	 SHORT $LN106@Partition_
  000d5	77 07		 ja	 SHORT $LN106@Partition_

; 8311 :         ++_Plast;

  000d7	83 c3 0d	 add	 ebx, 13			; 0000000dH
  000da	3b da		 cmp	 ebx, edx
  000dc	72 f2		 jb	 SHORT $LL4@Partition_
$LN106@Partition_:
  000de	89 5d f8	 mov	 DWORD PTR __Plast$1$[ebp], ebx
$LN5@Partition_:

; 8312 :     }
; 8313 : 
; 8314 :     _RanIt _Gfirst = _Plast;
; 8315 :     _RanIt _Glast  = _Pfirst;

  000e1	8b c6		 mov	 eax, esi
  000e3	8b fb		 mov	 edi, ebx
  000e5	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
$LN133@Partition_:

; 8316 : 
; 8317 :     for (;;) { // partition
; 8318 :         for (; _Gfirst < _Last; ++_Gfirst) {

  000e8	89 7d f4	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
  000eb	0f 1f 44 00 00	 npad	 5
$LL8@Partition_:
  000f0	3b fa		 cmp	 edi, edx
  000f2	73 56		 jae	 SHORT $LN84@Partition_
$LL11@Partition_:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000f4	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  000f7	3a 47 0c	 cmp	 al, BYTE PTR [edi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8319 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  000fa	72 3e		 jb	 SHORT $LN9@Partition_

; 8320 :                 continue;
; 8321 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  000fc	77 43		 ja	 SHORT $LN107@Partition_

; 8322 :                 break;
; 8323 :             } else if (_Plast != _Gfirst) {

  000fe	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  00101	89 45 f0	 mov	 DWORD PTR tv659[ebp], eax
  00104	3b df		 cmp	 ebx, edi
  00106	74 30		 je	 SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 139  :     _Ty _Tmp = _STD move(_Left);

  00108	8a 53 0c	 mov	 dl, BYTE PTR [ebx+12]
  0010b	f3 0f 7e 0b	 movq	 xmm1, QWORD PTR [ebx]
  0010f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 140  :     _Left    = _STD move(_Right);

  00112	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00116	66 0f d6 03	 movq	 QWORD PTR [ebx], xmm0
  0011a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0011d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00120	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  00123	88 43 0c	 mov	 BYTE PTR [ebx+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8325 :                 ++_Plast;

  00126	8b 5d f0	 mov	 ebx, DWORD PTR tv659[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 141  :     _Right   = _STD move(_Tmp);

  00129	66 0f d6 0f	 movq	 QWORD PTR [edi], xmm1
  0012d	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00130	88 57 0c	 mov	 BYTE PTR [edi+12], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8326 :             } else {

  00133	8b 55 08	 mov	 edx, DWORD PTR __Last$[ebp]
  00136	eb 02		 jmp	 SHORT $LN9@Partition_
$LN19@Partition_:

; 8327 :                 ++_Plast;

  00138	8b d8		 mov	 ebx, eax
$LN9@Partition_:

; 8316 : 
; 8317 :     for (;;) { // partition
; 8318 :         for (; _Gfirst < _Last; ++_Gfirst) {

  0013a	83 c7 0d	 add	 edi, 13			; 0000000dH
  0013d	3b fa		 cmp	 edi, edx
  0013f	72 b3		 jb	 SHORT $LL11@Partition_
$LN107@Partition_:
  00141	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  00144	89 5d f8	 mov	 DWORD PTR __Plast$1$[ebp], ebx
  00147	89 7d f4	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
$LN84@Partition_:

; 8331 :         for (; _First < _Glast; --_Glast) {

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR __First$1$[ebp]
  0014d	3b c1		 cmp	 eax, ecx
  0014f	76 5c		 jbe	 SHORT $LN132@Partition_
  00151	8d 78 f3	 lea	 edi, DWORD PTR [eax-13]
  00154	8b d9		 mov	 ebx, ecx
$LL14@Partition_:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00156	8a 4f 0c	 mov	 cl, BYTE PTR [edi+12]
  00159	3a 4e 0c	 cmp	 cl, BYTE PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8333 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

  0015c	72 34		 jb	 SHORT $LN12@Partition_

; 8334 :                 continue;
; 8335 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

  0015e	77 3f		 ja	 SHORT $LN108@Partition_

; 8336 :                 break;
; 8337 :             } else if (--_Pfirst != _Glast_prev) {

  00160	83 ee 0d	 sub	 esi, 13			; 0000000dH
  00163	3b f7		 cmp	 esi, edi
  00165	74 2b		 je	 SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  00167	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  0016b	f3 0f 7e 0e	 movq	 xmm1, QWORD PTR [esi]
  0016f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00172	8a 56 0c	 mov	 dl, BYTE PTR [esi+12]
  00175	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00179	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0017c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0017f	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  00182	88 46 0c	 mov	 BYTE PTR [esi+12], al
  00185	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]

; 141  :     _Right   = _STD move(_Tmp);

  00188	66 0f d6 0f	 movq	 QWORD PTR [edi], xmm1
  0018c	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0018f	88 57 0c	 mov	 BYTE PTR [edi+12], dl
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8331 :         for (; _First < _Glast; --_Glast) {

  00192	83 e8 0d	 sub	 eax, 13			; 0000000dH
  00195	83 ef 0d	 sub	 edi, 13			; 0000000dH
  00198	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
  0019b	3b d8		 cmp	 ebx, eax
  0019d	72 b7		 jb	 SHORT $LL14@Partition_
$LN108@Partition_:
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR __First$1$[ebp]

; 8338 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8339 :             }
; 8340 :         }
; 8341 : 
; 8342 :         if (_Glast == _First && _Gfirst == _Last) {

  001a2	3b c1		 cmp	 eax, ecx
  001a4	8b 7d f4	 mov	 edi, DWORD PTR __Gfirst$1$[ebp]
  001a7	8b 5d f8	 mov	 ebx, DWORD PTR __Plast$1$[ebp]
  001aa	8b 55 08	 mov	 edx, DWORD PTR __Last$[ebp]
$LN132@Partition_:
  001ad	75 73		 jne	 SHORT $LN27@Partition_
  001af	3b fa		 cmp	 edi, edx
  001b1	0f 84 1f 01 00
	00		 je	 $LN86@Partition_

; 8344 :         }
; 8345 : 
; 8346 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8347 :             if (_Plast != _Gfirst) {

  001b7	3b df		 cmp	 ebx, edi
  001b9	74 28		 je	 SHORT $LN45@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  001bb	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]
  001bf	f3 0f 7e 0e	 movq	 xmm1, QWORD PTR [esi]
  001c3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c6	8a 56 0c	 mov	 dl, BYTE PTR [esi+12]
  001c9	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  001cd	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  001d0	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001d3	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  001d6	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 141  :     _Right   = _STD move(_Tmp);

  001d9	66 0f d6 0b	 movq	 QWORD PTR [ebx], xmm1
  001dd	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  001e0	88 53 0c	 mov	 BYTE PTR [ebx+12], dl
$LN45@Partition_:

; 139  :     _Ty _Tmp = _STD move(_Left);

  001e3	8a 56 0c	 mov	 dl, BYTE PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8351 :             ++_Plast;

  001e6	83 c3 0d	 add	 ebx, 13			; 0000000dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  001e9	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  001ed	f3 0f 7e 0e	 movq	 xmm1, QWORD PTR [esi]
  001f1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001f4	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  001f8	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001fb	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001fe	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  00201	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8353 :             ++_Pfirst;

  00204	83 c6 0d	 add	 esi, 13			; 0000000dH

; 8354 :             ++_Gfirst;

  00207	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 141  :     _Right   = _STD move(_Tmp);

  0020a	66 0f d6 0f	 movq	 QWORD PTR [edi], xmm1
  0020e	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00211	88 57 0c	 mov	 BYTE PTR [edi+12], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8354 :             ++_Gfirst;

  00214	83 c7 0d	 add	 edi, 13			; 0000000dH
  00217	8b 55 08	 mov	 edx, DWORD PTR __Last$[ebp]
  0021a	89 5d f8	 mov	 DWORD PTR __Plast$1$[ebp], ebx
  0021d	e9 c6 fe ff ff	 jmp	 $LN133@Partition_
$LN27@Partition_:

; 8355 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  00222	83 c0 f3	 add	 eax, -13		; fffffff3H
  00225	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
  00228	3b fa		 cmp	 edi, edx
  0022a	75 6e		 jne	 SHORT $LN30@Partition_

; 8356 :             if (--_Glast != --_Pfirst) {

  0022c	83 ee 0d	 sub	 esi, 13			; 0000000dH
  0022f	3b c6		 cmp	 eax, esi
  00231	74 2e		 je	 SHORT $LN59@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 139  :     _Ty _Tmp = _STD move(_Left);

  00233	f3 0f 7e 08	 movq	 xmm1, QWORD PTR [eax]
  00237	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0023a	8a 50 0c	 mov	 dl, BYTE PTR [eax+12]

; 140  :     _Left    = _STD move(_Right);

  0023d	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  00241	8b 7d 0c	 mov	 edi, DWORD PTR __Glast$1$[ebp]
  00244	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00248	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0024b	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0024e	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00251	88 47 0c	 mov	 BYTE PTR [edi+12], al
  00254	8b 7d f4	 mov	 edi, DWORD PTR __Gfirst$1$[ebp]

; 141  :     _Right   = _STD move(_Tmp);

  00257	66 0f d6 0e	 movq	 QWORD PTR [esi], xmm1
  0025b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0025e	88 56 0c	 mov	 BYTE PTR [esi+12], dl
$LN59@Partition_:

; 139  :     _Ty _Tmp = _STD move(_Left);

  00261	8a 56 0c	 mov	 dl, BYTE PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8360 :             swap(*_Pfirst, *--_Plast); // intentional ADL

  00264	83 eb 0d	 sub	 ebx, 13			; 0000000dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 139  :     _Ty _Tmp = _STD move(_Left);

  00267	f3 0f 7e 0e	 movq	 xmm1, QWORD PTR [esi]
  0026b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8360 :             swap(*_Pfirst, *--_Plast); // intentional ADL

  0026e	89 5d f8	 mov	 DWORD PTR __Plast$1$[ebp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  00271	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]
  00275	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00279	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0027c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0027f	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  00282	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8361 :         } else {

  00285	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 141  :     _Right   = _STD move(_Tmp);

  00288	66 0f d6 0b	 movq	 QWORD PTR [ebx], xmm1
  0028c	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  0028f	88 53 0c	 mov	 BYTE PTR [ebx+12], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8361 :         } else {

  00292	8b 55 08	 mov	 edx, DWORD PTR __Last$[ebp]
  00295	e9 56 fe ff ff	 jmp	 $LL8@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  0029a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0029e	8a 57 0c	 mov	 dl, BYTE PTR [edi+12]
  002a1	f3 0f 7e 0f	 movq	 xmm1, QWORD PTR [edi]
  002a5	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  002a8	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8362 :             swap(*_Gfirst, *--_Glast); // intentional ADL

  002ac	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  002af	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002b2	89 47 08	 mov	 DWORD PTR [edi+8], eax
  002b5	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  002b8	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  002bb	88 47 0c	 mov	 BYTE PTR [edi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8363 :             ++_Gfirst;

  002be	83 c7 0d	 add	 edi, 13			; 0000000dH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 141  :     _Right   = _STD move(_Tmp);

  002c1	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  002c4	66 0f d6 08	 movq	 QWORD PTR [eax], xmm1
  002c8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002cb	88 50 0c	 mov	 BYTE PTR [eax+12], dl
  002ce	8b 55 08	 mov	 edx, DWORD PTR __Last$[ebp]
  002d1	e9 12 fe ff ff	 jmp	 $LN133@Partition_
$LN86@Partition_:

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  002d6	8b 45 ec	 mov	 eax, DWORD PTR ___$ReturnUdt$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8343 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  002d9	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  002da	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8343 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  002dc	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  002dd	89 58 04	 mov	 DWORD PTR [eax+4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8343 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  002e0	5b		 pop	 ebx

; 8364 :         }
; 8365 :     }
; 8366 : }

  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@0@AAI@Z
_TEXT	SEGMENT
??$_Allocate_at_least_helper@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<SShopItemTable> >, COMDAT
; __Al$dead$ = ecx
; __Count$ = edx

; 2295 : #if _HAS_CXX23
; 2296 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2297 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2298 :         _Count                  = _Allocated;
; 2299 :         return _Ptr;
; 2300 :     } else
; 2301 : #endif // _HAS_CXX23
; 2302 :     {
; 2303 :         return _Al.allocate(_Count);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]

; 117  :         if (_Count > _Max_possible) {

  00002	3d 13 3b b1 13	 cmp	 eax, 330382099		; 13b13b13H
  00007	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0000d	6b c0 0d	 imul	 eax, eax, 13

; 227  :     if (_Bytes == 0) {

  00010	85 c0		 test	 eax, eax
  00012	75 01		 jne	 SHORT $LN10@Allocate_a

; 2304 :     }
; 2305 : }

  00014	c3		 ret	 0
$LN10@Allocate_a:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00015	50		 push	 eax
  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 09		 jb	 SHORT $LN12@Allocate_a

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0001d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>

; 2304 :     }
; 2305 : }

  00022	83 c4 04	 add	 esp, 4
  00025	c3		 ret	 0
$LN12@Allocate_a:

; 136  :         return ::operator new(_Bytes);

  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 2304 :     }
; 2305 : }

  0002b	83 c4 04	 add	 esp, 4
  0002e	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z PROC ; std::_Get_unwrapped<SShopItemTable * const &>, COMDAT
; __It$ = ecx

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z ENDP ; std::_Get_unwrapped<SShopItemTable * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z PROC ; std::_Uninitialized_move<SShopItemTable *,std::allocator<SShopItemTable> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1977 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00005	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00008	8b fa		 mov	 edi, edx
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>

; 1993 :             return _Dest + (_ULast - _UFirst);

  00011	2b fe		 sub	 edi, esi
  00013	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00018	f7 ef		 imul	 edi
  0001a	83 c4 04	 add	 esp, 4
  0001d	c1 fa 02	 sar	 edx, 2
  00020	8b c2		 mov	 eax, edx
  00022	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00025	03 c2		 add	 eax, edx
  00027	6b c0 0d	 imul	 eax, eax, 13
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	03 45 08	 add	 eax, DWORD PTR __Dest$[ebp]

; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1999 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 2000 :     }
; 2001 : 
; 2002 :     return _Backout._Release();
; 2003 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z ENDP ; std::_Uninitialized_move<SShopItemTable *,std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z
_TEXT	SEGMENT
??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z PROC ; std::forward<SShopItemTable const &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z ENDP ; std::forward<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_back_with_unused_capacity<SShopItemTable const &>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000a	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00011	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00015	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00018	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001b	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  0001e	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 868  :         _Ty& _Result = *_Mylast;

  00021	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 869  :         ++_Mylast;

  00024	8d 48 0d	 lea	 ecx, DWORD PTR [eax+13]
  00027	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 870  : 
; 871  :         return _Result;

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 872  :     }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_back_with_unused_capacity<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -12					; size = 4
__Whereoff$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>, COMDAT
; _this$ = ecx

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();
; 878  :         auto& _My_data    = _Mypair._Myval2;
; 879  :         pointer& _Myfirst = _My_data._Myfirst;
; 880  :         pointer& _Mylast  = _My_data._Mylast;
; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b 31		 mov	 esi, DWORD PTR [ecx]
  00012	2b d6		 sub	 edx, esi
  00014	f7 ea		 imul	 edx
  00016	57		 push	 edi
  00017	c1 fa 02	 sar	 edx, 2
  0001a	8b c2		 mov	 eax, edx
  0001c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx
  00024	89 45 f8	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00027	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002a	2b c6		 sub	 eax, esi
  0002c	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00032	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

  00035	3d 13 3b b1 13	 cmp	 eax, 330382099		; 13b13b13H
  0003a	0f 84 d8 00 00
	00		 je	 $LN129@Emplace_re

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

  00040	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00043	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00046	2b c6		 sub	 eax, esi
  00048	69 d0 c5 4e ec
	c4		 imul	 edx, eax, -991146299

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004e	b8 13 3b b1 13	 mov	 eax, 330382099		; 13b13b13H
  00053	8b ca		 mov	 ecx, edx
  00055	d1 e9		 shr	 ecx, 1
  00057	2b c1		 sub	 eax, ecx
  00059	3b d0		 cmp	 edx, eax
  0005b	76 12		 jbe	 SHORT $LN8@Emplace_re

; 2012 :             return _Max; // geometric growth would overflow

  0005d	b8 f7 ff ff ff	 mov	 eax, -9			; fffffff7H
  00062	be 13 3b b1 13	 mov	 esi, 330382099		; 13b13b13H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	eb 36		 jmp	 SHORT $LN127@Emplace_re
$LN8@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006f	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00072	8b f3		 mov	 esi, ebx
  00074	3b c3		 cmp	 eax, ebx
  00076	0f 43 f0	 cmovae	 esi, eax
  00079	81 fe 13 3b b1
	13		 cmp	 esi, 330382099		; 13b13b13H
  0007f	0f 87 98 00 00
	00		 ja	 $LN130@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00085	6b c6 0d	 imul	 eax, esi, 13

; 227  :     if (_Bytes == 0) {

  00088	85 c0		 test	 eax, eax
  0008a	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0008c	33 ff		 xor	 edi, edi
  0008e	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00095	72 08		 jb	 SHORT $LN25@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009d	eb 06		 jmp	 SHORT $LN127@Emplace_re
$LN25@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN127@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 900  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a5	8b f8		 mov	 edi, eax
  000a7	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000aa	6b 5d f8 0d	 imul	 ebx, DWORD PTR __Whereoff$1$[ebp], 13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 900  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000b1	03 df		 add	 ebx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  000b3	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  000b7	66 0f d6 03	 movq	 QWORD PTR [ebx], xmm0
  000bb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000be	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000c1	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000c4	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  000c7	88 43 0c	 mov	 BYTE PTR [ebx+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000cd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d0	8b 00		 mov	 eax, DWORD PTR [eax]
  000d2	3b ca		 cmp	 ecx, edx
  000d4	75 04		 jne	 SHORT $LN3@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000d6	8b cf		 mov	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 909  :         } else { // provide basic guarantee

  000d8	eb 19		 jmp	 SHORT $LN74@Emplace_re
$LN3@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000da	8b d1		 mov	 edx, ecx
  000dc	8b c8		 mov	 ecx, eax
  000de	57		 push	 edi
  000df	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>

; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000e7	8d 4b 0d	 lea	 ecx, DWORD PTR [ebx+13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000ea	83 c4 04	 add	 esp, 4

; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000ed	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000f0	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
$LN74@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000f3	51		 push	 ecx
  000f4	8b c8		 mov	 ecx, eax
  000f6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
  000fb	8b 45 f4	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00104	40		 inc	 eax
  00105	56		 push	 esi
  00106	50		 push	 eax
  00107	57		 push	 edi
  00108	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array

; 918  :     }

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	8b c3		 mov	 eax, ebx
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
$LN129@Emplace_re:

; 888  :             _Xlength();

  00118	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
$LN130@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0011d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN126@Emplace_re:
  00122	cc		 int	 3
??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>, COMDAT
; _this$ = ecx

; 1628 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1629 :         const auto _Scary = _Get_scary();
; 1630 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	89 02		 mov	 DWORD PTR [edx], eax
  0000d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00014	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1631 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1632 :         while (!_Trynode->_Isnil) {

  00017	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001b	75 36		 jne	 SHORT $LN18@Find_lower
  0001d	53		 push	 ebx
  0001e	56		 push	 esi
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0001f	8b 75 0c	 mov	 esi, DWORD PTR __Keyval$[ebp]
  00022	8a 1e		 mov	 bl, BYTE PTR [esi]
$LL2@Find_lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1633 :             _Result._Location._Parent = _Trynode;

  00024	89 02		 mov	 DWORD PTR [edx], eax
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00026	38 58 0e	 cmp	 BYTE PTR [eax+14], bl
  00029	72 18		 jb	 SHORT $LN12@Find_lower
  0002b	75 0a		 jne	 SHORT $LN4@Find_lower
  0002d	66 8b 48 0f	 mov	 cx, WORD PTR [eax+15]
  00031	66 3b 4e 01	 cmp	 cx, WORD PTR [esi+1]
  00035	72 0c		 jb	 SHORT $LN12@Find_lower
$LN4@Find_lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1639 :                 _Result._Bound           = _Trynode;

  00037	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1640 :                 _Trynode                 = _Trynode->_Left;

  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 05		 jmp	 SHORT $LN5@Find_lower
$LN12@Find_lower:

; 1634 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {
; 1635 :                 _Result._Location._Child = _Tree_child::_Right;
; 1636 :                 _Trynode                 = _Trynode->_Right;

  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00046	33 c9		 xor	 ecx, ecx
$LN5@Find_lower:

; 1631 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1632 :         while (!_Trynode->_Isnil) {

  00048	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004f	74 d3		 je	 SHORT $LL2@Find_lower
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
$LN18@Find_lower:

; 1641 :             }
; 1642 :         }
; 1643 : 
; 1644 :         return _Result;
; 1645 :     }

  00053	8b c2		 mov	 eax, edx
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Lower_bound_duplicate<SItemPos>, COMDAT
; _this$dead$ = ecx

; 1623 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Bound$[ebp]
  00006	53		 push	 ebx
  00007	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000b	75 1d		 jne	 SHORT $LN3@Lower_boun
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	3a 51 0e	 cmp	 dl, BYTE PTR [ecx+14]
  00015	72 13		 jb	 SHORT $LN3@Lower_boun
  00017	75 0a		 jne	 SHORT $LN12@Lower_boun
  00019	66 8b 40 01	 mov	 ax, WORD PTR [eax+1]
  0001d	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  00021	72 07		 jb	 SHORT $LN3@Lower_boun
$LN12@Lower_boun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00023	b0 01		 mov	 al, 1
  00025	5b		 pop	 ebx

; 1625 :     }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN3@Lower_boun:

; 1624 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0002a	32 c0		 xor	 al, al
  0002c	5b		 pop	 ebx

; 1625 :     }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Lower_bound_duplicate<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 775  :     return _Old_val;
; 776  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 383  :     }

  0000b	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 376  :     }

  0000b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z PROC ; std::addressof<std::pair<SItemPos const ,SShopItemTable> >, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<SItemPos const ,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SShopItemTable> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1099 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1100 :     using _Ty = typename _Alloc::value_type;
; 1101 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1102 :         for (; _First != _Last; ++_First) {
; 1103 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1104 :         }
; 1105 :     }
; 1106 : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > const >, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >, COMDAT

; 1660 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1661 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1662 :         return _Last - _First; // assume the iterator will do debug checking
; 1663 :     } else {
; 1664 :         _STD _Adl_verify_range(_First, _Last);
; 1665 :         auto _UFirst             = _STD _Get_unwrapped(_First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1660 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00009	57		 push	 edi

; 1666 :         const auto _ULast        = _STD _Get_unwrapped(_Last);
; 1667 :         _Iter_diff_t<_InIt> _Off = 0;

  0000a	33 ff		 xor	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  0000c	3b c1		 cmp	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000e	74 43		 je	 SHORT $LN33@distance
  00010	56		 push	 esi
$LL4@distance:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00011	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1669 :             ++_Off;

  00014	47		 inc	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00015	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00019	74 1d		 je	 SHORT $LN9@distance

; 51   :             _Nodeptr _Pnode;
; 52   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0001b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00022	75 10		 jne	 SHORT $LN34@distance
$LL7@distance:
  00024	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00027	75 0b		 jne	 SHORT $LN34@distance

; 53   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00029	8b c2		 mov	 eax, edx
  0002b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0002e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00032	74 f0		 je	 SHORT $LL7@distance
$LN34@distance:

; 54   :             }
; 55   : 
; 56   :             _Ptr = _Pnode; // ==> parent (head if end())

  00034	8b c2		 mov	 eax, edx

; 57   :         } else {

  00036	eb 16		 jmp	 SHORT $LN15@distance
$LN9@distance:

; 58   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00038	8b c2		 mov	 eax, edx

; 476  :         while (!_Pnode->_Left->_Isnil) {

  0003a	8b 30		 mov	 esi, DWORD PTR [eax]
  0003c	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00040	75 0c		 jne	 SHORT $LN15@distance
$LL14@distance:
  00042	8b 16		 mov	 edx, DWORD PTR [esi]

; 477  :             _Pnode = _Pnode->_Left;

  00044	8b c6		 mov	 eax, esi
  00046	8b f2		 mov	 esi, edx
  00048	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0004c	74 f4		 je	 SHORT $LL14@distance
$LN15@distance:

; 96   :         return _Ptr == _Right._Ptr;

  0004e	3b c1		 cmp	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 1668 :         for (; _UFirst != _ULast; ++_UFirst) {

  00050	75 bf		 jne	 SHORT $LL4@distance
  00052	5e		 pop	 esi
$LN33@distance:

; 1670 :         }
; 1671 : 
; 1672 :         return _Off;
; 1673 :     }
; 1674 : }

  00053	8b c7		 mov	 eax, edi
  00055	5f		 pop	 edi
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> &>, COMDAT
; __It$ = ecx

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;
; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);

  00000	8b c1		 mov	 eax, ecx

; 1387 :     }
; 1388 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1><std::less<SItemPos> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1><std::less<SItemPos> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1_Simple_reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Simple_reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Simple_reallocation_guard::~_Simple_reallocation_guard, COMDAT
; _this$ = ecx

; 637  :             if (_New_begin != nullptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 28		 je	 SHORT $LN8@Simple_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 49 08 0d	 imul	 ecx, DWORD PTR [ecx+8], 13

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00011	72 12		 jb	 SHORT $LN16@Simple_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00013	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00016	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00019	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00021	77 0d		 ja	 SHORT $LN15@Simple_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00023	8b c2		 mov	 eax, edx
$LN16@Simple_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN8@Simple_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 640  :         }

  0002f	c3		 ret	 0
$LN15@Simple_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 __invoke_watson
$LN20@Simple_rea:
  0003f	cc		 int	 3
??1_Simple_reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Simple_reallocation_guard::~_Simple_reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SShopItemTable> >::_Vector_val<std::_Simple_types<SShopItemTable> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SShopItemTable> >::_Vector_val<std::_Simple_types<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 13 3b b1 13	 mov	 eax, 330382099		; 13b13b13H

; 747  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal, COMDAT
; _this$ = ecx

; 2231 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2232 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal, COMDAT
; _this$ = ecx

; 2227 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2228 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array, COMDAT
; _this$ = ecx

; 2059 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2060 :         // orphan all iterators, discard old array, acquire new array
; 2061 :         auto& _Al         = _Getal();
; 2062 :         auto& _My_data    = _Mypair._Myval2;
; 2063 :         pointer& _Myfirst = _My_data._Myfirst;
; 2064 :         pointer& _Mylast  = _My_data._Mylast;
; 2065 :         pointer& _Myend   = _My_data._Myend;
; 2066 : 
; 2067 :         _My_data._Orphan_all();
; 2068 : 
; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 16		 mov	 edx, DWORD PTR [esi]
  00008	85 d2		 test	 edx, edx
  0000a	74 34		 je	 SHORT $LN8@Change_arr

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2071 :             _ASAN_VECTOR_REMOVE;
; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000f	2b c2		 sub	 eax, edx
  00011	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	6b c8 0d	 imul	 ecx, eax, 13

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 14		 jb	 SHORT $LN16@Change_arr
  00022	57		 push	 edi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00023	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00026	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00029	2b d7		 sub	 edx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002b	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0002e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00031	77 29		 ja	 SHORT $LN15@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00033	8b d7		 mov	 edx, edi
  00035	5f		 pop	 edi
$LN16@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00036	51		 push	 ecx
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003d	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2076 :         _Mylast  = _Newvec + _Newsize;

  00040	6b 45 0c 0d	 imul	 eax, DWORD PTR __Newsize$[ebp], 13
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00047	89 0e		 mov	 DWORD PTR [esi], ecx
  00049	03 c1		 add	 eax, ecx
  0004b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  0004e	6b 45 10 0d	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 13
  00052	03 c1		 add	 eax, ecx
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	5e		 pop	 esi

; 2079 :     }

  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	e8 00 00 00 00	 call	 __invoke_watson
$LN23@Change_arr:
  0006b	cc		 int	 3
?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z PROC ; std::allocator<SShopItemTable>::deallocate, COMDAT
; _this$dead$ = ecx

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	6b 4d 0c 0d	 imul	 ecx, DWORD PTR __Count$[ebp], 13
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00010	72 12		 jb	 SHORT $LN12@deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00012	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00015	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00018	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00020	77 10		 ja	 SHORT $LN11@deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00022	8b c2		 mov	 eax, edx
$LN12@deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8

; 986  :     }

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
$LN11@deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	e8 00 00 00 00	 call	 __invoke_watson
$LN15@deallocate:
  00041	cc		 int	 3
?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z ENDP ; std::allocator<SShopItemTable>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@USShopItemTable@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USShopItemTable@@@std@@QAE@XZ PROC	; std::allocator<SShopItemTable>::allocator<SShopItemTable>, COMDAT
; _this$ = ecx

; 974  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USShopItemTable@@@std@@QAE@XZ ENDP	; std::allocator<SShopItemTable>::allocator<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1539 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1540 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 49   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 50   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN4@operator

; 51   :             _Nodeptr _Pnode;
; 52   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN21@operator
$LL2@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN21@operator

; 53   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL2@operator
$LN21@operator:

; 54   :             }
; 55   : 
; 56   :             _Ptr = _Pnode; // ==> parent (head if end())
; 57   :         } else {
; 58   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 59   :         }
; 60   : 
; 61   :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 62   :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN4@operator:

; 476  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN10@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 477  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL9@operator
$LN10@operator:

; 54   :             }
; 55   : 
; 56   :             _Ptr = _Pnode; // ==> parent (head if end())
; 57   :         } else {
; 58   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 59   :         }
; 60   : 
; 61   :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 62   :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*, COMDAT
; _this$ = ecx

; 179  : #if _ITERATOR_DEBUG_LEVEL == 2
; 180  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 181  :         _STL_VERIFY(_Mycont, "cannot dereference value-initialized map/set iterator");
; 182  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 183  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 184  : 
; 185  :         return this->_Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0e	 add	 eax, 14			; 0000000eH

; 186  :     }

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1971 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1972 :     }

  00002	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1953 :     void _Alloc_sentinel_and_proxy() {

  00000	56		 push	 esi

; 345  :         const auto _Pnode = _Al.allocate(1);

  00001	6a 20		 push	 32			; 00000020H

; 1953 :     void _Alloc_sentinel_and_proxy() {

  00003	8b f1		 mov	 esi, ecx

; 345  :         const auto _Pnode = _Al.allocate(1);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000d	89 00		 mov	 DWORD PTR [eax], eax

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00012	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 349  :         _Pnode->_Color = _Black;

  00015	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1954 :         const auto _Scary = _Get_scary();
; 1955 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1956 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1957 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	5e		 pop	 esi

; 1958 :         _Proxy._Release();
; 1959 :     }

  0001e	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1309 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1310 :         const auto _Begin = _Unchecked_begin();
; 1311 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi

; 96   :         return _Ptr == _Right._Ptr;

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 1309 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {

  0000d	57		 push	 edi

; 1161 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  0000e	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 96   :         return _Ptr == _Right._Ptr;

  00010	3b 37		 cmp	 esi, DWORD PTR [edi]

; 1310 :         const auto _Begin = _Unchecked_begin();
; 1311 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00012	75 28		 jne	 SHORT $LN71@Erase_unch
  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	74 22		 je	 SHORT $LN71@Erase_unch

; 1374 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  0001a	ff 77 04	 push	 DWORD PTR [edi+4]
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1375 :         _Head->_Parent  = _Head;

  00023	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 1376 :         _Head->_Left    = _Head;

  00026	89 3f		 mov	 DWORD PTR [edi], edi

; 1377 :         _Head->_Right   = _Head;

  00028	89 7f 08	 mov	 DWORD PTR [edi+8], edi

; 1312 :             // erase all
; 1313 :             clear();
; 1314 :             return _Last._Ptr;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	5f		 pop	 edi

; 1319 :             _Erase_unchecked(_First++);
; 1320 :         }
; 1321 : 
; 1322 :         return _Last._Ptr;
; 1323 :     }

  0002f	5e		 pop	 esi

; 1378 :         _Scary->_Mysize = 0;

  00030	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1319 :             _Erase_unchecked(_First++);
; 1320 :         }
; 1321 : 
; 1322 :         return _Last._Ptr;
; 1323 :     }

  00037	5b		 pop	 ebx
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN71@Erase_unch:

; 96   :         return _Ptr == _Right._Ptr;

  0003c	3b f0		 cmp	 esi, eax

; 1315 :         }
; 1316 : 
; 1317 :         // partial erase, one at a time
; 1318 :         while (_First != _Last) {

  0003e	74 25		 je	 SHORT $LN1@Erase_unch
$LL2@Erase_unch:

; 66   :         ++*this;

  00040	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1303 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00048	56		 push	 esi
  00049	8b cb		 mov	 ecx, ebx
  0004b	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00050	6a 20		 push	 32			; 00000020H
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  00058	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0005b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 96   :         return _Ptr == _Right._Ptr;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00061	3b f0		 cmp	 esi, eax

; 1315 :         }
; 1316 : 
; 1317 :         // partial erase, one at a time
; 1318 :         while (_First != _Last) {

  00063	75 db		 jne	 SHORT $LL2@Erase_unch
$LN1@Erase_unch:
  00065	5f		 pop	 edi

; 1319 :             _Erase_unchecked(_First++);
; 1320 :         }
; 1321 : 
; 1322 :         return _Last._Ptr;
; 1323 :     }

  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z PROC	; std::less<SItemPos>::operator(), COMDAT
; _this$dead$ = ecx

; 2379 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2379 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

  00009	53		 push	 ebx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0000a	8a 10		 mov	 dl, BYTE PTR [eax]
  0000c	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0000e	72 13		 jb	 SHORT $LN6@operator
  00010	75 0a		 jne	 SHORT $LN5@operator
  00012	66 8b 40 01	 mov	 ax, WORD PTR [eax+1]
  00016	66 3b 41 01	 cmp	 ax, WORD PTR [ecx+1]
  0001a	72 07		 jb	 SHORT $LN6@operator
$LN5@operator:
  0001c	32 c0		 xor	 al, al
  0001e	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2381 :     }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
$LN6@operator:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00023	b0 01		 mov	 al, 1
  00025	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2381 :     }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z ENDP	; std::less<SItemPos>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > ><std::pair<SItemPos,SShopItemTable> >, COMDAT
; _this$ = ecx

; 829  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00036	6a 20		 push	 32			; 00000020H
  00038	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0003f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00044	8b 55 10	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00047	8b f0		 mov	 esi, eax
  00049	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0004c	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0004f	66 8b 0a	 mov	 cx, WORD PTR [edx]
  00052	66 89 4e 0e	 mov	 WORD PTR [esi+14], cx
  00056	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  00059	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  0005c	f3 0f 7e 42 03	 movq	 xmm0, QWORD PTR [edx+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 831  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00061	8b 4d 0c	 mov	 ecx, DWORD PTR __Myhead$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00064	66 0f d6 46 11	 movq	 QWORD PTR [esi+17], xmm0
  00069	8b 42 0b	 mov	 eax, DWORD PTR [edx+11]
  0006c	89 46 19	 mov	 DWORD PTR [esi+25], eax
  0006f	8a 42 0f	 mov	 al, BYTE PTR [edx+15]
  00072	88 46 1d	 mov	 BYTE PTR [esi+29], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 831  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00075	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00078	89 08		 mov	 DWORD PTR [eax], ecx

; 832  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0007a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 833  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00080	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00083	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 834  :         this->_Ptr->_Color = _Red;

  00086	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00089	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 835  :         this->_Ptr->_Isnil = false;

  0008d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00090	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 836  :     }

  00094	8b c7		 mov	 eax, edi
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > ><std::pair<SItemPos,SShopItemTable> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,bool,0>, COMDAT
; _this$ = ecx

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 275  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool,0>, COMDAT
; _this$ = ecx

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 275  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > > >, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z PROC ; std::move<SShopItemTable &>, COMDAT
; __Arg$ = ecx

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1514 : }

  00002	c3		 ret	 0
??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ENDP ; std::move<SShopItemTable &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z PROC ; std::_Move_backward_unchecked<SShopItemTable *,SShopItemTable *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5182 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5191 :         }
; 5192 :     }
; 5193 : 
; 5194 :     while (_First != _Last) {
; 5195 :         *--_Dest = _STD move(*--_Last);
; 5196 :     }
; 5197 : 
; 5198 :     return _Dest;
; 5199 : }

  00003	5d		 pop	 ebp

; 5183 :     // move [_First, _Last) backwards to [..., _Dest)
; 5184 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 5185 :     if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 5186 : #if _HAS_CXX20
; 5187 :         if (!_STD is_constant_evaluated())
; 5188 : #endif // _HAS_CXX20
; 5189 :         {
; 5190 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

  00004	e9 00 00 00 00	 jmp	 ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ENDP ; std::_Move_backward_unchecked<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
;	COMDAT ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z
_TEXT	SEGMENT
tv424 = -12						; size = 4
__Max_sequence_non_leaf$1$ = -8				; size = 4
__Top$1$ = -4						; size = 4
__Bottom$ = 8						; size = 4
tv420 = 11						; size = 1
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z PROC ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 58   :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 59   :     // percolate _Hole to _Bottom, then push _Val
; 60   :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 61   : 
; 62   :     using _Diff      = _Iter_diff_t<_RanIt>;
; 63   :     const _Diff _Top = _Hole;
; 64   :     _Diff _Idx       = _Hole;
; 65   : 
; 66   :     // Check whether _Idx can have a child before calculating that child's index, since
; 67   :     // calculating the child's index can trigger integer overflows
; 68   :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Bottom$[ebp]
  0000c	56		 push	 esi
  0000d	8b f2		 mov	 esi, edx
  0000f	57		 push	 edi
  00010	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00013	89 75 fc	 mov	 DWORD PTR __Top$1$[ebp], esi
  00016	89 45 f4	 mov	 DWORD PTR tv424[ebp], eax
  00019	8b fe		 mov	 edi, esi
  0001b	d1 f8		 sar	 eax, 1
  0001d	89 45 f8	 mov	 DWORD PTR __Max_sequence_non_leaf$1$[ebp], eax

; 69   :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  00020	3b f0		 cmp	 esi, eax
  00022	7d 43		 jge	 SHORT $LN3@Pop_heap_h
$LL2@Pop_heap_h:

; 70   :         _Idx = 2 * _Idx + 2;

  00024	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]

; 71   :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00027	6b ca 0d	 imul	 ecx, edx, 13

; 72   :             --_Idx;
; 73   :         }
; 74   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0002a	0f b6 44 19 26	 movzx	 eax, BYTE PTR [ecx+ebx+38]
  0002f	3a 44 19 19	 cmp	 al, BYTE PTR [ecx+ebx+25]
  00033	1b c0		 sbb	 eax, eax
  00035	6b ce 0d	 imul	 ecx, esi, 13
  00038	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0003b	03 fa		 add	 edi, edx
  0003d	6b d7 0d	 imul	 edx, edi, 13

; 75   :         _Hole             = _Idx;

  00040	8b f7		 mov	 esi, edi
  00042	f3 0f 7e 04 1a	 movq	 xmm0, QWORD PTR [edx+ebx]
  00047	66 0f d6 04 19	 movq	 QWORD PTR [ecx+ebx], xmm0
  0004c	8b 44 1a 08	 mov	 eax, DWORD PTR [edx+ebx+8]
  00050	89 44 19 08	 mov	 DWORD PTR [ecx+ebx+8], eax
  00054	0f b6 44 1a 0c	 movzx	 eax, BYTE PTR [edx+ebx+12]
  00059	88 44 19 0c	 mov	 BYTE PTR [ecx+ebx+12], al
  0005d	8b 45 f8	 mov	 eax, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  00060	3b f8		 cmp	 edi, eax
  00062	7c c0		 jl	 SHORT $LL2@Pop_heap_h
  00064	8b 4d 08	 mov	 ecx, DWORD PTR __Bottom$[ebp]
$LN3@Pop_heap_h:

; 76   :     }
; 77   : 
; 78   :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00067	3b f8		 cmp	 edi, eax
  00069	75 29		 jne	 SHORT $LN5@Pop_heap_h
  0006b	f6 c1 01	 test	 cl, 1
  0006e	75 24		 jne	 SHORT $LN5@Pop_heap_h

; 79   :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  00070	6b c9 0d	 imul	 ecx, ecx, 13
  00073	6b d6 0d	 imul	 edx, esi, 13

; 80   :         _Hole             = _Bottom - 1;

  00076	8b 75 f4	 mov	 esi, DWORD PTR tv424[ebp]
  00079	f3 0f 7e 44 19
	f3		 movq	 xmm0, QWORD PTR [ecx+ebx-13]
  0007f	66 0f d6 04 1a	 movq	 QWORD PTR [edx+ebx], xmm0
  00084	8b 44 19 fb	 mov	 eax, DWORD PTR [ecx+ebx-5]
  00088	89 44 1a 08	 mov	 DWORD PTR [edx+ebx+8], eax
  0008c	8a 44 19 ff	 mov	 al, BYTE PTR [ecx+ebx-1]
  00090	88 44 1a 0c	 mov	 BYTE PTR [edx+ebx+12], al
$LN5@Pop_heap_h:

; 26   :     for (_Diff _Idx                                                         = (_Hole - 1) >> 1; // shift for codegen

  00094	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00097	d1 f8		 sar	 eax, 1

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  00099	39 75 fc	 cmp	 DWORD PTR __Top$1$[ebp], esi
  0009c	7d 3a		 jge	 SHORT $LN24@Pop_heap_h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  000a1	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  000a4	88 55 0b	 mov	 BYTE PTR tv420[ebp], dl
$LL12@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000a7	6b f8 0d	 imul	 edi, eax, 13
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000aa	03 fb		 add	 edi, ebx
  000ac	38 57 0c	 cmp	 BYTE PTR [edi+12], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000af	73 27		 jae	 SHORT $LN24@Pop_heap_h

; 28   :         // move _Hole up to parent
; 29   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  000b1	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  000b5	6b d6 0d	 imul	 edx, esi, 13

; 30   :         _Hole             = _Idx;

  000b8	8b f0		 mov	 esi, eax
  000ba	48		 dec	 eax
  000bb	d1 f8		 sar	 eax, 1
  000bd	66 0f d6 04 1a	 movq	 QWORD PTR [edx+ebx], xmm0
  000c2	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000c5	89 4c 1a 08	 mov	 DWORD PTR [edx+ebx+8], ecx
  000c9	8a 4f 0c	 mov	 cl, BYTE PTR [edi+12]
  000cc	88 4c 1a 0c	 mov	 BYTE PTR [edx+ebx+12], cl
  000d0	8a 55 0b	 mov	 dl, BYTE PTR tv420[ebp]
  000d3	39 75 fc	 cmp	 DWORD PTR __Top$1$[ebp], esi
  000d6	7c cf		 jl	 SHORT $LL12@Pop_heap_h
$LN24@Pop_heap_h:

; 31   :     }
; 32   : 
; 33   :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  000d8	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  000db	6b ce 0d	 imul	 ecx, esi, 13
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  000e4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e7	66 0f d6 04 19	 movq	 QWORD PTR [ecx+ebx], xmm0
  000ec	89 44 19 08	 mov	 DWORD PTR [ecx+ebx+8], eax
  000f0	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  000f3	88 44 19 0c	 mov	 BYTE PTR [ecx+ebx+12], al
  000f7	5b		 pop	 ebx

; 81   :     }
; 82   : 
; 83   :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 84   : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ENDP ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
;	COMDAT ??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1 = -16						; size = 13
__Pred$ = 8						; size = 1
??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Pop_heap_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 98   : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :     // pop *_First to *(_Last - 1) and reheap
; 100  :     if (2 <= _Last - _First) {

  00003	8b c2		 mov	 eax, edx
  00005	83 ec 10	 sub	 esp, 16			; 00000010H
  00008	2b c1		 sub	 eax, ecx
  0000a	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  00010	83 f8 02	 cmp	 eax, 2
  00013	7c 49		 jl	 SHORT $LN2@Pop_heap_u

; 101  :         --_Last;
; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00015	f3 0f 7e 42 f3	 movq	 xmm0, QWORD PTR [edx-13]
  0001a	83 ea 0d	 sub	 edx, 13			; 0000000dH

; 93   :     _STD _Pop_heap_hole_by_index(

  0001d	ff 75 08	 push	 DWORD PTR __Pred$[ebp]

; 101  :         --_Last;
; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00020	66 0f d6 45 f0	 movq	 QWORD PTR __Val$1[ebp], xmm0

; 91   :     *_Dest      = _STD move(*_First);

  00025	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]

; 101  :         --_Last;
; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00029	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002c	89 45 f8	 mov	 DWORD PTR __Val$1[ebp+8], eax
  0002f	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]

; 91   :     *_Dest      = _STD move(*_First);

  00033	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0

; 101  :         --_Last;
; 102  :         _Iter_value_t<_RanIt> _Val(_STD move(*_Last));

  00037	88 45 fc	 mov	 BYTE PTR __Val$1[ebp+12], al

; 91   :     *_Dest      = _STD move(*_First);

  0003a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00040	0f b6 41 0c	 movzx	 eax, BYTE PTR [ecx+12]
  00044	88 42 0c	 mov	 BYTE PTR [edx+12], al

; 92   :     using _Diff = _Iter_diff_t<_RanIt>;
; 93   :     _STD _Pop_heap_hole_by_index(

  00047	8d 45 f0	 lea	 eax, DWORD PTR __Val$1[ebp]
  0004a	2b d1		 sub	 edx, ecx
  0004c	50		 push	 eax
  0004d	69 c2 c5 4e ec
	c4		 imul	 eax, edx, -991146299
  00053	33 d2		 xor	 edx, edx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Pop_heap_u:

; 103  :         _STD _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 104  :     }
; 105  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Pop_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z PROC ; std::_Prev_iter<SShopItemTable *>, COMDAT
; __First$ = ecx

; 1692 :     return --_First;

  00000	8d 41 f3	 lea	 eax, DWORD PTR [ecx-13]

; 1693 : }

  00003	c3		 ret	 0
??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ENDP ; std::_Prev_iter<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z
_TEXT	SEGMENT
tv186 = -12						; size = 4
__First$1$ = -8						; size = 4
__Mid$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z PROC ; std::_Guess_median_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 8281 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f2		 mov	 esi, edx
  00009	8b d1		 mov	 edx, ecx

; 8282 :     // sort median element to middle
; 8283 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 8284 :     const _Diff _Count = _Last - _First;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	8b c1		 mov	 eax, ecx
  00010	2b c2		 sub	 eax, edx
  00012	89 75 fc	 mov	 DWORD PTR __Mid$1$[ebp], esi
  00015	69 c0 c5 4e ec
	c4		 imul	 eax, eax, -991146299
  0001b	89 55 f8	 mov	 DWORD PTR __First$1$[ebp], edx

; 8285 :     if (40 < _Count) { // Tukey's ninther

  0001e	83 f8 28	 cmp	 eax, 40			; 00000028H
  00021	7e 63		 jle	 SHORT $LN2@Guess_medi

; 8286 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller
; 8287 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 8288 :         _STD _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00023	8b 75 0c	 mov	 esi, DWORD PTR __Pred$[ebp]
  00026	40		 inc	 eax
  00027	53		 push	 ebx
  00028	c1 f8 03	 sar	 eax, 3
  0002b	57		 push	 edi
  0002c	6b f8 0d	 imul	 edi, eax, 13
  0002f	6b d8 1a	 imul	 ebx, eax, 26
  00032	56		 push	 esi
  00033	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  00036	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00039	89 4d f4	 mov	 DWORD PTR tv186[ebp], ecx
  0003c	8b d1		 mov	 edx, ecx
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR __First$1$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8289 :         _STD _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00047	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1$[ebp]
  0004a	8b ca		 mov	 ecx, edx
  0004c	56		 push	 esi
  0004d	2b cf		 sub	 ecx, edi
  0004f	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8290 :         _STD _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  00058	8b 45 08	 mov	 eax, DWORD PTR __Last$[ebp]
  0005b	8b f0		 mov	 esi, eax
  0005d	2b f7		 sub	 esi, edi
  0005f	8b 7d 0c	 mov	 edi, DWORD PTR __Pred$[ebp]
  00062	57		 push	 edi
  00063	50		 push	 eax
  00064	2b c3		 sub	 eax, ebx
  00066	8b d6		 mov	 edx, esi
  00068	8b c8		 mov	 ecx, eax
  0006a	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 8291 :         _STD _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR tv186[ebp]
  00075	57		 push	 edi
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  0007c	83 c4 20	 add	 esp, 32			; 00000020H
  0007f	5f		 pop	 edi
  00080	5b		 pop	 ebx
  00081	5e		 pop	 esi

; 8294 :     }
; 8295 : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN2@Guess_medi:

; 8292 :     } else {
; 8293 :         _STD _Med3_unchecked(_First, _Mid, _Last, _Pred);

  00086	ff 75 0c	 push	 DWORD PTR __Pred$[ebp]
  00089	8b d6		 mov	 edx, esi
  0008b	51		 push	 ecx
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR __First$1$[ebp]
  0008f	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  00094	83 c4 08	 add	 esp, 8
  00097	5e		 pop	 esi

; 8294 :     }
; 8295 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ENDP ; std::_Guess_median_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z
_TEXT	SEGMENT
??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z PROC ; std::_Next_iter<SShopItemTable *>, COMDAT
; __First$ = ecx

; 1678 :     return ++_First;

  00000	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]

; 1679 : }

  00003	c3		 ret	 0
??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ENDP ; std::_Next_iter<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z
_TEXT	SEGMENT
??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z PROC ; std::swap<SShopItemTable,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 139  :     _Ty _Tmp = _STD move(_Left);
; 140  :     _Left    = _STD move(_Right);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	f3 0f 7e 09	 movq	 xmm1, QWORD PTR [ecx]
  00008	53		 push	 ebx
  00009	8a 59 0c	 mov	 bl, BYTE PTR [ecx+12]
  0000c	56		 push	 esi
  0000d	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00010	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00014	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00017	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0001a	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  0001d	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 141  :     _Right   = _STD move(_Tmp);

  00020	66 0f d6 0a	 movq	 QWORD PTR [edx], xmm1
  00024	89 72 08	 mov	 DWORD PTR [edx+8], esi
  00027	5e		 pop	 esi
  00028	88 5a 0c	 mov	 BYTE PTR [edx+12], bl
  0002b	5b		 pop	 ebx

; 142  : }

  0002c	c3		 ret	 0
??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z ENDP ; std::swap<SShopItemTable,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z PROC ; std::pair<SShopItemTable *,SShopItemTable *>::pair<SShopItemTable *,SShopItemTable *><SShopItemTable * &,SShopItemTable * &,0>, COMDAT
; _this$ = ecx

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 275  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z ENDP ; std::pair<SShopItemTable *,SShopItemTable *>::pair<SShopItemTable *,SShopItemTable *><SShopItemTable * &,SShopItemTable * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@USShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@USShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z PROC ; std::_Unfancy<SShopItemTable>, COMDAT
; __Ptr$ = ecx

; 69   :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 70   : }

  00002	c3		 ret	 0
??$_Unfancy@USShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ENDP ; std::_Unfancy<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z PROC ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4762 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4763 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4764 :     const auto _First_ptr    = _STD _To_address(_First);
; 4765 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4766 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);
; 4767 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4768 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);

  00003	2b d1		 sub	 edx, ecx

; 4770 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00005	51		 push	 ecx
  00006	52		 push	 edx
  00007	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<SShopItemTable *>
  0000f	83 c4 08	 add	 esp, 8

; 4771 : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ENDP ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z
_TEXT	SEGMENT
??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z PROC ; std::_To_address<SShopItemTable *>, COMDAT
; __Val$ = ecx

; 4616 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4617 :     return _STD to_address(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 4618 : }

  00002	c3		 ret	 0
??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z ENDP ; std::_To_address<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Emplace_back<SShopItemTable>, COMDAT
; _this$ = ecx

; 1843 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1843 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00006	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00007	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000a	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0000e	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00018	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  0001b	88 46 0c	 mov	 BYTE PTR [esi+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

  0001e	83 41 04 0d	 add	 DWORD PTR [ecx+4], 13	; 0000000dH
  00022	5e		 pop	 esi

; 1846 :     }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Emplace_back<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z
_TEXT	SEGMENT
??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z PROC ; std::_Construct_in_place<SShopItemTable,SShopItemTable const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00011	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 477  :     }
; 478  : }

  00014	c3		 ret	 0
??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z ENDP ; std::_Construct_in_place<SShopItemTable,SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00006	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  0000a	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  0000e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00011	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00014	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00017	88 42 0c	 mov	 BYTE PTR [edx+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 734  :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::destroy<std::pair<SItemPos const ,SShopItemTable> >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$dead$ = edx

; 738  : #if _HAS_CXX20
; 739  :         _STD destroy_at(_Ptr);
; 740  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 741  :         _Ptr->~_Uty();
; 742  : #endif // ^^^ !_HAS_CXX20 ^^^
; 743  :     }

  00000	c2 00 00	 ret	 0
??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::destroy<std::pair<SItemPos const ,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

  00000	c2 00 00	 ret	 0
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z PROC ; std::forward<std::less<SItemPos> const &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z ENDP ; std::forward<std::less<SItemPos> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; __Al$dead$ = ecx

; 344  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 345  :         const auto _Pnode = _Al.allocate(1);

  00000	6a 20		 push	 32			; 00000020H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000a	89 00		 mov	 DWORD PTR [eax], eax

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0000f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 349  :         _Pnode->_Color = _Black;

  00012	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 350  :         _Pnode->_Isnil = true;
; 351  :         return _Pnode;
; 352  :     }

  00018	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Release, COMDAT
; _this$ = ecx

; 1849 :         _First = _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	89 01		 mov	 DWORD PTR [ecx], eax

; 1850 :         return _Last;
; 1851 :     }

  00005	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::~_Uninitialized_backout_al<std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 1839 :         _STD _Destroy_range(_First, _Last, _Al);
; 1840 :     }

  00000	c2 00 00	 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::~_Uninitialized_backout_al<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Uninitialized_backout_al<std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Al_$[ebp]
  0000e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00011	8b c1		 mov	 eax, ecx
  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Uninitialized_backout_al<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1164 :     }

  0000a	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1172 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN17@Tree_temp_

; 289  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 20		 push	 32			; 00000020H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN17@Tree_temp_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 848  :     }

  00012	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map_impl@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z
_TEXT	SEGMENT
?_Extract@?$_In_place_key_extract_map_impl@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z PROC ; std::_In_place_key_extract_map_impl<SItemPos,std::pair<SItemPos,SShopItemTable> >::_Extract, COMDAT
; __Val$ = ecx

; 2175 :         return _Val.first;

  00000	8b c1		 mov	 eax, ecx

; 2176 :     }

  00002	c3		 ret	 0
?_Extract@?$_In_place_key_extract_map_impl@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z ENDP ; std::_In_place_key_extract_map_impl<SItemPos,std::pair<SItemPos,SShopItemTable> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1543 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1544 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1539 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1540 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 621  :             if (_New_begin != nullptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 28		 je	 SHORT $LN8@Reallocati
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 49 08 0d	 imul	 ecx, DWORD PTR [ecx+8], 13

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00011	72 12		 jb	 SHORT $LN16@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00013	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00016	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00019	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00021	77 0d		 ja	 SHORT $LN15@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00023	8b c2		 mov	 eax, edx
$LN16@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN8@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 625  :         }

  0002f	c3		 ret	 0
$LN15@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 __invoke_watson
$LN20@Reallocati:
  0003f	cc		 int	 3
??1_Reallocation_guard@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 2223 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2006 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00008	b9 13 3b b1 13	 mov	 ecx, 330382099		; 13b13b13H
  0000d	57		 push	 edi

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000e	69 f8 c5 4e ec
	c4		 imul	 edi, eax, -991146299

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00014	8b d7		 mov	 edx, edi
  00016	d1 ea		 shr	 edx, 1
  00018	2b ca		 sub	 ecx, edx
  0001a	3b f9		 cmp	 edi, ecx
  0001c	76 0a		 jbe	 SHORT $LN2@Calculate_

; 2012 :             return _Max; // geometric growth would overflow

  0001e	b8 13 3b b1 13	 mov	 eax, 330382099		; 13b13b13H
  00023	5f		 pop	 edi

; 2018 :             return _Newsize; // geometric growth would be insufficient
; 2019 :         }
; 2020 : 
; 2021 :         return _Geometric; // geometric growth is sufficient
; 2022 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN2@Calculate_:

; 2013 :         }
; 2014 : 
; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00028	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]

; 2016 : 
; 2017 :         if (_Geometric < _Newsize) {

  0002b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0002e	5f		 pop	 edi
  0002f	0f 42 45 08	 cmovb	 eax, DWORD PTR __Newsize$[ebp]

; 2018 :             return _Newsize; // geometric growth would be insufficient
; 2019 :         }
; 2020 : 
; 2021 :         return _Geometric; // geometric growth is sufficient
; 2022 :     }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z PROC ; std::allocator<SShopItemTable>::allocate, COMDAT
; _this$dead$ = ecx

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  :         if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 13 3b b1 13	 cmp	 eax, 330382099		; 13b13b13H
  0000b	77 2b		 ja	 SHORT $LN19@allocate

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0000d	6b c0 0d	 imul	 eax, eax, 13

; 227  :     if (_Bytes == 0) {

  00010	85 c0		 test	 eax, eax
  00012	75 04		 jne	 SHORT $LN8@allocate

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN8@allocate:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	50		 push	 eax
  00019	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001e	72 0c		 jb	 SHORT $LN10@allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00020	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00025	83 c4 04	 add	 esp, 4
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN10@allocate:

; 136  :         return ::operator new(_Bytes);

  0002c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00031	83 c4 04	 add	 esp, 4
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN19@allocate:

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00038	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN16@allocate:
  0003d	cc		 int	 3
?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z ENDP ; std::allocator<SShopItemTable>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ PROC ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1543 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1544 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ ENDP ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 95   :     _NODISCARD bool operator==(const _Tree_unchecked_const_iterator& _Right) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   :         return _Ptr == _Right._Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 97   :     }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 64   :     _Tree_unchecked_const_iterator operator++(int) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 65   :         _Tree_unchecked_const_iterator _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 66   :         ++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 67   :         return _Tmp;

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 68   :     }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node, COMDAT
; _this$ = ecx

; 669  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 670  :         ++_Mysize;
; 671  :         const auto _Head  = _Myhead;
; 672  :         _Newnode->_Parent = _Loc._Parent;

  00004	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	ff 43 04	 inc	 DWORD PTR [ebx+4]
  00013	89 45 fc	 mov	 DWORD PTR __Head$1$[ebp], eax
  00016	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 673  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00019	3b d0		 cmp	 edx, eax
  0001b	75 16		 jne	 SHORT $LN5@Insert_nod

; 674  :             _Head->_Left     = _Newnode;

  0001d	89 38		 mov	 DWORD PTR [eax], edi

; 675  :             _Head->_Parent   = _Newnode;

  0001f	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 676  :             _Head->_Right    = _Newnode;

  00022	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 735  :         return _Newnode;
; 736  :     }

  00025	8b c7		 mov	 eax, edi
  00027	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0002b	5f		 pop	 edi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 677  :             _Newnode->_Color = _Black; // the root is black
; 678  :             return _Newnode;
; 679  :         }
; 680  : 
; 681  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 682  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00033	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00037	75 0d		 jne	 SHORT $LN6@Insert_nod

; 683  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 684  :             _Loc._Parent->_Right = _Newnode;

  00039	89 7a 08	 mov	 DWORD PTR [edx+8], edi

; 685  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003c	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003f	75 0d		 jne	 SHORT $LN9@Insert_nod

; 686  :                 _Head->_Right = _Newnode;

  00041	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 687  :             }
; 688  :         } else { // add to left of _Loc._Parent

  00044	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 689  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 690  :             _Loc._Parent->_Left = _Newnode;

  00046	89 3a		 mov	 DWORD PTR [edx], edi

; 691  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00048	3b 10		 cmp	 edx, DWORD PTR [eax]
  0004a	75 02		 jne	 SHORT $LN9@Insert_nod

; 692  :                 _Head->_Left = _Newnode;

  0004c	89 38		 mov	 DWORD PTR [eax], edi
$LN9@Insert_nod:

; 693  :             }
; 694  :         }
; 695  : 
; 696  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00051	8b c7		 mov	 eax, edi
  00053	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00057	0f 85 7d 01 00
	00		 jne	 $LN3@Insert_nod
  0005d	56		 push	 esi
  0005e	66 90		 npad	 2
$LL4@Insert_nod:

; 697  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00063	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 85 aa 00 00
	00		 jne	 $LN10@Insert_nod

; 698  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 699  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00073	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00077	0f 84 a3 00 00
	00		 je	 $LN82@Insert_nod

; 700  :                     _Pnode->_Parent->_Color          = _Black;
; 701  :                     _Parent_sibling->_Color          = _Black;
; 702  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 703  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 704  :                 } else { // parent's sibling has red and black children
; 705  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0007d	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00080	3b c6		 cmp	 eax, esi
  00082	75 37		 jne	 SHORT $LN57@Insert_nod

; 485  :         _Wherenode->_Right = _Pnode->_Left;

  00084	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 706  :                         _Pnode = _Pnode->_Parent;

  00086	8b c2		 mov	 eax, edx

; 485  :         _Wherenode->_Right = _Pnode->_Left;

  00088	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 486  : 
; 487  :         if (!_Pnode->_Left->_Isnil) {

  0008b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00091	75 03		 jne	 SHORT $LN21@Insert_nod

; 488  :             _Pnode->_Left->_Parent = _Wherenode;

  00093	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN21@Insert_nod:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Parent = _Wherenode->_Parent;

  00096	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00099	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 492  : 
; 493  :         if (_Wherenode == _Myhead->_Parent) {

  0009c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0009e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000a1	75 05		 jne	 SHORT $LN22@Insert_nod

; 494  :             _Myhead->_Parent = _Pnode;

  000a3	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000a6	eb 0e		 jmp	 SHORT $LN25@Insert_nod
$LN22@Insert_nod:

; 495  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000a8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ab	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000ad	75 04		 jne	 SHORT $LN24@Insert_nod

; 496  :             _Wherenode->_Parent->_Left = _Pnode;

  000af	89 31		 mov	 DWORD PTR [ecx], esi

; 497  :         } else {

  000b1	eb 03		 jmp	 SHORT $LN25@Insert_nod
$LN24@Insert_nod:

; 498  :             _Wherenode->_Parent->_Right = _Pnode;

  000b3	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN25@Insert_nod:

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;

  000b6	89 06		 mov	 DWORD PTR [esi], eax

; 502  :         _Wherenode->_Parent = _Pnode;

  000b8	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN57@Insert_nod:

; 707  :                         _Lrotate(_Pnode);
; 708  :                     }
; 709  : 
; 710  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 711  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c8	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 712  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 506  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000d2	8b 32		 mov	 esi, DWORD PTR [edx]

; 507  :         _Wherenode->_Left = _Pnode->_Right;

  000d4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d7	89 0a		 mov	 DWORD PTR [edx], ecx

; 508  : 
; 509  :         if (!_Pnode->_Right->_Isnil) {

  000d9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dc	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e0	75 03		 jne	 SHORT $LN29@Insert_nod

; 510  :             _Pnode->_Right->_Parent = _Wherenode;

  000e2	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN29@Insert_nod:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Parent = _Wherenode->_Parent;

  000e5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e8	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 514  : 
; 515  :         if (_Wherenode == _Myhead->_Parent) {

  000eb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ed	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f0	75 0b		 jne	 SHORT $LN30@Insert_nod

; 516  :             _Myhead->_Parent = _Pnode;

  000f2	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  000f5	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 713  :                 }
; 714  :             } else { // fixup red-red in right subtree

  000f8	e9 cc 00 00 00	 jmp	 $LN81@Insert_nod
$LN30@Insert_nod:

; 517  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  000fd	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00100	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00103	75 0b		 jne	 SHORT $LN32@Insert_nod

; 518  :             _Wherenode->_Parent->_Right = _Pnode;

  00105	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  00108	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 713  :                 }
; 714  :             } else { // fixup red-red in right subtree

  0010b	e9 b9 00 00 00	 jmp	 $LN81@Insert_nod
$LN32@Insert_nod:

; 520  :             _Wherenode->_Parent->_Left = _Pnode;

  00110	89 31		 mov	 DWORD PTR [ecx], esi

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  00112	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 713  :                 }
; 714  :             } else { // fixup red-red in right subtree

  00115	e9 af 00 00 00	 jmp	 $LN81@Insert_nod
$LN10@Insert_nod:

; 715  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 716  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  0011a	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0011e	75 1d		 jne	 SHORT $LN15@Insert_nod
$LN82@Insert_nod:

; 693  :             }
; 694  :         }
; 695  : 
; 696  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00120	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
  00124	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0012e	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00132	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00135	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00138	e9 8f 00 00 00	 jmp	 $LN2@Insert_nod
$LN15@Insert_nod:

; 717  :                     _Pnode->_Parent->_Color          = _Black;
; 718  :                     _Parent_sibling->_Color          = _Black;
; 719  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 720  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 721  :                 } else { // parent's sibling has red and black children
; 722  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  0013d	8b 32		 mov	 esi, DWORD PTR [edx]
  0013f	3b c6		 cmp	 eax, esi
  00141	75 3a		 jne	 SHORT $LN42@Insert_nod

; 507  :         _Wherenode->_Left = _Pnode->_Right;

  00143	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 723  :                         _Pnode = _Pnode->_Parent;

  00146	8b c2		 mov	 eax, edx

; 507  :         _Wherenode->_Left = _Pnode->_Right;

  00148	89 08		 mov	 DWORD PTR [eax], ecx

; 508  : 
; 509  :         if (!_Pnode->_Right->_Isnil) {

  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00151	75 03		 jne	 SHORT $LN37@Insert_nod

; 510  :             _Pnode->_Right->_Parent = _Wherenode;

  00153	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN37@Insert_nod:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Parent = _Wherenode->_Parent;

  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 514  : 
; 515  :         if (_Wherenode == _Myhead->_Parent) {

  0015c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0015e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00161	75 05		 jne	 SHORT $LN38@Insert_nod

; 516  :             _Myhead->_Parent = _Pnode;

  00163	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00166	eb 0f		 jmp	 SHORT $LN41@Insert_nod
$LN38@Insert_nod:

; 517  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00168	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0016b	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0016e	75 05		 jne	 SHORT $LN40@Insert_nod

; 518  :             _Wherenode->_Parent->_Right = _Pnode;

  00170	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 519  :         } else {

  00173	eb 02		 jmp	 SHORT $LN41@Insert_nod
$LN40@Insert_nod:

; 520  :             _Wherenode->_Parent->_Left = _Pnode;

  00175	89 31		 mov	 DWORD PTR [ecx], esi
$LN41@Insert_nod:

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  00177	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 524  :         _Wherenode->_Parent = _Pnode;

  0017a	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN42@Insert_nod:

; 724  :                         _Rrotate(_Pnode);
; 725  :                     }
; 726  : 
; 727  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0017d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00180	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 728  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00184	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00187	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0018a	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 729  :                     _Lrotate(_Pnode->_Parent->_Parent);

  0018e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00191	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 484  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00194	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 485  :         _Wherenode->_Right = _Pnode->_Left;

  00197	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00199	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 486  : 
; 487  :         if (!_Pnode->_Left->_Isnil) {

  0019c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001a2	75 03		 jne	 SHORT $LN45@Insert_nod

; 488  :             _Pnode->_Left->_Parent = _Wherenode;

  001a4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN45@Insert_nod:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Parent = _Wherenode->_Parent;

  001a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001aa	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 492  : 
; 493  :         if (_Wherenode == _Myhead->_Parent) {

  001ad	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001af	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b2	75 05		 jne	 SHORT $LN46@Insert_nod

; 494  :             _Myhead->_Parent = _Pnode;

  001b4	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  001b7	eb 0e		 jmp	 SHORT $LN49@Insert_nod
$LN46@Insert_nod:

; 495  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001b9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001bc	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001be	75 04		 jne	 SHORT $LN48@Insert_nod

; 496  :             _Wherenode->_Parent->_Left = _Pnode;

  001c0	89 31		 mov	 DWORD PTR [ecx], esi

; 497  :         } else {

  001c2	eb 03		 jmp	 SHORT $LN49@Insert_nod
$LN48@Insert_nod:

; 498  :             _Wherenode->_Parent->_Right = _Pnode;

  001c4	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN49@Insert_nod:

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;

  001c7	89 16		 mov	 DWORD PTR [esi], edx
$LN81@Insert_nod:

; 693  :             }
; 694  :         }
; 695  : 
; 696  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001c9	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN2@Insert_nod:
  001cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001cf	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d3	0f 84 87 fe ff
	ff		 je	 $LL4@Insert_nod
  001d9	5e		 pop	 esi
$LN3@Insert_nod:

; 730  :                 }
; 731  :             }
; 732  :         }
; 733  : 
; 734  :         _Head->_Parent->_Color = _Black; // root is always black

  001da	8b 45 fc	 mov	 eax, DWORD PTR __Head$1$[ebp]
  001dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e0	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 735  :         return _Newnode;
; 736  :     }

  001e4	8b c7		 mov	 eax, edi
  001e6	5f		 pop	 edi
  001e7	5b		 pop	 ebx
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Min, COMDAT
; __Pnode$ = ecx

; 476  :         while (!_Pnode->_Left->_Isnil) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00006	75 0d		 jne	 SHORT $LN10@Min
$LL2@Min:
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 477  :             _Pnode = _Pnode->_Left;

  0000a	8b c2		 mov	 eax, edx
  0000c	8b d1		 mov	 edx, ecx
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	74 f4		 je	 SHORT $LL2@Min

; 481  :     }

  00014	c3		 ret	 0
$LN10@Min:

; 478  :         }
; 479  : 
; 480  :         return _Pnode;

  00015	8b c1		 mov	 eax, ecx

; 481  :     }

  00017	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::deallocate, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 289  :         ::operator delete(_Ptr, _Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8

; 715  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 716  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 717  :         if (_STD is_constant_evaluated()) {
; 718  :             _Al.deallocate(_Ptr, _Count);
; 719  :         } else
; 720  : #endif // _HAS_CXX20
; 721  :         {
; 722  :             (void) _Al;
; 723  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
; 724  :         }
; 725  :     }

  0000b	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1648 :         if (max_size() == _Get_scary()->_Mysize) {

  00000	81 79 04 ff ff
	ff 07		 cmp	 DWORD PTR [ecx+4], 134217727 ; 07ffffffH
  00007	0f 84 00 00 00
	00		 je	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error

; 1649 :             _Throw_tree_length_error();
; 1650 :         }
; 1651 :     }

  0000d	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Successor$ = -4					; size = 4
__Where$ = 8						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1299 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1300 :         const auto _Scary                    = _Get_scary();
; 1301 :         _Unchecked_const_iterator _Successor = _Where;

  00005	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 75 fc	 mov	 DWORD PTR __Successor$[ebp], esi

; 1302 :         ++_Successor; // save successor iterator for return

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Successor$[ebp]
  00011	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1303 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00016	56		 push	 esi
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0001e	6a 20		 push	 32			; 00000020H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1306 :         return _Successor._Ptr; // return successor nodeptr

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Successor$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00029	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 1306 :         return _Successor._Ptr; // return successor nodeptr

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1307 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1160 :     _Unchecked_iterator _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1161 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1162 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 1172 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN11@Tree_temp_

; 289  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 20		 push	 32			; 00000020H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN11@Tree_temp_:
  00012	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::construct<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00006	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00009	66 89 02	 mov	 WORD PTR [edx], ax
  0000c	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  00010	88 42 02	 mov	 BYTE PTR [edx+2], al
  00013	f3 0f 7e 41 03	 movq	 xmm0, QWORD PTR [ecx+3]
  00018	66 0f d6 42 03	 movq	 QWORD PTR [edx+3], xmm0
  0001d	8b 41 0b	 mov	 eax, DWORD PTR [ecx+11]
  00020	89 42 0b	 mov	 DWORD PTR [edx+11], eax
  00023	0f b6 41 0f	 movzx	 eax, BYTE PTR [ecx+15]
  00027	88 42 0f	 mov	 BYTE PTR [edx+15], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 734  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::construct<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z PROC ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5083 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5084 :     // implement copy_backward-like function as memmove
; 5085 :     const auto _First_ptr = _STD _To_address(_First);
; 5086 :     const auto _Last_ptr  = _STD _To_address(_Last);
; 5087 :     const auto _Dest_ptr  = _STD _To_address(_Dest);
; 5088 :     const auto _First_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 5089 :     const auto _Last_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 5090 :     const auto _Dest_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 5091 :     const auto _Count     = static_cast<size_t>(_Last_ch - _First_ch);
; 5092 :     const auto _Result    = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	2b d1		 sub	 edx, ecx
  00008	52		 push	 edx
  00009	51		 push	 ecx
  0000a	2b c2		 sub	 eax, edx
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _memmove
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5093 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 5094 :         return static_cast<_CtgIt2>(_Result);
; 5095 :     } else {
; 5096 :         return _Dest - static_cast<_Iter_diff_t<_CtgIt2>>(_Last_ptr - _First_ptr);
; 5097 :     }
; 5098 : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ENDP ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z PROC ; std::forward<SShopItemTable>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ENDP ; std::forward<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
;	COMDAT ??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z PROC ; std::_Push_heap_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 23   :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   :     // percolate _Hole to _Top or where _Val belongs
; 25   :     using _Diff = _Iter_diff_t<_RanIt>;
; 26   :     for (_Diff _Idx                                                         = (_Hole - 1) >> 1; // shift for codegen

  00003	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00006	d1 f8		 sar	 eax, 1
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  0000b	39 55 08	 cmp	 DWORD PTR __Top$[ebp], edx
  0000e	7d 38		 jge	 SHORT $LN12@Push_heap_
  00010	53		 push	 ebx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00011	8b 5d 0c	 mov	 ebx, DWORD PTR __Val$[ebp]
  00014	56		 push	 esi
  00015	8a 5b 0c	 mov	 bl, BYTE PTR [ebx+12]
$LL4@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  00018	6b f0 0d	 imul	 esi, eax, 13
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0001b	03 f7		 add	 esi, edi
  0001d	38 5e 0c	 cmp	 BYTE PTR [esi+12], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp

; 27   :         _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); _Idx = (_Hole - 1) >> 1) { // shift for codegen

  00020	73 24		 jae	 SHORT $LN16@Push_heap_

; 28   :         // move _Hole up to parent
; 29   :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00022	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  00026	6b d2 0d	 imul	 edx, edx, 13
  00029	66 0f d6 04 3a	 movq	 QWORD PTR [edx+edi], xmm0
  0002e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00031	89 4c 3a 08	 mov	 DWORD PTR [edx+edi+8], ecx
  00035	8a 4e 0c	 mov	 cl, BYTE PTR [esi+12]
  00038	88 4c 3a 0c	 mov	 BYTE PTR [edx+edi+12], cl

; 30   :         _Hole             = _Idx;

  0003c	8b d0		 mov	 edx, eax
  0003e	48		 dec	 eax
  0003f	d1 f8		 sar	 eax, 1
  00041	39 55 08	 cmp	 DWORD PTR __Top$[ebp], edx
  00044	7c d2		 jl	 SHORT $LL4@Push_heap_
$LN16@Push_heap_:
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
$LN12@Push_heap_:

; 31   :     }
; 32   : 
; 33   :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00048	6b ca 0d	 imul	 ecx, edx, 13
  0004b	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  0004e	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00052	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00055	66 0f d6 04 39	 movq	 QWORD PTR [ecx+edi], xmm0
  0005a	89 44 39 08	 mov	 DWORD PTR [ecx+edi+8], eax
  0005e	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00061	88 44 39 0c	 mov	 BYTE PTR [ecx+edi+12], al
  00065	5f		 pop	 edi

; 34   : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ENDP ; std::_Push_heap_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp
;	COMDAT ??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z PROC ; std::_Pop_heap_hole_unchecked<SShopItemTable *,SShopItemTable,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 87   : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :     // pop *_First to *_Dest and reheap
; 89   :     // precondition: _First != _Last
; 90   :     // precondition: _First != _Dest
; 91   :     *_Dest      = _STD move(*_First);

  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000b	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00015	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00018	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 92   :     using _Diff = _Iter_diff_t<_RanIt>;
; 93   :     _STD _Pop_heap_hole_by_index(

  0001b	5e		 pop	 esi
  0001c	2b d1		 sub	 edx, ecx
  0001e	69 c2 c5 4e ec
	c4		 imul	 eax, edx, -991146299
  00024	89 45 08	 mov	 DWORD PTR __Dest$[ebp], eax
  00027	33 d2		 xor	 edx, edx

; 94   :         _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD forward<_Ty>(_Val), _Pred);
; 95   : }

  00029	5d		 pop	 ebp

; 92   :     using _Diff = _Iter_diff_t<_RanIt>;
; 93   :     _STD _Pop_heap_hole_by_index(

  0002a	e9 00 00 00 00	 jmp	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z ENDP ; std::_Pop_heap_hole_unchecked<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z PROC ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 8265 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f2		 mov	 esi, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00009	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0000c	3a 47 0c	 cmp	 al, BYTE PTR [edi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8267 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0000f	73 27		 jae	 SHORT $LN9@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  00011	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00015	8a d0		 mov	 dl, al
  00017	f3 0f 7e 0e	 movq	 xmm1, QWORD PTR [esi]
  0001b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001e	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00022	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00025	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00028	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  0002b	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 141  :     _Right   = _STD move(_Tmp);

  0002e	66 0f d6 0f	 movq	 QWORD PTR [edi], xmm1
  00032	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00035	88 57 0c	 mov	 BYTE PTR [edi+12], dl
$LN9@Med3_unche:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0003b	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  0003e	3a 46 0c	 cmp	 al, BYTE PTR [esi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8271 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00041	73 50		 jae	 SHORT $LN19@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  00043	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  00047	f3 0f 7e 09	 movq	 xmm1, QWORD PTR [ecx]
  0004b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004e	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00052	53		 push	 ebx

; 139  :     _Ty _Tmp = _STD move(_Left);

  00053	8a d8		 mov	 bl, al

; 140  :     _Left    = _STD move(_Right);

  00055	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00058	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0005b	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  0005f	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 141  :     _Right   = _STD move(_Tmp);

  00062	66 0f d6 0e	 movq	 QWORD PTR [esi], xmm1
  00066	89 56 08	 mov	 DWORD PTR [esi+8], edx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00069	0f b6 c3	 movzx	 eax, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 141  :     _Right   = _STD move(_Tmp);

  0006c	88 5e 0c	 mov	 BYTE PTR [esi+12], bl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0006f	3a 47 0c	 cmp	 al, BYTE PTR [edi+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8274 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00072	73 1e		 jae	 SHORT $LN24@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  00074	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00078	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  0007c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00082	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  00085	88 46 0c	 mov	 BYTE PTR [esi+12], al

; 141  :     _Right   = _STD move(_Tmp);

  00088	66 0f d6 0f	 movq	 QWORD PTR [edi], xmm1
  0008c	89 57 08	 mov	 DWORD PTR [edi+8], edx
  0008f	88 5f 0c	 mov	 BYTE PTR [edi+12], bl
$LN24@Med3_unche:
  00092	5b		 pop	 ebx
$LN19@Med3_unche:
  00093	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm

; 8278 : }

  00094	5e		 pop	 esi
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ENDP ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z PROC ; std::forward<SShopItemTable * &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z ENDP ; std::forward<SShopItemTable * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z
_TEXT	SEGMENT
??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z PROC ; std::to_address<SShopItemTable>, COMDAT
; __Val$ = ecx

; 541  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 542  :     return _Val;

  00000	8b c1		 mov	 eax, ecx

; 543  : }

  00002	c3		 ret	 0
??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z ENDP ; std::to_address<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAPAUSShopItemTable@@@std@@YA$$QAPAUSShopItemTable@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUSShopItemTable@@@std@@YA$$QAPAUSShopItemTable@@AAPAU1@@Z PROC ; std::move<SShopItemTable * &>, COMDAT
; __Arg$ = ecx

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1514 : }

  00002	c3		 ret	 0
??$move@AAPAUSShopItemTable@@@std@@YA$$QAPAUSShopItemTable@@AAPAU1@@Z ENDP ; std::move<SShopItemTable * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@QBDQAU1@II@Z
_TEXT	SEGMENT
__Byte_count$ = 8					; size = 4
__Object_count$dead$ = 12				; size = 4
??$_Copy_memmove_tail@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@QBDQAU1@II@Z PROC ; std::_Copy_memmove_tail<SShopItemTable *>, COMDAT
; __First_ch$ = ecx
; __Dest$ = edx

; 4747 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4748 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4749 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4750 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Byte_count$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b fa		 mov	 edi, edx
  0000b	51		 push	 ecx
  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 _memmove
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4752 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4753 :         (void) _Object_count;
; 4754 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4755 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00015	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi

; 4756 :     } else {
; 4757 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4758 :     }
; 4759 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Copy_memmove_tail@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@QBDQAU1@II@Z ENDP ; std::_Copy_memmove_tail<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00006	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  0000a	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  0000e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00011	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00014	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00017	88 42 0c	 mov	 BYTE PTR [edx+12], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 734  :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z PROC ; std::addressof<SShopItemTable>, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z ENDP ; std::addressof<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@USShopItemTable@@ABU1@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z
_TEXT	SEGMENT
??$construct_at@USShopItemTable@@ABU1@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z PROC ; std::construct_at<SShopItemTable,SShopItemTable const &>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00011	88 41 0c	 mov	 BYTE PTR [ecx+12], al
  00014	8b c1		 mov	 eax, ecx

; 464  : }

  00016	c3		 ret	 0
??$construct_at@USShopItemTable@@ABU1@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z ENDP ; std::construct_at<SShopItemTable,SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z PROC ; std::destroy_at<std::pair<SItemPos const ,SShopItemTable> >, COMDAT
; __Location$dead$ = ecx

; 331  : #if _HAS_CXX20
; 332  :     if constexpr (is_array_v<_Ty>) {
; 333  :         _STD _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 334  :     } else
; 335  : #endif // _HAS_CXX20
; 336  :     {
; 337  :         _Location->~_Ty();
; 338  :     }
; 339  : }

  00000	c2 00 00	 ret	 0
??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z ENDP ; std::destroy_at<std::pair<SItemPos const ,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::nullptr_t>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 775  :     return _Old_val;
; 776  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0N@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0N@@std@@YAII@Z PROC			; std::_Get_size_of_n<13>, COMDAT
; __Count$ = ecx

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {

  00000	81 f9 13 3b b1
	13		 cmp	 ecx, 330382099		; 13b13b13H
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0000c	6b c1 0d	 imul	 eax, ecx, 13

; 123  : }

  0000f	c3		 ret	 0
??$_Get_size_of_n@$0N@@std@@YAII@Z ENDP			; std::_Get_size_of_n<13>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 1172 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 289  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 20		 push	 32			; 00000020H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1173 :             _Al.deallocate(_Ptr, 1);
; 1174 :         }
; 1175 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00029	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002c	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 808  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1168 :         _Ptr = _Al.allocate(1);

  00035	6a 20		 push	 32			; 00000020H
  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0003e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00046	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 810  :     }

  00049	8b c6		 mov	 eax, esi
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00055	59		 pop	 ecx
  00056	5e		 pop	 esi
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
tv1039 = -16						; size = 4
tv1073 = -12						; size = 4
tv1093 = -12						; size = 4
$T1 = -12						; size = 4
__Erasednode$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract, COMDAT
; _this$ = ecx

; 527  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 528  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

  00006	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 45 f8	 mov	 DWORD PTR __Erasednode$1$[ebp], eax
  00010	57		 push	 edi

; 529  :         ++_Where; // save successor iterator for return

  00011	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00014	89 5d fc	 mov	 DWORD PTR _this$1$[ebp], ebx
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 530  : 
; 531  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 532  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 533  :         _Nodeptr _Pnode = _Erasednode;
; 534  : 
; 535  :         if (_Pnode->_Left->_Isnil) {

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$1$[ebp]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	75 18		 jne	 SHORT $LN94@Extract

; 536  :             _Fixnode = _Pnode->_Right; // stitch up right subtree
; 537  :         } else if (_Pnode->_Right->_Isnil) {

  0002a	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0002e	74 04		 je	 SHORT $LN7@Extract

; 538  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

  00030	8b f8		 mov	 edi, eax

; 539  :         } else { // two subtrees, must lift successor node to replace erased

  00032	eb 0e		 jmp	 SHORT $LN94@Extract
$LN7@Extract:

; 540  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

  00034	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]

; 541  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

  00037	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  0003a	3b d1		 cmp	 edx, ecx

; 542  :         }
; 543  : 
; 544  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

  0003c	0f 85 91 00 00
	00		 jne	 $LN9@Extract
$LN94@Extract:

; 545  :             _Fixnodeparent = _Erasednode->_Parent;
; 546  :             if (!_Fixnode->_Isnil) {

  00042	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00046	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00049	75 03		 jne	 SHORT $LN11@Extract

; 547  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

  0004b	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN11@Extract:

; 548  :             }
; 549  : 
; 550  :             if (_Myhead->_Parent == _Erasednode) {

  0004e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00050	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00053	75 05		 jne	 SHORT $LN12@Extract

; 551  :                 _Myhead->_Parent = _Fixnode; // link down from root

  00055	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00058	eb 0b		 jmp	 SHORT $LN15@Extract
$LN12@Extract:

; 552  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

  0005a	39 0e		 cmp	 DWORD PTR [esi], ecx
  0005c	75 04		 jne	 SHORT $LN14@Extract

; 553  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

  0005e	89 3e		 mov	 DWORD PTR [esi], edi

; 554  :             } else {

  00060	eb 03		 jmp	 SHORT $LN15@Extract
$LN14@Extract:

; 555  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

  00062	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN15@Extract:

; 556  :             }
; 557  : 
; 558  :             if (_Myhead->_Left == _Erasednode) {

  00065	8b 03		 mov	 eax, DWORD PTR [ebx]
  00067	39 08		 cmp	 DWORD PTR [eax], ecx
  00069	75 28		 jne	 SHORT $LN16@Extract

; 559  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  0006b	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0006f	74 04		 je	 SHORT $LN42@Extract
  00071	8b d6		 mov	 edx, esi
  00073	eb 1c		 jmp	 SHORT $LN43@Extract
$LN42@Extract:

; 476  :         while (!_Pnode->_Left->_Isnil) {

  00075	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 559  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  00077	8b d7		 mov	 edx, edi

; 476  :         while (!_Pnode->_Left->_Isnil) {

  00079	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0007d	75 0f		 jne	 SHORT $LN49@Extract
  0007f	90		 npad	 1
$LL48@Extract:
  00080	8b 01		 mov	 eax, DWORD PTR [ecx]

; 477  :             _Pnode = _Pnode->_Left;

  00082	8b d1		 mov	 edx, ecx
  00084	8b c8		 mov	 ecx, eax
  00086	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008a	74 f4		 je	 SHORT $LL48@Extract
  0008c	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN49@Extract:
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$1$[ebp]
$LN43@Extract:

; 559  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  00091	89 10		 mov	 DWORD PTR [eax], edx
$LN16@Extract:

; 560  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 561  :             }
; 562  : 
; 563  :             if (_Myhead->_Right == _Erasednode) {

  00093	8b 13		 mov	 edx, DWORD PTR [ebx]
  00095	39 4a 08	 cmp	 DWORD PTR [edx+8], ecx
  00098	75 34		 jne	 SHORT $LN17@Extract

; 564  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  0009a	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0009e	74 0d		 je	 SHORT $LN44@Extract

; 565  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 566  :             }
; 567  :         } else { // erased has two subtrees, _Pnode is successor to erased

  000a0	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  000a3	8b ce		 mov	 ecx, esi
  000a5	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000a8	e9 94 00 00 00	 jmp	 $LN58@Extract
$LN44@Extract:

; 468  :         while (!_Pnode->_Right->_Isnil) {

  000ad	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 564  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  000b0	8b cf		 mov	 ecx, edi

; 468  :         while (!_Pnode->_Right->_Isnil) {

  000b2	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000b6	75 13		 jne	 SHORT $LN54@Extract
  000b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL53@Extract:

; 469  :             _Pnode = _Pnode->_Right;

  000c0	8b c8		 mov	 ecx, eax
  000c2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000c5	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000c9	74 f5		 je	 SHORT $LL53@Extract
$LN54@Extract:

; 564  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  000cb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN17@Extract:

; 565  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 566  :             }
; 567  :         } else { // erased has two subtrees, _Pnode is successor to erased

  000ce	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  000d1	eb 6e		 jmp	 SHORT $LN58@Extract
$LN9@Extract:

; 568  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

  000d3	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 569  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

  000d6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d8	89 02		 mov	 DWORD PTR [edx], eax

; 570  : 
; 571  :             if (_Pnode == _Erasednode->_Right) {

  000da	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  000dd	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  000e0	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000e3	75 04		 jne	 SHORT $LN18@Extract

; 572  :                 _Fixnodeparent = _Pnode; // successor is next to erased

  000e5	8b f2		 mov	 esi, edx

; 573  :             } else { // successor further down, link in place of erased

  000e7	eb 1f		 jmp	 SHORT $LN19@Extract
$LN18@Extract:

; 574  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's
; 575  :                 if (!_Fixnode->_Isnil) {

  000e9	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000ed	8b 30		 mov	 esi, DWORD PTR [eax]
  000ef	75 03		 jne	 SHORT $LN20@Extract

; 576  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

  000f1	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN20@Extract:

; 577  :                 }
; 578  : 
; 579  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

  000f4	89 3e		 mov	 DWORD PTR [esi], edi

; 580  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

  000f6	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000f9	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 581  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

  000fc	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000ff	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00102	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  00105	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN19@Extract:

; 582  :             }
; 583  : 
; 584  :             if (_Myhead->_Parent == _Erasednode) {

  00108	8b 03		 mov	 eax, DWORD PTR [ebx]
  0010a	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  0010d	75 05		 jne	 SHORT $LN21@Extract

; 585  :                 _Myhead->_Parent = _Pnode; // link down from root

  0010f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00112	eb 0e		 jmp	 SHORT $LN141@Extract
$LN21@Extract:

; 586  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

  00114	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00117	39 08		 cmp	 DWORD PTR [eax], ecx
  00119	75 04		 jne	 SHORT $LN23@Extract

; 587  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

  0011b	89 10		 mov	 DWORD PTR [eax], edx

; 588  :             } else {

  0011d	eb 03		 jmp	 SHORT $LN141@Extract
$LN23@Extract:

; 589  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

  0011f	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN141@Extract:

; 590  :             }
; 591  : 
; 592  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

  00122	b8 04 00 00 00	 mov	 eax, 4
  00127	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  0012a	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0012d	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 140  :     _Left    = _STD move(_Right);

  0012f	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  00132	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]
  00135	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  00138	88 42 0c	 mov	 BYTE PTR [edx+12], al

; 141  :     _Right   = _STD move(_Tmp);

  0013b	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  0013e	88 48 0c	 mov	 BYTE PTR [eax+12], cl
$LN58@Extract:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree

; 596  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

  00141	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00145	0f 85 ba 01 00
	00		 jne	 $LN25@Extract

; 597  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  0014b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0014d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00150	0f 84 a8 01 00
	00		 je	 $LN3@Extract
  00156	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  0015a	89 75 f4	 mov	 DWORD PTR tv1093[ebp], esi
  0015d	0f 85 9b 01 00
	00		 jne	 $LN3@Extract
$LL4@Extract:

; 598  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

  00163	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00165	3b f9		 cmp	 edi, ecx
  00167	0f 85 be 00 00
	00		 jne	 $LN26@Extract

; 599  :                     _Pnode = _Fixnodeparent->_Right;

  0016d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 600  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

  00170	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00174	75 54		 jne	 SHORT $LN95@Extract

; 601  :                         _Pnode->_Color         = _Black;

  00176	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 484  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  0017a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 602  :                         _Fixnodeparent->_Color = _Red;

  0017d	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0

; 485  :         _Wherenode->_Right = _Pnode->_Left;

  00181	8b 01		 mov	 eax, DWORD PTR [ecx]
  00183	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 486  : 
; 487  :         if (!_Pnode->_Left->_Isnil) {

  00186	8b 01		 mov	 eax, DWORD PTR [ecx]
  00188	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0018c	75 03		 jne	 SHORT $LN61@Extract

; 488  :             _Pnode->_Left->_Parent = _Wherenode;

  0018e	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN61@Extract:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Parent = _Wherenode->_Parent;

  00191	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00194	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00197	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 492  : 
; 493  :         if (_Wherenode == _Myhead->_Parent) {

  0019a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0019c	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  0019f	75 0c		 jne	 SHORT $LN62@Extract

; 494  :             _Myhead->_Parent = _Pnode;

  001a1	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;

  001a4	89 31		 mov	 DWORD PTR [ecx], esi

; 502  :         _Wherenode->_Parent = _Pnode;

  001a6	89 0a		 mov	 DWORD PTR [edx], ecx

; 603  :                         _Lrotate(_Fixnodeparent);
; 604  :                         _Pnode = _Fixnodeparent->_Right;

  001a8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001ab	eb 20		 jmp	 SHORT $LN87@Extract
$LN62@Extract:

; 495  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001ad	8b 02		 mov	 eax, DWORD PTR [edx]
  001af	3b 30		 cmp	 esi, DWORD PTR [eax]
  001b1	75 0b		 jne	 SHORT $LN64@Extract

; 496  :             _Wherenode->_Parent->_Left = _Pnode;

  001b3	89 08		 mov	 DWORD PTR [eax], ecx

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;

  001b5	89 31		 mov	 DWORD PTR [ecx], esi

; 502  :         _Wherenode->_Parent = _Pnode;

  001b7	89 0a		 mov	 DWORD PTR [edx], ecx

; 603  :                         _Lrotate(_Fixnodeparent);
; 604  :                         _Pnode = _Fixnodeparent->_Right;

  001b9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001bc	eb 0f		 jmp	 SHORT $LN87@Extract
$LN64@Extract:

; 498  :             _Wherenode->_Parent->_Right = _Pnode;

  001be	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;

  001c1	89 31		 mov	 DWORD PTR [ecx], esi

; 502  :         _Wherenode->_Parent = _Pnode;

  001c3	89 0a		 mov	 DWORD PTR [edx], ecx

; 603  :                         _Lrotate(_Fixnodeparent);
; 604  :                         _Pnode = _Fixnodeparent->_Right;

  001c5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c8	eb 03		 jmp	 SHORT $LN87@Extract
$LN95@Extract:
  001ca	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
$LN87@Extract:

; 605  :                     }
; 606  : 
; 607  :                     if (_Pnode->_Isnil) {

  001cd	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001d1	0f 85 d0 00 00
	00		 jne	 $LN2@Extract

; 608  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 609  :                     } else if (_Pnode->_Left->_Color == _Black
; 610  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

  001d7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001d9	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001dd	75 0d		 jne	 SHORT $LN97@Extract
  001df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001e2	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001e6	0f 84 b4 00 00
	00		 je	 $LN142@Extract
$LN97@Extract:

; 611  :                         _Pnode->_Color = _Red;
; 612  :                         _Fixnode       = _Fixnodeparent;
; 613  :                     } else { // must rearrange right subtree
; 614  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

  001ec	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001ef	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  001f2	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001f6	75 15		 jne	 SHORT $LN33@Extract

; 615  :                             _Pnode->_Left->_Color = _Black;

  001f8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  :                             _Pnode->_Color        = _Red;
; 617  :                             _Rrotate(_Pnode);

  001fa	51		 push	 ecx
  001fb	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001ff	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00203	8b cb		 mov	 ecx, ebx
  00205	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate

; 618  :                             _Pnode = _Fixnodeparent->_Right;

  0020a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN33@Extract:

; 619  :                         }
; 620  : 
; 621  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  0020d	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00210	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 622  :                         _Fixnodeparent->_Color = _Black;

  00213	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 623  :                         _Pnode->_Right->_Color = _Black;

  00217	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 624  :                         _Lrotate(_Fixnodeparent);

  0021a	8b cb		 mov	 ecx, ebx
  0021c	56		 push	 esi
  0021d	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00221	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate

; 625  :                         break; // tree now recolored/rebalanced

  00226	e9 d3 00 00 00	 jmp	 $LN3@Extract
$LN26@Extract:

; 626  :                     }
; 627  :                 } else { // fixup right subtree
; 628  :                     _Pnode = _Fixnodeparent->_Left;
; 629  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

  0022b	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0022f	75 55		 jne	 SHORT $LN96@Extract

; 630  :                         _Pnode->_Color         = _Black;

  00231	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 506  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00235	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 631  :                         _Fixnodeparent->_Color = _Red;

  00237	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0

; 507  :         _Wherenode->_Left = _Pnode->_Right;

  0023b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0023e	89 06		 mov	 DWORD PTR [esi], eax

; 508  : 
; 509  :         if (!_Pnode->_Right->_Isnil) {

  00240	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00243	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00247	75 03		 jne	 SHORT $LN69@Extract

; 510  :             _Pnode->_Right->_Parent = _Wherenode;

  00249	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN69@Extract:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Parent = _Wherenode->_Parent;

  0024c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0024f	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00252	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 514  : 
; 515  :         if (_Wherenode == _Myhead->_Parent) {

  00255	8b 03		 mov	 eax, DWORD PTR [ebx]
  00257	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  0025a	75 0c		 jne	 SHORT $LN70@Extract

; 516  :             _Myhead->_Parent = _Pnode;

  0025c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  0025f	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 524  :         _Wherenode->_Parent = _Pnode;

  00262	89 0a		 mov	 DWORD PTR [edx], ecx

; 632  :                         _Rrotate(_Fixnodeparent);
; 633  :                         _Pnode = _Fixnodeparent->_Left;

  00264	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00266	eb 21		 jmp	 SHORT $LN86@Extract
$LN70@Extract:

; 517  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00268	8b 02		 mov	 eax, DWORD PTR [edx]
  0026a	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0026d	75 0c		 jne	 SHORT $LN72@Extract

; 518  :             _Wherenode->_Parent->_Right = _Pnode;

  0026f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  00272	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 524  :         _Wherenode->_Parent = _Pnode;

  00275	89 0a		 mov	 DWORD PTR [edx], ecx

; 632  :                         _Rrotate(_Fixnodeparent);
; 633  :                         _Pnode = _Fixnodeparent->_Left;

  00277	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00279	eb 0e		 jmp	 SHORT $LN86@Extract
$LN72@Extract:

; 520  :             _Wherenode->_Parent->_Left = _Pnode;

  0027b	89 08		 mov	 DWORD PTR [eax], ecx

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;

  0027d	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 524  :         _Wherenode->_Parent = _Pnode;

  00280	89 0a		 mov	 DWORD PTR [edx], ecx

; 632  :                         _Rrotate(_Fixnodeparent);
; 633  :                         _Pnode = _Fixnodeparent->_Left;

  00282	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00284	eb 03		 jmp	 SHORT $LN86@Extract
$LN96@Extract:
  00286	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
$LN86@Extract:

; 634  :                     }
; 635  : 
; 636  :                     if (_Pnode->_Isnil) {

  00289	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0028d	75 18		 jne	 SHORT $LN2@Extract

; 637  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 638  :                     } else if (_Pnode->_Right->_Color == _Black
; 639  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

  0028f	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00292	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  00296	75 2c		 jne	 SHORT $LN98@Extract
  00298	8b 01		 mov	 eax, DWORD PTR [ecx]
  0029a	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0029e	75 24		 jne	 SHORT $LN98@Extract
$LN142@Extract:

; 597  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  002a0	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  002a3	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN2@Extract:
  002a7	8b 03		 mov	 eax, DWORD PTR [ebx]
  002a9	8b 4d f4	 mov	 ecx, DWORD PTR tv1093[ebp]
  002ac	8b f9		 mov	 edi, ecx
  002ae	8b 32		 mov	 esi, DWORD PTR [edx]
  002b0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  002b3	74 49		 je	 SHORT $LN3@Extract
  002b5	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  002b9	89 75 f4	 mov	 DWORD PTR tv1093[ebp], esi
  002bc	0f 84 a1 fe ff
	ff		 je	 $LL4@Extract
  002c2	eb 3a		 jmp	 SHORT $LN3@Extract
$LN98@Extract:

; 640  :                         _Pnode->_Color = _Red;
; 641  :                         _Fixnode       = _Fixnodeparent;
; 642  :                     } else { // must rearrange left subtree
; 643  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

  002c4	8b 01		 mov	 eax, DWORD PTR [ecx]
  002c6	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  002ca	75 17		 jne	 SHORT $LN101@Extract

; 644  :                             _Pnode->_Right->_Color = _Black;

  002cc	c6 43 0c 01	 mov	 BYTE PTR [ebx+12], 1

; 645  :                             _Pnode->_Color         = _Red;
; 646  :                             _Lrotate(_Pnode);

  002d0	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  002d3	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  002d7	51		 push	 ecx
  002d8	8b cb		 mov	 ecx, ebx
  002da	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate

; 647  :                             _Pnode = _Fixnodeparent->_Left;

  002df	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e1	eb 03		 jmp	 SHORT $LN39@Extract
$LN101@Extract:

; 640  :                         _Pnode->_Color = _Red;
; 641  :                         _Fixnode       = _Fixnodeparent;
; 642  :                     } else { // must rearrange left subtree
; 643  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

  002e3	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN39@Extract:

; 648  :                         }
; 649  : 
; 650  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  002e6	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  002e9	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 651  :                         _Fixnodeparent->_Color = _Black;

  002ec	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 652  :                         _Pnode->_Left->_Color  = _Black;

  002f0	8b 01		 mov	 eax, DWORD PTR [ecx]

; 653  :                         _Rrotate(_Fixnodeparent);

  002f2	8b cb		 mov	 ecx, ebx
  002f4	56		 push	 esi
  002f5	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  002f9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate
$LN3@Extract:

; 654  :                         break; // tree now recolored/rebalanced
; 655  :                     }
; 656  :                 }
; 657  :             }
; 658  : 
; 659  :             _Fixnode->_Color = _Black; // stopping node is black

  002fe	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  00301	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN25@Extract:

; 660  :         }
; 661  : 
; 662  :         if (0 < _Mysize) {

  00305	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00308	85 c9		 test	 ecx, ecx
  0030a	74 04		 je	 SHORT $LN40@Extract

; 663  :             --_Mysize;

  0030c	49		 dec	 ecx
  0030d	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
$LN40@Extract:

; 664  :         }
; 665  : 
; 666  :         return _Erasednode;
; 667  :     }

  00310	5f		 pop	 edi
  00311	5e		 pop	 esi
  00312	5b		 pop	 ebx
  00313	8b e5		 mov	 esp, ebp
  00315	5d		 pop	 ebp
  00316	c2 04 00	 ret	 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate, COMDAT
; _this$ = ecx

; 505  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 507  :         _Wherenode->_Left = _Pnode->_Right;

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 508  : 
; 509  :         if (!_Pnode->_Right->_Isnil) {

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Rrotate

; 510  :             _Pnode->_Right->_Parent = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Parent = _Wherenode->_Parent;

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 514  : 
; 515  :         if (_Wherenode == _Myhead->_Parent) {

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN3@Rrotate

; 516  :             _Myhead->_Parent = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;
; 524  :         _Wherenode->_Parent = _Pnode;
; 525  :     }

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN3@Rrotate:

; 517  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN5@Rrotate

; 518  :             _Wherenode->_Parent->_Right = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;
; 524  :         _Wherenode->_Parent = _Pnode;
; 525  :     }

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN5@Rrotate:

; 519  :         } else {
; 520  :             _Wherenode->_Parent->_Left = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 521  :         }
; 522  : 
; 523  :         _Pnode->_Right      = _Wherenode;
; 524  :         _Wherenode->_Parent = _Pnode;
; 525  :     }

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate, COMDAT
; _this$ = ecx

; 483  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 485  :         _Wherenode->_Right = _Pnode->_Left;

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 486  : 
; 487  :         if (!_Pnode->_Left->_Isnil) {

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Lrotate

; 488  :             _Pnode->_Left->_Parent = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Parent = _Wherenode->_Parent;

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 492  : 
; 493  :         if (_Wherenode == _Myhead->_Parent) {

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN3@Lrotate

; 494  :             _Myhead->_Parent = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;
; 502  :         _Wherenode->_Parent = _Pnode;
; 503  :     }

  0002a	89 16		 mov	 DWORD PTR [esi], edx
  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN3@Lrotate:

; 495  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN5@Lrotate

; 496  :             _Wherenode->_Parent->_Left = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;
; 502  :         _Wherenode->_Parent = _Pnode;
; 503  :     }

  0003d	89 16		 mov	 DWORD PTR [esi], edx
  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@Lrotate:

; 497  :         } else {
; 498  :             _Wherenode->_Parent->_Right = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 499  :         }
; 500  : 
; 501  :         _Pnode->_Left       = _Wherenode;
; 502  :         _Wherenode->_Parent = _Pnode;
; 503  :     }

  0004a	89 16		 mov	 DWORD PTR [esi], edx
  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >, COMDAT
; _this$ = ecx

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00000	6a 20		 push	 32			; 00000020H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 991  :     }

  0000a	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  :         ::operator delete(_Ptr, _Bytes);

  00003	6a 20		 push	 32			; 00000020H
  00005	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 986  :     }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >, COMDAT
; _this$ = ecx

; 974  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1213 :         return (_STD min)(

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 1214 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1215 :     }

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z PROC ; std::construct_at<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00000	66 8b 02	 mov	 ax, WORD PTR [edx]
  00003	66 89 01	 mov	 WORD PTR [ecx], ax
  00006	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0000a	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0000d	f3 0f 7e 42 03	 movq	 xmm0, QWORD PTR [edx+3]
  00012	66 0f d6 41 03	 movq	 QWORD PTR [ecx+3], xmm0
  00017	8b 42 0b	 mov	 eax, DWORD PTR [edx+11]
  0001a	89 41 0b	 mov	 DWORD PTR [ecx+11], eax
  0001d	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  00021	88 41 0f	 mov	 BYTE PTR [ecx+15], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00024	8b c1		 mov	 eax, ecx

; 464  : }

  00026	c3		 ret	 0
??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z ENDP ; std::construct_at<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z
_TEXT	SEGMENT
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	8b c1		 mov	 eax, ecx

; 464  : }

  00006	c3		 ret	 0
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@USShopItemTable@@U1@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z
_TEXT	SEGMENT
??$construct_at@USShopItemTable@@U1@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z PROC ; std::construct_at<SShopItemTable,SShopItemTable>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00011	88 41 0c	 mov	 BYTE PTR [ecx+12], al
  00014	8b c1		 mov	 eax, ecx

; 464  : }

  00016	c3		 ret	 0
??$construct_at@USShopItemTable@@U1@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z ENDP ; std::construct_at<SShopItemTable,SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z
_TEXT	SEGMENT
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	8b c1		 mov	 eax, ecx

; 464  : }

  00006	c3		 ret	 0
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1166 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1167 :         _Ptr = nullptr; // if allocate throws, prevents double-free
; 1168 :         _Ptr = _Al.allocate(1);

  00003	6a 20		 push	 32			; 00000020H
  00005	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	5e		 pop	 esi

; 1169 :     }

  00018	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Max, COMDAT
; __Pnode$ = ecx

; 468  :         while (!_Pnode->_Right->_Isnil) {

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00007	75 13		 jne	 SHORT $LN10@Max
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Max:

; 469  :             _Pnode = _Pnode->_Right;

  00010	8b c2		 mov	 eax, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max

; 473  :     }

  0001b	c3		 ret	 0
$LN10@Max:

; 470  :         }
; 471  : 
; 472  :         return _Pnode;

  0001c	8b c1		 mov	 eax, ecx

; 473  :     }

  0001e	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::max_size, COMDAT
; ___formal$dead$ = ecx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 747  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1979 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1980 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::pair<SItemPos const ,SShopItemTable>::pair<SItemPos const ,SShopItemTable><SItemPos,SShopItemTable,0>, COMDAT
; _this$ = ecx

; 303  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	66 8b 02	 mov	 ax, WORD PTR [edx]
  00009	66 89 01	 mov	 WORD PTR [ecx], ax
  0000c	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00010	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00013	f3 0f 7e 42 03	 movq	 xmm0, QWORD PTR [edx+3]
  00018	66 0f d6 41 03	 movq	 QWORD PTR [ecx+3], xmm0
  0001d	8b 42 0b	 mov	 eax, DWORD PTR [edx+11]
  00020	89 41 0b	 mov	 DWORD PTR [ecx+11], eax
  00023	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  00027	88 41 0f	 mov	 BYTE PTR [ecx+15], al
  0002a	8b c1		 mov	 eax, ecx
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::pair<SItemPos const ,SShopItemTable>::pair<SItemPos const ,SShopItemTable><SItemPos,SShopItemTable,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1543 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1544 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z
_TEXT	SEGMENT
??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z PROC ; std::forward<SItemPos>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z ENDP ; std::forward<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\GameType.h
;	COMDAT ??MSItemPos@@QBE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??MSItemPos@@QBE_NABU0@@Z PROC				; SItemPos::operator<, COMDAT
; _this$ = ecx

; 254  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00003	8b 55 08	 mov	 edx, DWORD PTR _rhs$[ebp]
  00006	8a 01		 mov	 al, BYTE PTR [ecx]
  00008	53		 push	 ebx
  00009	3a 02		 cmp	 al, BYTE PTR [edx]
  0000b	72 13		 jb	 SHORT $LN4@operator
  0000d	75 0a		 jne	 SHORT $LN3@operator
  0000f	66 8b 41 01	 mov	 ax, WORD PTR [ecx+1]
  00013	66 3b 42 01	 cmp	 ax, WORD PTR [edx+1]
  00017	72 07		 jb	 SHORT $LN4@operator
$LN3@operator:
  00019	32 c0		 xor	 al, al
  0001b	5b		 pop	 ebx

; 256  : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN4@operator:

; 255  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00020	b0 01		 mov	 al, 1
  00022	5b		 pop	 ebx

; 256  : 	}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??MSItemPos@@QBE_NABU0@@Z ENDP				; SItemPos::operator<
_TEXT	ENDS
END
