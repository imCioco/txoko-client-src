; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35217.0 

	TITLE	d:\_m2work\txoko-m2-work\txoko-client-src\vs_files\userinterface\distribute\accountconnector.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@ ; `string'
PUBLIC	??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@ ; `string'
PUBLIC	??_C@_0BA@HGDBLFFH@SendLogin?5Error@		; `string'
PUBLIC	??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@ ; `string'
PUBLIC	??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@ ; `string'
PUBLIC	??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@	; `string'
PUBLIC	??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@ ; `string'
PUBLIC	??_C@_09FJACDEDF@BESAMEKEY@			; `string'
PUBLIC	??_C@_03KJMMOONA@?$CIs?$CJ@			; `string'
PUBLIC	??_C@_0P@OOEAIINI@OnLoginFailure@		; `string'
PUBLIC	??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@	; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ@			; `string'
PUBLIC	??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@ ; `string'
PUBLIC	??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@		; `string'
PUBLIC	??_C@_0N@PIKEFLJP@OnMatrixCard@			; `string'
PUBLIC	??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@	; `string'
PUBLIC	??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@ ; `string'
PUBLIC	??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@	; `string'
PUBLIC	??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@ ; `string'
PUBLIC	??_C@_0BB@JEKGEMCL@OnConnectFailure@		; `string'
PUBLIC	??_C@_06NAODFICM@OnExit@			; `string'
PUBLIC	??_R2CAccountConnector@@8			; CAccountConnector::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCAccountConnector@@@@8	; CSingleton<CAccountConnector>::`RTTI Base Class Array'
PUBLIC	??_R2CNetworkStream@@8				; CNetworkStream::`RTTI Base Class Array'
PUBLIC	??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (124,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CAccountConnector@@8		; CAccountConnector::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CNetworkStream@@8			; CNetworkStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$CSingleton@VCAccountConnector@@@@8	; CSingleton<CAccountConnector>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CSingleton@VCAccountConnector@@@@@8	; CSingleton<CAccountConnector> `RTTI Type Descriptor'
PUBLIC	??_R3CNetworkStream@@8				; CNetworkStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCNetworkStream@@@8			; CNetworkStream `RTTI Type Descriptor'
PUBLIC	??_R3CAccountConnector@@8			; CAccountConnector::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCAccountConnector@@@8			; CAccountConnector `RTTI Type Descriptor'
PUBLIC	??_R4?$CSingleton@VCAccountConnector@@@@6B@	; CSingleton<CAccountConnector>::`RTTI Complete Object Locator'
PUBLIC	??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ ; CAccountConnector::`RTTI Complete Object Locator'
PUBLIC	??_R4CAccountConnector@@6BCNetworkStream@@@	; CAccountConnector::`RTTI Complete Object Locator'
PUBLIC	?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A ; CSingleton<CAccountConnector>::ms_singleton
PUBLIC	??_7?$CSingleton@VCAccountConnector@@@@6B@	; CSingleton<CAccountConnector>::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ ; CAccountConnector::`vftable'
PUBLIC	??_7CAccountConnector@@6BCNetworkStream@@@	; CAccountConnector::`vftable'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	?OnProcess@CNetworkStream@@MAE_NXZ:PROC		; CNetworkStream::OnProcess
EXTRN	?SetSendBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetSendBufferSize
EXTRN	?SetRecvBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetRecvBufferSize
EXTRN	??1CNetworkStream@@UAE@XZ:PROC			; CNetworkStream::~CNetworkStream
EXTRN	??0CNetworkStream@@QAE@XZ:PROC			; CNetworkStream::CNetworkStream
EXTRN	?Peek@CNetworkStream@@QAE_NH@Z:PROC		; CNetworkStream::Peek
EXTRN	?Peek@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Peek
EXTRN	?ActivateCipher@CNetworkStream@@IAEXXZ:PROC	; CNetworkStream::ActivateCipher
EXTRN	?Activate@CNetworkStream@@IAE_NIPBXI@Z:PROC	; CNetworkStream::Activate
EXTRN	?Prepare@CNetworkStream@@IAEIPAXPAI@Z:PROC	; CNetworkStream::Prepare
EXTRN	?DecryptPackIV@CEterPackManager@@QAE_NK@Z:PROC	; CEterPackManager::DecryptPackIV
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	?IsSecurityMode@CNetworkStream@@QAE_NXZ:PROC	; CNetworkStream::IsSecurityMode
EXTRN	?RetrieveHybridCryptPackSDB@CEterPackManager@@QAEXPBE@Z:PROC ; CEterPackManager::RetrieveHybridCryptPackSDB
EXTRN	?RetrieveHybridCryptPackKeys@CEterPackManager@@QAEXPBE@Z:PROC ; CEterPackManager::RetrieveHybridCryptPackKeys
EXTRN	?RegisterPack@CEterPackManager@@QAE_NPBD0PBE@Z:PROC ; CEterPackManager::RegisterPack
EXTRN	?ELTimer_SetServerMSec@@YAXK@Z:PROC		; ELTimer_SetServerMSec
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?Recv@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Recv
EXTRN	?Process@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Process
EXTRN	?Tracen@@YAXPBD@Z:PROC				; Tracen
EXTRN	?SendSequence@CNetworkStream@@QAE_NXZ:PROC	; CNetworkStream::SendSequence
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?Send@CNetworkStream@@QAE_NHPBX@Z:PROC		; CNetworkStream::Send
EXTRN	_strncpy:PROC
EXTRN	?Disconnect@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Disconnect
EXTRN	?Connect@CNetworkStream@@QAE_NPBDHH@Z:PROC	; CNetworkStream::Connect
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__invoke_watson:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___std_exception_copy:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___std_terminate:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A DD 01H DUP (?) ; CSingleton<CAccountConnector>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A DD 01H DUP (?) ; CSingleton<CPythonNetworkStream>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CAccountConnector@@6BCNetworkStream@@@
CONST	SEGMENT
??_7CAccountConnector@@6BCNetworkStream@@@ DD FLAT:??_R4CAccountConnector@@6BCNetworkStream@@@ ; CAccountConnector::`vftable'
	DD	FLAT:??_ECAccountConnector@@UAEPAXI@Z
	DD	FLAT:?OnConnectSuccess@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnConnectFailure@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnRemoteDisconnect@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnDisconnect@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnProcess@CNetworkStream@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@
CONST	SEGMENT
??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ DD FLAT:??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ ; CAccountConnector::`vftable'
	DD	FLAT:??_ECAccountConnector@@WHM@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCAccountConnector@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCAccountConnector@@@@6B@ DD FLAT:??_R4?$CSingleton@VCAccountConnector@@@@6B@ ; CSingleton<CAccountConnector>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CAccountConnector@@6BCNetworkStream@@@
rdata$r	SEGMENT
??_R4CAccountConnector@@6BCNetworkStream@@@ DD 00H	; CAccountConnector::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAccountConnector@@@8
	DD	FLAT:??_R3CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@
rdata$r	SEGMENT
??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ DD 00H ; CAccountConnector::`RTTI Complete Object Locator'
	DD	07cH
	DD	00H
	DD	FLAT:??_R0?AVCAccountConnector@@@8
	DD	FLAT:??_R3CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCAccountConnector@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCAccountConnector@@@@6B@ DD 00H	; CSingleton<CAccountConnector>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCAccountConnector@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAccountConnector@@@8
data$rs	SEGMENT
??_R0?AVCAccountConnector@@@8 DD FLAT:??_7type_info@@6B@ ; CAccountConnector `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAccountConnector@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CAccountConnector@@8
rdata$r	SEGMENT
??_R3CAccountConnector@@8 DD 00H			; CAccountConnector::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCNetworkStream@@@8
data$rs	SEGMENT
??_R0?AVCNetworkStream@@@8 DD FLAT:??_7type_info@@6B@	; CNetworkStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCNetworkStream@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CNetworkStream@@8
rdata$r	SEGMENT
??_R3CNetworkStream@@8 DD 00H				; CNetworkStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCAccountConnector@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCAccountConnector@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CAccountConnector> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCAccountConnector@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCAccountConnector@@@@8 DD 00H	; CSingleton<CAccountConnector>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CNetworkStream@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CNetworkStream@@8 DD FLAT:??_R0?AVCNetworkStream@@@8 ; CNetworkStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCAccountConnector@@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAccountConnector@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAccountConnector@@8 DD FLAT:??_R0?AVCAccountConnector@@@8 ; CAccountConnector::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCAccountConnector@@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (124,-1,0,64)'
	DD	00H
	DD	07cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CNetworkStream@@8
rdata$r	SEGMENT
??_R2CNetworkStream@@8 DD FLAT:??_R1A@?0A@EA@CNetworkStream@@8 ; CNetworkStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCAccountConnector@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CAccountConnector@@8
rdata$r	SEGMENT
??_R2CAccountConnector@@8 DD FLAT:??_R1A@?0A@EA@CAccountConnector@@8 ; CAccountConnector::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CNetworkStream@@8
	DD	FLAT:??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_06NAODFICM@OnExit@
CONST	SEGMENT
??_C@_06NAODFICM@OnExit@ DB 'OnExit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JEKGEMCL@OnConnectFailure@
CONST	SEGMENT
??_C@_0BB@JEKGEMCL@OnConnectFailure@ DB 'OnConnectFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@
CONST	SEGMENT
??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@ DB 'KEY_AGREEMENT_COMPL'
	DB	'ETED RECV', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@
CONST	SEGMENT
??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@ DB 'KEY_AGREEMENT SEND %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@
CONST	SEGMENT
??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@ DB ' CAccountConnec'
	DB	'tor::__AuthState_RecvKeyAgreement - SendKeyAgreement Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@
CONST	SEGMENT
??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@ DB 'KEY_AGREEMENT RECV %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PIKEFLJP@OnMatrixCard@
CONST	SEGMENT
??_C@_0N@PIKEFLJP@OnMatrixCard@ DB 'OnMatrixCard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@
CONST	SEGMENT
??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@ DB '(iiiiiiii)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@
CONST	SEGMENT
??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@ DB 'BINARY_OnNEWCIBNPa'
	DB	'sspodRequest', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ@ DB '()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@
CONST	SEGMENT
??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@ DB 'BINARY_OnRunupMatrixQuiz'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOEAIINI@OnLoginFailure@
CONST	SEGMENT
??_C@_0P@OOEAIINI@OnLoginFailure@ DB 'OnLoginFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KJMMOONA@?$CIs?$CJ@
CONST	SEGMENT
??_C@_03KJMMOONA@?$CIs?$CJ@ DB '(s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FJACDEDF@BESAMEKEY@
CONST	SEGMENT
??_C@_09FJACDEDF@BESAMEKEY@ DB 'BESAMEKEY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@
CONST	SEGMENT
??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@ DB ' CAccountConne'
	DB	'ctor::__AuthState_RecvHandshake - SendHandshake Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@
CONST	SEGMENT
??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@ DB 'HANDSHAKE SEND %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@
CONST	SEGMENT
??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@ DB 'HANDSHAKE RECV %u %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@
CONST	SEGMENT
??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@ DB ' CAccountConne'
	DB	'ctor::__AuthState_RecvPhase - SendLogin3 Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
CONST	SEGMENT
??_C@_0BA@HGDBLFFH@SendLogin?5Error@ DB 'SendLogin Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@
CONST	SEGMENT
??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@ DB 'SendRunupMatrixCar'
	DB	'dPacketError', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@
CONST	SEGMENT
??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@ DB 'SendNEWCIBNPasspod'
	DB	'AnswerPacket', 00H				; `string'
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAADABD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	??$_Deallocate@$07@std@@YAXPAXI@Z		; std::_Deallocate<8>
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	??$_Convert_size@II@std@@YAII@Z			; std::_Convert_size<unsigned int,unsigned int>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??$construct_at@PADABQAD@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$construct_at@D$$V@std@@YAPADQAD@Z		; std::construct_at<char>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	??$_Max_limit@H@std@@YAHXZ			; std::_Max_limit<int>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??_ECAccountConnector@@WHM@AEPAXI@Z		; [thunk]:CAccountConnector::`vector deleting destructor'
PUBLIC	??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z ; CSingleton<CAccountConnector>::`scalar deleting destructor'
PUBLIC	??0?$CSingleton@VCAccountConnector@@@@QAE@XZ	; CSingleton<CAccountConnector>::CSingleton<CAccountConnector>
PUBLIC	??1?$CSingleton@VCAccountConnector@@@@UAE@XZ	; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>
PUBLIC	?Instance@?$CSingleton@VCPythonNetworkStream@@@@SAAAVCPythonNetworkStream@@XZ ; CSingleton<CPythonNetworkStream>::Instance
PUBLIC	?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ ; CSingleton<CEterPackManager>::Instance
PUBLIC	?instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ ; CSingleton<CEterPackManager>::instance
PUBLIC	??1CAccountConnector@@UAE@XZ			; CAccountConnector::~CAccountConnector
PUBLIC	??_GCAccountConnector@@UAEPAXI@Z		; CAccountConnector::`scalar deleting destructor'
PUBLIC	??0CAccountConnector@@QAE@XZ			; CAccountConnector::CAccountConnector
PUBLIC	?__Inialize@CAccountConnector@@IAEXXZ		; CAccountConnector::__Inialize
PUBLIC	?OnDisconnect@CAccountConnector@@MAEXXZ		; CAccountConnector::OnDisconnect
PUBLIC	?OnRemoteDisconnect@CAccountConnector@@MAEXXZ	; CAccountConnector::OnRemoteDisconnect
PUBLIC	?OnConnectSuccess@CAccountConnector@@MAEXXZ	; CAccountConnector::OnConnectSuccess
PUBLIC	?OnConnectFailure@CAccountConnector@@MAEXXZ	; CAccountConnector::OnConnectFailure
PUBLIC	?__AuthState_Set@CAccountConnector@@IAEXXZ	; CAccountConnector::__AuthState_Set
PUBLIC	?__HandshakeState_Set@CAccountConnector@@IAEXXZ	; CAccountConnector::__HandshakeState_Set
PUBLIC	?__OfflineState_Set@CAccountConnector@@IAEXXZ	; CAccountConnector::__OfflineState_Set
PUBLIC	?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
PUBLIC	?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
PUBLIC	?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
PUBLIC	?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreement
PUBLIC	?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvChinaMatrixCard
PUBLIC	?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest
PUBLIC	?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz
PUBLIC	?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthFailure
PUBLIC	?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthSuccess
PUBLIC	?__AuthState_SendPong@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_SendPong
PUBLIC	?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPing
PUBLIC	?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptSDB
PUBLIC	?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptKeys
PUBLIC	?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPanamaPack
PUBLIC	?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvHandshake
PUBLIC	?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPhase
PUBLIC	?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvEmpty
PUBLIC	?__AuthState_Process@CAccountConnector@@IAE_NXZ	; CAccountConnector::__AuthState_Process
PUBLIC	?__HandshakeState_Process@CAccountConnector@@IAE_NXZ ; CAccountConnector::__HandshakeState_Process
PUBLIC	?__StateProcess@CAccountConnector@@IAE_NXZ	; CAccountConnector::__StateProcess
PUBLIC	?Process@CAccountConnector@@QAEXXZ		; CAccountConnector::Process
PUBLIC	?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ; CAccountConnector::SendChinaMatrixCardPacket
PUBLIC	?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ; CAccountConnector::SendRunupMatrixCardPacket
PUBLIC	?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z ; CAccountConnector::SendNEWCIBNPasspodAnswerPacket
PUBLIC	?Disconnect@CAccountConnector@@QAEXXZ		; CAccountConnector::Disconnect
PUBLIC	?Connect@CAccountConnector@@QAE_NPBDH0H@Z	; CAccountConnector::Connect
PUBLIC	?ClearLoginInfo@CAccountConnector@@QAEXXZ	; CAccountConnector::ClearLoginInfo
PUBLIC	?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z	; CAccountConnector::SetLoginInfo
PUBLIC	?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z ; CAccountConnector::SetHandler
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?GetFixedHeaderSize@SPacketGCHybridSDB@@SAHXZ	; SPacketGCHybridSDB::GetFixedHeaderSize
PUBLIC	??1SPacketGCHybridSDB@@QAE@XZ			; SPacketGCHybridSDB::~SPacketGCHybridSDB
PUBLIC	??0SPacketGCHybridSDB@@QAE@H@Z			; SPacketGCHybridSDB::SPacketGCHybridSDB
PUBLIC	?GetFixedHeaderSize@SPacketGCHybridCryptKeys@@SAHXZ ; SPacketGCHybridCryptKeys::GetFixedHeaderSize
PUBLIC	??1SPacketGCHybridCryptKeys@@QAE@XZ		; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
PUBLIC	??0SPacketGCHybridCryptKeys@@QAE@H@Z		; SPacketGCHybridCryptKeys::SPacketGCHybridCryptKeys
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d23d70a
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e19999a
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f333333
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3fb33333
PUBLIC	__real@3fc00000
PUBLIC	__real@3fe3333333333333
PUBLIC	__real@40000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40490fd8
PUBLIC	__real@404e000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@4076800000000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41700000
PUBLIC	__real@41800000
PUBLIC	__real@41880000
PUBLIC	__real@41a00000
PUBLIC	__real@41d00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@42200000
PUBLIC	__real@42340000
PUBLIC	__real@42480000
PUBLIC	__real@425c0000
PUBLIC	__real@42652ee0
PUBLIC	__real@42700000
PUBLIC	__real@42b40000
PUBLIC	__real@42c70000
PUBLIC	__real@42c76666
PUBLIC	__real@42c80000
PUBLIC	__real@42dc0000
PUBLIC	__real@43000000
PUBLIC	__real@43160000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@437f0000
PUBLIC	__real@43960000
PUBLIC	__real@43b40000
PUBLIC	__real@43fa0000
PUBLIC	__real@44070000
PUBLIC	__real@44160000
PUBLIC	__real@44340000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@44a28000
PUBLIC	__real@44fa0000
PUBLIC	__real@45160000
PUBLIC	__real@451c4000
PUBLIC	__real@455ac000
PUBLIC	__real@461c4000
PUBLIC	__real@466a6000
PUBLIC	__real@46c80000
PUBLIC	__real@47435000
PUBLIC	__real@bf800000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c2b40000
PUBLIC	__real@c2c80000
PUBLIC	__real@c3340000
PUBLIC	__real@c61c4000
PUBLIC	__xmm@000000690000006a0000006c0000006b
PUBLIC	__xmm@0000006d000000680000006800000066
PUBLIC	__xmm@0000008e0000008d0000008c0000008b
PUBLIC	__xmm@0000c41c0000c41b0000c41a0000c419
PUBLIC	__xmm@3f800000000000003e99999a00000000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECAccountConnector@@UAEPAXI@Z:PROC		; CAccountConnector::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z:PROC ; CSingleton<CAccountConnector>::`vector deleting destructor'
EXTRN	__CIfmod:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ftol3:PROC
EXTRN	__libm_sse2_acos_precise:PROC
EXTRN	__libm_sse2_asin_precise:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__ltof3:PROC
EXTRN	_ceil:PROC
EXTRN	_floor:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_DATA	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003e99999a00000000
CONST	SEGMENT
__xmm@3f800000000000003e99999a00000000 DB 00H, 00H, 00H, 00H, 09aH, 099H, 099H
	DB	'>', 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@0000c41c0000c41b0000c41a0000c419
CONST	SEGMENT
__xmm@0000c41c0000c41b0000c41a0000c419 DB 019H, 0c4H, 00H, 00H, 01aH, 0c4H
	DB	00H, 00H, 01bH, 0c4H, 00H, 00H, 01cH, 0c4H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000008e0000008d0000008c0000008b
CONST	SEGMENT
__xmm@0000008e0000008d0000008c0000008b DB 08bH, 00H, 00H, 00H, 08cH, 00H, 00H
	DB	00H, 08dH, 00H, 00H, 00H, 08eH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000006d000000680000006800000066
CONST	SEGMENT
__xmm@0000006d000000680000006800000066 DB 'f', 00H, 00H, 00H, 'h', 00H, 00H
	DB	00H, 'h', 00H, 00H, 00H, 'm', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000690000006a0000006c0000006b
CONST	SEGMENT
__xmm@000000690000006a0000006c0000006b DB 'k', 00H, 00H, 00H, 'l', 00H, 00H
	DB	00H, 'j', 00H, 00H, 00H, 'i', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c61c4000
CONST	SEGMENT
__real@c61c4000 DD 0c61c4000r			; -10000
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2b40000
CONST	SEGMENT
__real@c2b40000 DD 0c2b40000r			; -90
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47435000
CONST	SEGMENT
__real@47435000 DD 047435000r			; 50000
CONST	ENDS
;	COMDAT __real@46c80000
CONST	SEGMENT
__real@46c80000 DD 046c80000r			; 25600
CONST	ENDS
;	COMDAT __real@466a6000
CONST	SEGMENT
__real@466a6000 DD 0466a6000r			; 15000
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@455ac000
CONST	SEGMENT
__real@455ac000 DD 0455ac000r			; 3500
CONST	ENDS
;	COMDAT __real@451c4000
CONST	SEGMENT
__real@451c4000 DD 0451c4000r			; 2500
CONST	ENDS
;	COMDAT __real@45160000
CONST	SEGMENT
__real@45160000 DD 045160000r			; 2400
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44a28000
CONST	SEGMENT
__real@44a28000 DD 044a28000r			; 1300
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44340000
CONST	SEGMENT
__real@44340000 DD 044340000r			; 720
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@44070000
CONST	SEGMENT
__real@44070000 DD 044070000r			; 540
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42dc0000
CONST	SEGMENT
__real@42dc0000 DD 042dc0000r			; 110
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42c76666
CONST	SEGMENT
__real@42c76666 DD 042c76666r			; 99.7
CONST	ENDS
;	COMDAT __real@42c70000
CONST	SEGMENT
__real@42c70000 DD 042c70000r			; 99.5
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee0
CONST	SEGMENT
__real@42652ee0 DD 042652ee0r			; 57.2958
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41d00000
CONST	SEGMENT
__real@41d00000 DD 041d00000r			; 26
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@40490fd8
CONST	SEGMENT
__real@40490fd8 DD 040490fd8r			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe3333333333333
CONST	SEGMENT
__real@3fe3333333333333 DQ 03fe3333333333333r	; 0.6
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb33333
CONST	SEGMENT
__real@3fb33333 DD 03fb33333r			; 1.4
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CAccountConnector@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CAccountConnector@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CAccountConnector@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$4
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
;	COMDAT ??0SPacketGCHybridCryptKeys@@QAE@H@Z
_TEXT	SEGMENT
_iStreamSize$ = 8					; size = 4
??0SPacketGCHybridCryptKeys@@QAE@H@Z PROC		; SPacketGCHybridCryptKeys::SPacketGCHybridCryptKeys, COMDAT
; _this$ = ecx

; 2634 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2633 : 	SPacketGCHybridCryptKeys(int iStreamSize) : iKeyStreamLen(iStreamSize)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iStreamSize$[ebp]

; 2634 : 	{

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2635 : 		m_pStream = new BYTE[iStreamSize];

  00009	50		 push	 eax
  0000a	89 46 03	 mov	 DWORD PTR [esi+3], eax
  0000d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00012	83 c4 04	 add	 esp, 4
  00015	89 46 07	 mov	 DWORD PTR [esi+7], eax

; 2636 : 	}

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0SPacketGCHybridCryptKeys@@QAE@H@Z ENDP		; SPacketGCHybridCryptKeys::SPacketGCHybridCryptKeys
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
;	COMDAT ??1SPacketGCHybridCryptKeys@@QAE@XZ
_TEXT	SEGMENT
??1SPacketGCHybridCryptKeys@@QAE@XZ PROC		; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys, COMDAT
; _this$ = ecx

; 2638 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2639 : 		if( m_pStream )

  00003	8b 46 07	 mov	 eax, DWORD PTR [esi+7]
  00006	85 c0		 test	 eax, eax
  00008	74 10		 je	 SHORT $LN2@SPacketGCH

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00010	83 c4 04	 add	 esp, 4

; 2642 : 			m_pStream = NULL;

  00013	c7 46 07 00 00
	00 00		 mov	 DWORD PTR [esi+7], 0
$LN2@SPacketGCH:

; 2643 : 		}
; 2644 : 	}

  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1SPacketGCHybridCryptKeys@@QAE@XZ ENDP		; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
;	COMDAT ?GetFixedHeaderSize@SPacketGCHybridCryptKeys@@SAHXZ
_TEXT	SEGMENT
?GetFixedHeaderSize@SPacketGCHybridCryptKeys@@SAHXZ PROC ; SPacketGCHybridCryptKeys::GetFixedHeaderSize, COMDAT

; 2647 : 		return sizeof(BYTE)+sizeof(WORD)+sizeof(int);

  00000	b8 07 00 00 00	 mov	 eax, 7

; 2648 : 	}

  00005	c3		 ret	 0
?GetFixedHeaderSize@SPacketGCHybridCryptKeys@@SAHXZ ENDP ; SPacketGCHybridCryptKeys::GetFixedHeaderSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
;	COMDAT ??0SPacketGCHybridSDB@@QAE@H@Z
_TEXT	SEGMENT
_iStreamSize$ = 8					; size = 4
??0SPacketGCHybridSDB@@QAE@H@Z PROC			; SPacketGCHybridSDB::SPacketGCHybridSDB, COMDAT
; _this$ = ecx

; 2665 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2664 : 	SPacketGCHybridSDB(int iStreamSize) : iSDBStreamLen(iStreamSize)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iStreamSize$[ebp]

; 2665 : 	{

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2666 : 		m_pStream = new BYTE[iStreamSize];

  00009	50		 push	 eax
  0000a	89 46 03	 mov	 DWORD PTR [esi+3], eax
  0000d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00012	83 c4 04	 add	 esp, 4
  00015	89 46 07	 mov	 DWORD PTR [esi+7], eax

; 2667 : 	}

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0SPacketGCHybridSDB@@QAE@H@Z ENDP			; SPacketGCHybridSDB::SPacketGCHybridSDB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
;	COMDAT ??1SPacketGCHybridSDB@@QAE@XZ
_TEXT	SEGMENT
??1SPacketGCHybridSDB@@QAE@XZ PROC			; SPacketGCHybridSDB::~SPacketGCHybridSDB, COMDAT
; _this$ = ecx

; 2669 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2670 : 		delete[] m_pStream;

  00003	ff 76 07	 push	 DWORD PTR [esi+7]
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	83 c4 04	 add	 esp, 4

; 2671 : 		m_pStream = NULL;

  0000e	c7 46 07 00 00
	00 00		 mov	 DWORD PTR [esi+7], 0
  00015	5e		 pop	 esi

; 2672 : 	}

  00016	c3		 ret	 0
??1SPacketGCHybridSDB@@QAE@XZ ENDP			; SPacketGCHybridSDB::~SPacketGCHybridSDB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
;	COMDAT ?GetFixedHeaderSize@SPacketGCHybridSDB@@SAHXZ
_TEXT	SEGMENT
?GetFixedHeaderSize@SPacketGCHybridSDB@@SAHXZ PROC	; SPacketGCHybridSDB::GetFixedHeaderSize, COMDAT

; 2675 : 		return sizeof(BYTE)+sizeof(WORD)+sizeof(int);

  00000	b8 07 00 00 00	 mov	 eax, 7

; 2676 : 	}

  00005	c3		 ret	 0
?GetFixedHeaderSize@SPacketGCHybridSDB@@SAHXZ ENDP	; SPacketGCHybridSDB::GetFixedHeaderSize
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_poHandler$ = 8						; size = 4
?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z PROC	; CAccountConnector::SetHandler, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 22   : 	m_poHandler = poHandler;

  00003	8b 45 08	 mov	 eax, DWORD PTR _poHandler$[ebp]
  00006	89 81 d4 00 00
	00		 mov	 DWORD PTR [ecx+212], eax

; 23   : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z ENDP	; CAccountConnector::SetHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z
_TEXT	SEGMENT
_c_szName$ = 8						; size = 4
_c_szPwd$ = 12						; size = 4
?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z PROC	; CAccountConnector::SetLoginInfo, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_szName$[ebp]
  00007	8b d6		 mov	 edx, esi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 26   : {

  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000c	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0000f	90		 npad	 1
$LL17@SetLoginIn:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL17@SetLoginIn
  00017	2b d1		 sub	 edx, ecx
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 27   : 	m_strID = c_szName;

  00019	8d 8f 84 00 00
	00		 lea	 ecx, DWORD PTR [edi+132]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001f	52		 push	 edx
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00026	8b 55 0c	 mov	 edx, DWORD PTR _c_szPwd$[ebp]
  00029	8b c2		 mov	 eax, edx
  0002b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0002e	66 90		 npad	 2
$LL18@SetLoginIn:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL18@SetLoginIn
  00037	2b c6		 sub	 eax, esi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 28   : 	m_strPassword = c_szPwd;

  00039	8d 8f 9c 00 00
	00		 lea	 ecx, DWORD PTR [edi+156]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0003f	50		 push	 eax
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 29   : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z ENDP	; CAccountConnector::SetLoginInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?ClearLoginInfo@CAccountConnector@@QAEXXZ
_TEXT	SEGMENT
?ClearLoginInfo@CAccountConnector@@QAEXXZ PROC		; CAccountConnector::ClearLoginInfo, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 34   : 	m_strPassword = "";

  00007	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 35   : }

  00012	c3		 ret	 0
?ClearLoginInfo@CAccountConnector@@QAEXXZ ENDP		; CAccountConnector::ClearLoginInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?Connect@CAccountConnector@@QAE_NPBDH0H@Z
_TEXT	SEGMENT
_c_szAddr$ = 8						; size = 4
_iPort$ = 12						; size = 4
_c_szAccountAddr$ = 16					; size = 4
_iAccountPort$ = 20					; size = 4
?Connect@CAccountConnector@@QAE_NPBDH0H@Z PROC		; CAccountConnector::Connect, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR _c_szAddr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 38   : {

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL12@Connect:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL12@Connect
  00017	2b c7		 sub	 eax, edi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 43   : 	m_strAddr = c_szAddr;

  00019	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 44   : 	m_iPort = iPort;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _iPort$[ebp]

; 45   : 
; 46   : 	__OfflineState_Set();

  00029	8b ce		 mov	 ecx, esi
  0002b	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00031	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 47   : 
; 48   : 	// CHINA_CRYPT_KEY
; 49   : 	if (LocaleService_IsYMIR())

  00036	e8 00 00 00 00	 call	 ?LocaleService_IsYMIR@@YA_NXZ ; LocaleService_IsYMIR
  0003b	84 c0		 test	 al, al
  0003d	75 05		 jne	 SHORT $LN3@Connect

; 50   : 	{
; 51   : 	}	
; 52   : 	else
; 53   : 	{
; 54   : 		__BuildClientKey_20050304Myevan();		

  0003f	e8 00 00 00 00	 call	 ?__BuildClientKey_20050304Myevan@CAccountConnector@@IAEXXZ ; CAccountConnector::__BuildClientKey_20050304Myevan
$LN3@Connect:

; 55   : 	}
; 56   : 	// END_OF_CHINA_CRYPT_KEY
; 57   : 
; 58   : 	return CNetworkStream::Connect(c_szAccountAddr, iAccountPort);

  00044	6a 03		 push	 3
  00046	ff 75 14	 push	 DWORD PTR _iAccountPort$[ebp]
  00049	8b ce		 mov	 ecx, esi
  0004b	ff 75 10	 push	 DWORD PTR _c_szAccountAddr$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 59   : }

  00055	5d		 pop	 ebp
  00056	c2 10 00	 ret	 16			; 00000010H
?Connect@CAccountConnector@@QAE_NPBDH0H@Z ENDP		; CAccountConnector::Connect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?Disconnect@CAccountConnector@@QAEXXZ
_TEXT	SEGMENT
?Disconnect@CAccountConnector@@QAEXXZ PROC		; CAccountConnector::Disconnect, COMDAT
; _this$ = ecx

; 62   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 63   : 	CNetworkStream::Disconnect();

  00003	e8 00 00 00 00	 call	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect

; 64   : 	__OfflineState_Set();

  00008	8b ce		 mov	 ecx, esi
  0000a	5e		 pop	 esi
  0000b	e9 00 00 00 00	 jmp	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set
?Disconnect@CAccountConnector@@QAEXXZ ENDP		; CAccountConnector::Disconnect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z
_TEXT	SEGMENT
_answerPacket$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_answer$ = 8						; size = 4
?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z PROC ; CAccountConnector::SendNEWCIBNPasspodAnswerPacket, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _answer$[ebp]
  00013	56		 push	 esi

; 69   : 	TPacketCGNEWCIBNPasspodAnswer answerPacket;
; 70   : 	answerPacket.bHeader = HEADER_CG_NEWCIBN_PASSPOD_ANSWER;
; 71   : 	strncpy(answerPacket.szAnswer, answer, NEWCIBN_PASSPOD_ANSWER_MAX_LEN);

  00014	6a 08		 push	 8
  00016	50		 push	 eax
  00017	8d 45 f1	 lea	 eax, DWORD PTR _answerPacket$[ebp+1]
  0001a	c6 45 f0 ca	 mov	 BYTE PTR _answerPacket$[ebp], 202 ; 000000caH
  0001e	50		 push	 eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 _strncpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 72   : 	answerPacket.szAnswer[NEWCIBN_PASSPOD_ANSWER_MAX_LEN] = '\0';	

  00029	c6 45 f9 00	 mov	 BYTE PTR _answerPacket$[ebp+9], 0

; 73   : 	if (!Send(sizeof(answerPacket), &answerPacket))

  0002d	8d 45 f0	 lea	 eax, DWORD PTR _answerPacket$[ebp]
  00030	8b ce		 mov	 ecx, esi
  00032	50		 push	 eax
  00033	6a 0a		 push	 10			; 0000000aH
  00035	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0003a	84 c0		 test	 al, al
  0003c	75 20		 jne	 SHORT $LN2@SendNEWCIB

; 74   : 	{
; 75   : 		TraceError("SendNEWCIBNPasspodAnswerPacket");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@
  00043	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00048	83 c4 04	 add	 esp, 4

; 76   : 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 79   : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN2@SendNEWCIB:

; 77   : 	}
; 78   : 	return SendSequence();

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 79   : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	5e		 pop	 esi
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z ENDP ; CAccountConnector::SendNEWCIBNPasspodAnswerPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z
_TEXT	SEGMENT
_answerPacket$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_c_szMatrixCardString$ = 8				; size = 4
?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z PROC ; CAccountConnector::SendRunupMatrixCardPacket, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _c_szMatrixCardString$[ebp]
  00013	56		 push	 esi

; 83   : 	TPacketCGRunupMatrixAnswer answerPacket;
; 84   : 	answerPacket.bHeader = HEADER_CG_RUNUP_MATRIX_ANSWER;
; 85   : 	strncpy(answerPacket.szAnswer, c_szMatrixCardString, RUNUP_MATRIX_ANSWER_MAX_LEN);

  00014	6a 04		 push	 4
  00016	50		 push	 eax
  00017	8d 45 f5	 lea	 eax, DWORD PTR _answerPacket$[ebp+1]
  0001a	c6 45 f4 c9	 mov	 BYTE PTR _answerPacket$[ebp], 201 ; 000000c9H
  0001e	50		 push	 eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 _strncpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   : 	answerPacket.szAnswer[RUNUP_MATRIX_ANSWER_MAX_LEN] = '\0';

  00029	c6 45 f9 00	 mov	 BYTE PTR _answerPacket$[ebp+5], 0

; 87   : 	if (!Send(sizeof(answerPacket), &answerPacket))

  0002d	8d 45 f4	 lea	 eax, DWORD PTR _answerPacket$[ebp]
  00030	8b ce		 mov	 ecx, esi
  00032	50		 push	 eax
  00033	6a 06		 push	 6
  00035	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0003a	84 c0		 test	 al, al
  0003c	75 20		 jne	 SHORT $LN2@SendRunupM

; 88   : 	{
; 89   : 		TraceError("SendRunupMatrixCardPacketError");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@
  00043	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00048	83 c4 04	 add	 esp, 4

; 90   : 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 93   : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN2@SendRunupM:

; 91   : 	}
; 92   : 	return SendSequence();

  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 93   : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	5e		 pop	 esi
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ENDP ; CAccountConnector::SendRunupMatrixCardPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z
_TEXT	SEGMENT
_MatrixCardPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_c_szMatrixCardString$ = 8				; size = 4
?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z PROC ; CAccountConnector::SendChinaMatrixCardPacket, COMDAT
; _this$ = ecx

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _c_szMatrixCardString$[ebp]
  00013	56		 push	 esi

; 97   : 	TPacketCGChinaMatrixCard MatrixCardPacket;
; 98   : 	MatrixCardPacket.bHeader = HEADER_CG_CHINA_MATRIX_CARD;
; 99   : 	strncpy(MatrixCardPacket.szAnswer, c_szMatrixCardString, CHINA_MATRIX_ANSWER_MAX_LEN);

  00014	6a 08		 push	 8
  00016	50		 push	 eax
  00017	8d 45 f1	 lea	 eax, DWORD PTR _MatrixCardPacket$[ebp+1]
  0001a	c6 45 f0 6c	 mov	 BYTE PTR _MatrixCardPacket$[ebp], 108 ; 0000006cH
  0001e	50		 push	 eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 _strncpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  : 	MatrixCardPacket.szAnswer[CHINA_MATRIX_ANSWER_MAX_LEN] = '\0';

  00029	c6 45 f9 00	 mov	 BYTE PTR _MatrixCardPacket$[ebp+9], 0

; 101  : 
; 102  : 	if (!Send(sizeof(MatrixCardPacket), &MatrixCardPacket))

  0002d	8d 45 f0	 lea	 eax, DWORD PTR _MatrixCardPacket$[ebp]
  00030	8b ce		 mov	 ecx, esi
  00032	50		 push	 eax
  00033	6a 0a		 push	 10			; 0000000aH
  00035	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0003a	84 c0		 test	 al, al
  0003c	75 20		 jne	 SHORT $LN2@SendChinaM

; 103  : 	{
; 104  : 		Tracen("SendLogin Error");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
  00043	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00048	83 c4 04	 add	 esp, 4

; 105  : 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 112  : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN2@SendChinaM:

; 106  : 	}
; 107  : 
; 108  : 	CPythonNetworkStream::Instance().SetWaitFlag();

  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00064	e8 00 00 00 00	 call	 ?SetWaitFlag@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetWaitFlag

; 109  : 	m_isWaitKey = TRUE;
; 110  : 
; 111  : 	return SendSequence();

  00069	8b ce		 mov	 ecx, esi
  0006b	c7 86 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+208], 1
  00075	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence

; 112  : }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	33 cd		 xor	 ecx, ebp
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ENDP ; CAccountConnector::SendChinaMatrixCardPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?Process@CAccountConnector@@QAEXXZ
_TEXT	SEGMENT
?Process@CAccountConnector@@QAEXXZ PROC			; CAccountConnector::Process, COMDAT
; _this$ = ecx

; 115  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 116  : 	CNetworkStream::Process();

  00003	e8 00 00 00 00	 call	 ?Process@CNetworkStream@@QAEXXZ ; CNetworkStream::Process

; 117  : 
; 118  : 	if (!__StateProcess())

  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ?__StateProcess@CAccountConnector@@IAE_NXZ ; CAccountConnector::__StateProcess
  0000f	84 c0		 test	 al, al
  00011	75 0d		 jne	 SHORT $LN2@Process

; 119  : 	{
; 120  : 		__OfflineState_Set();

  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 122  : 	}
; 123  : }

  0001a	5e		 pop	 esi

; 121  : 		Disconnect();

  0001b	e9 00 00 00 00	 jmp	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect
$LN2@Process:

; 122  : 	}
; 123  : }

  00020	5e		 pop	 esi
  00021	c3		 ret	 0
?Process@CAccountConnector@@QAEXXZ ENDP			; CAccountConnector::Process
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__StateProcess@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
?__StateProcess@CAccountConnector@@IAE_NXZ PROC		; CAccountConnector::__StateProcess, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 127  : 	switch (m_eState)

  00006	8b 81 80 00 00
	00		 mov	 eax, DWORD PTR [ecx+128]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	74 14		 je	 SHORT $LN4@StateProce
  00011	83 e8 01	 sub	 eax, 1
  00014	74 06		 je	 SHORT $LN5@StateProce

; 134  : 			break;
; 135  : 	}
; 136  : 
; 137  : 	return true;

  00016	b0 01		 mov	 al, 1

; 138  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN5@StateProce:

; 131  : 			break;
; 132  : 		case STATE_AUTH:
; 133  : 			return __AuthState_Process();

  0001c	e8 00 00 00 00	 call	 ?__AuthState_Process@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_Process

; 138  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
$LN4@StateProce:

; 128  : 	{
; 129  : 		case STATE_HANDSHAKE:
; 130  : 			return __HandshakeState_Process();

  00025	e8 00 00 00 00	 call	 ?__HandshakeState_Process@CAccountConnector@@IAE_NXZ ; CAccountConnector::__HandshakeState_Process

; 138  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?__StateProcess@CAccountConnector@@IAE_NXZ ENDP		; CAccountConnector::__StateProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__HandshakeState_Process@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
?__HandshakeState_Process@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__HandshakeState_Process, COMDAT
; _this$ = ecx

; 141  : {

  00000	56		 push	 esi

; 142  : 	if (!__AnalyzePacket(HEADER_GC_PHASE, sizeof(TPacketGCPhase), &CAccountConnector::__AuthState_RecvPhase))

  00001	6a 00		 push	 0
  00003	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPhase
  00008	6a 02		 push	 2
  0000a	68 fd 00 00 00	 push	 253			; 000000fdH
  0000f	8b f1		 mov	 esi, ecx
  00011	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00016	84 c0		 test	 al, al
  00018	0f 84 95 00 00
	00		 je	 $LN10@HandshakeS

; 143  : 		return false;
; 144  : 
; 145  : 	if (!__AnalyzePacket(HEADER_GC_HANDSHAKE, sizeof(TPacketGCHandshake), &CAccountConnector::__AuthState_RecvHandshake))

  0001e	6a 00		 push	 0
  00020	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvHandshake
  00025	6a 0d		 push	 13			; 0000000dH
  00027	68 ff 00 00 00	 push	 255			; 000000ffH
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00033	84 c0		 test	 al, al
  00035	74 7c		 je	 SHORT $LN10@HandshakeS

; 146  : 		return false;
; 147  : 
; 148  : 	if (!__AnalyzePacket(HEADER_GC_PING, sizeof(TPacketGCPing), &CAccountConnector::__AuthState_RecvPing))

  00037	6a 00		 push	 0
  00039	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPing
  0003e	6a 01		 push	 1
  00040	6a 2c		 push	 44			; 0000002cH
  00042	8b ce		 mov	 ecx, esi
  00044	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00049	84 c0		 test	 al, al
  0004b	74 66		 je	 SHORT $LN10@HandshakeS

; 149  : 		return false;
; 150  : 
; 151  : 	//  TODO :      data serialize & deserialize   .
; 152  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_KEYS, &CAccountConnector::__AuthState_RecvHybridCryptKeys))

  0004d	6a 00		 push	 0
  0004f	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptKeys
  00054	68 98 00 00 00	 push	 152			; 00000098H
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  00060	84 c0		 test	 al, al
  00062	74 4f		 je	 SHORT $LN10@HandshakeS

; 153  : 		return false;
; 154  : 
; 155  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_SDB, &CAccountConnector::__AuthState_RecvHybridCryptSDB))

  00064	6a 00		 push	 0
  00066	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptSDB
  0006b	68 99 00 00 00	 push	 153			; 00000099H
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  00077	84 c0		 test	 al, al
  00079	74 38		 je	 SHORT $LN10@HandshakeS

; 156  : 		return false;
; 157  : 
; 158  : #ifdef _IMPROVED_PACKET_ENCRYPTION_
; 159  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT, sizeof(TPacketKeyAgreement), &CAccountConnector::__AuthState_RecvKeyAgreement))

  0007b	6a 00		 push	 0
  0007d	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreement
  00082	68 05 01 00 00	 push	 261			; 00000105H
  00087	68 fb 00 00 00	 push	 251			; 000000fbH
  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00093	84 c0		 test	 al, al
  00095	74 1c		 je	 SHORT $LN10@HandshakeS

; 160  : 		return false;
; 161  : 
; 162  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT_COMPLETED, sizeof(TPacketKeyAgreementCompleted), &CAccountConnector::__AuthState_RecvKeyAgreementCompleted))

  00097	6a 00		 push	 0
  00099	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
  0009e	6a 04		 push	 4
  000a0	68 fa 00 00 00	 push	 250			; 000000faH
  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  000ac	84 c0		 test	 al, al
  000ae	0f 95 c0	 setne	 al

; 164  : #endif
; 165  : 
; 166  : 	return true;
; 167  : }

  000b1	5e		 pop	 esi
  000b2	c3		 ret	 0
$LN10@HandshakeS:

; 163  : 		return false;

  000b3	32 c0		 xor	 al, al

; 164  : #endif
; 165  : 
; 166  : 	return true;
; 167  : }

  000b5	5e		 pop	 esi
  000b6	c3		 ret	 0
?__HandshakeState_Process@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__HandshakeState_Process
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_Process@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
?__AuthState_Process@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_Process, COMDAT
; _this$ = ecx

; 170  : {

  00000	56		 push	 esi

; 171  : 	if (!__AnalyzePacket(0, sizeof(BYTE), &CAccountConnector::__AuthState_RecvEmpty))

  00001	6a 00		 push	 0
  00003	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvEmpty
  00008	6a 01		 push	 1
  0000a	6a 00		 push	 0
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00013	84 c0		 test	 al, al
  00015	0f 84 65 01 00
	00		 je	 $LN15@AuthState_

; 172  : 		return true;
; 173  : 
; 174  : 	if (!__AnalyzePacket(HEADER_GC_PHASE, sizeof(TPacketGCPhase), &CAccountConnector::__AuthState_RecvPhase))

  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPhase
  00022	6a 02		 push	 2
  00024	68 fd 00 00 00	 push	 253			; 000000fdH
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00030	84 c0		 test	 al, al
  00032	0f 84 44 01 00
	00		 je	 $LN17@AuthState_

; 175  : 		return false;
; 176  : 
; 177  : 	if (!__AnalyzePacket(HEADER_GC_PING, sizeof(TPacketGCPing), &CAccountConnector::__AuthState_RecvPing))

  00038	6a 00		 push	 0
  0003a	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPing
  0003f	6a 01		 push	 1
  00041	6a 2c		 push	 44			; 0000002cH
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0004a	84 c0		 test	 al, al
  0004c	0f 84 2a 01 00
	00		 je	 $LN17@AuthState_

; 178  : 		return false;
; 179  : 
; 180  : 	if (!__AnalyzePacket(HEADER_GC_AUTH_SUCCESS, sizeof(TPacketGCAuthSuccess), &CAccountConnector::__AuthState_RecvAuthSuccess))

  00052	6a 00		 push	 0
  00054	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthSuccess
  00059	6a 06		 push	 6
  0005b	68 96 00 00 00	 push	 150			; 00000096H
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00067	84 c0		 test	 al, al
  00069	0f 84 11 01 00
	00		 je	 $LN15@AuthState_

; 181  : 		return true;
; 182  : 
; 183  : #ifdef USE_OPENID
; 184  : 	if (!__AnalyzePacket(HEADER_GC_AUTH_SUCCESS_OPENID, sizeof(TPacketGCAuthSuccess), &CAccountConnector::__AuthState_RecvAuthSuccess_OpenID))
; 185  : 		return true;
; 186  : #endif /* USE_OPENID */
; 187  : 
; 188  : 	if (!__AnalyzePacket(HEADER_GC_LOGIN_FAILURE, sizeof(TPacketGCAuthSuccess), &CAccountConnector::__AuthState_RecvAuthFailure))

  0006f	6a 00		 push	 0
  00071	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthFailure
  00076	6a 06		 push	 6
  00078	6a 07		 push	 7
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00081	84 c0		 test	 al, al
  00083	0f 84 f7 00 00
	00		 je	 $LN15@AuthState_

; 189  : 		return true;
; 190  : 
; 191  : 	if (!__AnalyzePacket(HEADER_GC_CHINA_MATRIX_CARD, sizeof(TPacketGCChinaMatrixCard), &CAccountConnector::__AuthState_RecvChinaMatrixCard))

  00089	6a 00		 push	 0
  0008b	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvChinaMatrixCard
  00090	6a 09		 push	 9
  00092	6a 74		 push	 116			; 00000074H
  00094	8b ce		 mov	 ecx, esi
  00096	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0009b	84 c0		 test	 al, al
  0009d	0f 84 dd 00 00
	00		 je	 $LN15@AuthState_

; 192  : 		return true;
; 193  : 
; 194  : 	if (!__AnalyzePacket(HEADER_GC_RUNUP_MATRIX_QUIZ, sizeof(TPacketGCRunupMatrixQuiz), &CAccountConnector::__AuthState_RecvRunupMatrixQuiz))

  000a3	6a 00		 push	 0
  000a5	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz
  000aa	6a 0a		 push	 10			; 0000000aH
  000ac	68 c9 00 00 00	 push	 201			; 000000c9H
  000b1	8b ce		 mov	 ecx, esi
  000b3	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  000b8	84 c0		 test	 al, al
  000ba	0f 84 c0 00 00
	00		 je	 $LN15@AuthState_

; 195  : 		return true;
; 196  : 
; 197  : 	if (!__AnalyzePacket(HEADER_GC_NEWCIBN_PASSPOD_REQUEST, sizeof(TPacketGCNEWCIBNPasspodRequest), &CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest))

  000c0	6a 00		 push	 0
  000c2	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest
  000c7	6a 01		 push	 1
  000c9	68 ca 00 00 00	 push	 202			; 000000caH
  000ce	8b ce		 mov	 ecx, esi
  000d0	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  000d5	84 c0		 test	 al, al
  000d7	0f 84 a3 00 00
	00		 je	 $LN15@AuthState_

; 198  : 		return true;
; 199  : 
; 200  : 	if (!__AnalyzePacket(HEADER_GC_HANDSHAKE, sizeof(TPacketGCHandshake), &CAccountConnector::__AuthState_RecvHandshake))

  000dd	6a 00		 push	 0
  000df	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvHandshake
  000e4	6a 0d		 push	 13			; 0000000dH
  000e6	68 ff 00 00 00	 push	 255			; 000000ffH
  000eb	8b ce		 mov	 ecx, esi
  000ed	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  000f2	84 c0		 test	 al, al
  000f4	0f 84 82 00 00
	00		 je	 $LN17@AuthState_

; 201  : 		return false;
; 202  : 
; 203  : 	if (!__AnalyzePacket(HEADER_GC_PANAMA_PACK, sizeof(TPacketGCPanamaPack), &CAccountConnector::__AuthState_RecvPanamaPack))

  000fa	6a 00		 push	 0
  000fc	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPanamaPack
  00101	68 21 01 00 00	 push	 289			; 00000121H
  00106	68 97 00 00 00	 push	 151			; 00000097H
  0010b	8b ce		 mov	 ecx, esi
  0010d	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00112	84 c0		 test	 al, al
  00114	74 66		 je	 SHORT $LN17@AuthState_

; 204  : 		return false;
; 205  : 
; 206  : #ifdef _IMPROVED_PACKET_ENCRYPTION_
; 207  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT, sizeof(TPacketKeyAgreement), &CAccountConnector::__AuthState_RecvKeyAgreement))

  00116	6a 00		 push	 0
  00118	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreement
  0011d	68 05 01 00 00	 push	 261			; 00000105H
  00122	68 fb 00 00 00	 push	 251			; 000000fbH
  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0012e	84 c0		 test	 al, al
  00130	74 4a		 je	 SHORT $LN17@AuthState_

; 208  : 		return false;
; 209  : 
; 210  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT_COMPLETED, sizeof(TPacketKeyAgreementCompleted), &CAccountConnector::__AuthState_RecvKeyAgreementCompleted))

  00132	6a 00		 push	 0
  00134	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
  00139	6a 04		 push	 4
  0013b	68 fa 00 00 00	 push	 250			; 000000faH
  00140	8b ce		 mov	 ecx, esi
  00142	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00147	84 c0		 test	 al, al
  00149	74 31		 je	 SHORT $LN17@AuthState_

; 211  : 		return false;
; 212  : #endif
; 213  : 
; 214  : 	//  TODO :      data serialize & deserialize   .
; 215  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_KEYS, &CAccountConnector::__AuthState_RecvHybridCryptKeys))

  0014b	6a 00		 push	 0
  0014d	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptKeys
  00152	68 98 00 00 00	 push	 152			; 00000098H
  00157	8b ce		 mov	 ecx, esi
  00159	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  0015e	84 c0		 test	 al, al
  00160	74 1a		 je	 SHORT $LN17@AuthState_

; 216  : 		return false;
; 217  : 
; 218  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_SDB, &CAccountConnector::__AuthState_RecvHybridCryptSDB))

  00162	6a 00		 push	 0
  00164	68 00 00 00 00	 push	 OFFSET ?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptSDB
  00169	68 99 00 00 00	 push	 153			; 00000099H
  0016e	8b ce		 mov	 ecx, esi
  00170	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  00175	84 c0		 test	 al, al
  00177	0f 95 c0	 setne	 al

; 222  : }

  0017a	5e		 pop	 esi
  0017b	c3		 ret	 0
$LN17@AuthState_:

; 219  : 		return false;

  0017c	32 c0		 xor	 al, al

; 222  : }

  0017e	5e		 pop	 esi
  0017f	c3		 ret	 0
$LN15@AuthState_:

; 220  : 
; 221  : 	return true;

  00180	b0 01		 mov	 al, 1

; 222  : }

  00182	5e		 pop	 esi
  00183	c3		 ret	 0
?__AuthState_Process@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_Process
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_byEmpty$ = -1						; size = 1
?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_RecvEmpty, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 226  : 	BYTE byEmpty;
; 227  : 	Recv(sizeof(BYTE), &byEmpty);

  00004	8d 45 ff	 lea	 eax, DWORD PTR _byEmpty$[ebp]
  00007	50		 push	 eax
  00008	6a 01		 push	 1
  0000a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv

; 228  : 	return true;

  0000f	b0 01		 mov	 al, 1

; 229  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_RecvEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kPacketPhase$ = -76					; size = 2
_LoginPacket$1 = -72					; size = 65
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_RecvPhase, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 233  : 	TPacketGCPhase kPacketPhase;
; 234  : 	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))

  00011	8d 45 b4	 lea	 eax, DWORD PTR _kPacketPhase$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 02		 push	 2
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	0f 84 c4 00 00
	00		 je	 $LN49@AuthState_

; 235  : 		return false;
; 236  : 
; 237  : 	if (kPacketPhase.phase == PHASE_HANDSHAKE)

  00026	8a 45 b5	 mov	 al, BYTE PTR _kPacketPhase$[ebp+1]
  00029	3c 01		 cmp	 al, 1
  0002b	75 16		 jne	 SHORT $LN6@AuthState_

; 238  : 	{
; 239  : 		__HandshakeState_Set();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?__HandshakeState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__HandshakeState_Set
  00034	5e		 pop	 esi

; 348  : 	}
; 349  : 
; 350  : 	return true;
; 351  : }

  00035	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00038	33 cd		 xor	 ecx, ebp
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN6@AuthState_:

; 240  : 	}
; 241  : 	else if (kPacketPhase.phase == PHASE_AUTH)

  00043	3c 0a		 cmp	 al, 10			; 0000000aH
  00045	0f 85 c2 00 00
	00		 jne	 $LN8@AuthState_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0004b	83 be 98 00 00
	00 0f		 cmp	 DWORD PTR [esi+152], 15	; 0000000fH

; 2356 :         return _Mypair._Myval2._Myptr();

  00052	8d 86 84 00 00
	00		 lea	 eax, DWORD PTR [esi+132]
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 318  : 		LoginPacket.header = HEADER_CG_LOGIN3;

  00058	c6 45 b8 6f	 mov	 BYTE PTR _LoginPacket$1[ebp], 111 ; 0000006fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  0005c	76 02		 jbe	 SHORT $LN16@AuthState_

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN16@AuthState_:
  00060	57		 push	 edi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 320  : 		strncpy(LoginPacket.name, m_strID.c_str(), ID_MAX_NUM);

  00061	6a 1e		 push	 30			; 0000001eH
  00063	50		 push	 eax
  00064	8d 45 b9	 lea	 eax, DWORD PTR _LoginPacket$1[ebp+1]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _strncpy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

  00070	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]

; 453  :         return _Myres > _Small_string_capacity;

  00076	83 be b0 00 00
	00 0f		 cmp	 DWORD PTR [esi+176], 15	; 0000000fH

; 445  :         if (_Large_mode_engaged()) {

  0007d	76 06		 jbe	 SHORT $LN26@AuthState_

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  0007f	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
$LN26@AuthState_:
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 321  : 		strncpy(LoginPacket.pwd, m_strPassword.c_str(), PASS_MAX_NUM);

  00085	6a 10		 push	 16			; 00000010H
  00087	50		 push	 eax
  00088	8d 45 d8	 lea	 eax, DWORD PTR _LoginPacket$1[ebp+32]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _strncpy
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 322  : 		LoginPacket.name[ID_MAX_NUM] = '\0';

  00094	c6 45 d7 00	 mov	 BYTE PTR _LoginPacket$1[ebp+31], 0

; 323  : 		LoginPacket.pwd[PASS_MAX_NUM] = '\0';
; 324  : 
; 325  : 		//       ,     
; 326  : 		ClearLoginInfo();

  00098	8b ce		 mov	 ecx, esi
  0009a	c6 45 e8 00	 mov	 BYTE PTR _LoginPacket$1[ebp+48], 0
  0009e	e8 00 00 00 00	 call	 ?ClearLoginInfo@CAccountConnector@@QAEXXZ ; CAccountConnector::ClearLoginInfo

; 327  : 		CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 328  : 		rkNetStream.ClearLoginInfo();

  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  000a9	e8 00 00 00 00	 call	 ?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ClearLoginInfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000ae	6a 00		 push	 0
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000b5	8d 8e 9c 00 00
	00		 lea	 ecx, DWORD PTR [esi+156]
  000bb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 321  : 		strncpy(LoginPacket.pwd, m_strPassword.c_str(), PASS_MAX_NUM);

  000c0	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ?g_adwEncryptKey@@3PAKA

; 329  : 
; 330  : 		m_strPassword = "";
; 331  : 
; 332  : 		for (DWORD i = 0; i < 4; ++i)
; 333  : 			LoginPacket.adwClientKey[i] = g_adwEncryptKey[i];
; 334  : 
; 335  : 		if (!Send(sizeof(LoginPacket), &LoginPacket))

  000c7	8d 45 b8	 lea	 eax, DWORD PTR _LoginPacket$1[ebp]
  000ca	8b ce		 mov	 ecx, esi
  000cc	50		 push	 eax
  000cd	6a 41		 push	 65			; 00000041H
  000cf	0f 11 45 e9	 movups	 XMMWORD PTR _LoginPacket$1[ebp+49], xmm0
  000d3	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000d8	5f		 pop	 edi
  000d9	84 c0		 test	 al, al
  000db	75 1e		 jne	 SHORT $LN9@AuthState_

; 336  : 		{
; 337  : 			Tracen(" CAccountConnector::__AuthState_RecvPhase - SendLogin3 Error");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@
  000e2	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  000e7	83 c4 04	 add	 esp, 4
$LN49@AuthState_:

; 348  : 	}
; 349  : 
; 350  : 	return true;
; 351  : }

  000ea	32 c0		 xor	 al, al
  000ec	5e		 pop	 esi
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
$LN9@AuthState_:

; 338  : 			return false;
; 339  : 		}
; 340  : 
; 341  : 		if (!SendSequence())

  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00102	84 c0		 test	 al, al
  00104	74 e4		 je	 SHORT $LN49@AuthState_

; 342  : 		{
; 343  : 			return false;
; 344  : 		}
; 345  : #endif /* USE_OPENID */
; 346  : 
; 347  : 		__AuthState_Set();

  00106	8b ce		 mov	 ecx, esi
  00108	e8 00 00 00 00	 call	 ?__AuthState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__AuthState_Set
$LN8@AuthState_:

; 348  : 	}
; 349  : 
; 350  : 	return true;
; 351  : }

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	b0 01		 mov	 al, 1
  00112	33 cd		 xor	 ecx, ebp
  00114	5e		 pop	 esi
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_RecvPhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kPacketHandshake$ = -20				; size = 13
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvHandshake, COMDAT
; _this$ = ecx

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 355  : 	TPacketGCHandshake kPacketHandshake;
; 356  : 	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))

  00011	8d 45 ec	 lea	 eax, DWORD PTR _kPacketHandshake$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 0d		 push	 13			; 0000000dH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	74 5b		 je	 SHORT $LN7@AuthState_

; 357  : 		return false;
; 358  : 
; 359  : 	// HandShake
; 360  : 	{
; 361  : 		Tracenf("HANDSHAKE RECV %u %d", kPacketHandshake.dwTime, kPacketHandshake.lDelta);

  00022	ff 75 f5	 push	 DWORD PTR _kPacketHandshake$[ebp+9]
  00025	ff 75 f1	 push	 DWORD PTR _kPacketHandshake$[ebp+5]
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@
  0002d	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf

; 362  : 
; 363  : 		ELTimer_SetServerMSec(kPacketHandshake.dwTime+ kPacketHandshake.lDelta);

  00032	8b 45 f1	 mov	 eax, DWORD PTR _kPacketHandshake$[ebp+5]
  00035	03 45 f5	 add	 eax, DWORD PTR _kPacketHandshake$[ebp+9]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?ELTimer_SetServerMSec@@YAXK@Z ; ELTimer_SetServerMSec

; 364  : 
; 365  : 		//DWORD dwBaseServerTime = kPacketHandshake.dwTime+ kPacketHandshake.lDelta;
; 366  : 		//DWORD dwBaseClientTime = ELTimer_GetMSec();
; 367  : 
; 368  : 		kPacketHandshake.dwTime = kPacketHandshake.dwTime + kPacketHandshake.lDelta + kPacketHandshake.lDelta;

  0003e	8b 4d f5	 mov	 ecx, DWORD PTR _kPacketHandshake$[ebp+9]
  00041	8b 45 f1	 mov	 eax, DWORD PTR _kPacketHandshake$[ebp+5]

; 369  : 		kPacketHandshake.lDelta = 0;

  00044	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _kPacketHandshake$[ebp+9], 0
  0004b	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]

; 370  : 
; 371  : 		Tracenf("HANDSHAKE SEND %u", kPacketHandshake.dwTime);

  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@
  00054	89 45 f1	 mov	 DWORD PTR _kPacketHandshake$[ebp+5], eax
  00057	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0005c	83 c4 18	 add	 esp, 24			; 00000018H

; 372  : 
; 373  : 		if (!Send(sizeof(kPacketHandshake), &kPacketHandshake))

  0005f	8d 45 ec	 lea	 eax, DWORD PTR _kPacketHandshake$[ebp]
  00062	8b ce		 mov	 ecx, esi
  00064	50		 push	 eax
  00065	6a 0d		 push	 13			; 0000000dH
  00067	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0006c	84 c0		 test	 al, al
  0006e	75 1e		 jne	 SHORT $LN3@AuthState_

; 374  : 		{
; 375  : 			Tracen(" CAccountConnector::__AuthState_RecvHandshake - SendHandshake Error");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@
  00075	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0007a	83 c4 04	 add	 esp, 4
$LN7@AuthState_:

; 376  : 			return false;
; 377  : 		}
; 378  : 	}
; 379  : 
; 380  : 	return true;
; 381  : }

  0007d	32 c0		 xor	 al, al
  0007f	5e		 pop	 esi
  00080	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00083	33 cd		 xor	 ecx, ebp
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN3@AuthState_:
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	b0 01		 mov	 al, 1
  00093	33 cd		 xor	 ecx, ebp
  00095	5e		 pop	 esi
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvHandshake
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kPacket$ = -296					; size = 289
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvPanamaPack, COMDAT
; _this$ = ecx

; 384  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 385  : 	TPacketGCPanamaPack kPacket;
; 386  : 
; 387  : 	if (!Recv(sizeof(TPacketGCPanamaPack), &kPacket))

  00013	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _kPacket$[ebp]
  00019	50		 push	 eax
  0001a	68 21 01 00 00	 push	 289			; 00000121H
  0001f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00024	84 c0		 test	 al, al
  00026	75 0e		 jne	 SHORT $LN2@AuthState_

; 391  : 	return true;
; 392  : }

  00028	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002b	33 cd		 xor	 ecx, ebp
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN2@AuthState_:

; 388  : 		return false;
; 389  : 
; 390  : 	CEterPackManager::instance().RegisterPack(kPacket.szPackName, "*", kPacket.abIV);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  0003c	8d 45 d9	 lea	 eax, DWORD PTR _kPacket$[ebp+257]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_01NBENCBCI@?$CK@
  00045	8d 85 d9 fe ff
	ff		 lea	 eax, DWORD PTR _kPacket$[ebp+1]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?RegisterPack@CEterPackManager@@QAE_NPBD0PBE@Z ; CEterPackManager::RegisterPack

; 391  : 	return true;
; 392  : }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	b0 01		 mov	 al, 1
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvPanamaPack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
_TEXT	SEGMENT
_kPacket$ = -24						; size = 11
__$EHRec$ = -12						; size = 12
_iTotalSize$ = 8					; size = 4
?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z PROC ; CAccountConnector::__AuthState_RecvHybridCryptKeys, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 396  : 	int iFixedHeaderSize = TPacketGCHybridCryptKeys::GetFixedHeaderSize();
; 397  : 	
; 398  : 	TPacketGCHybridCryptKeys kPacket(iTotalSize-iFixedHeaderSize);

  00029	8b 45 08	 mov	 eax, DWORD PTR _iTotalSize$[ebp]
  0002c	83 c0 f9	 add	 eax, -7			; fffffff9H
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h

; 2635 : 		m_pStream = new BYTE[iStreamSize];

  0002f	50		 push	 eax
  00030	89 45 eb	 mov	 DWORD PTR _kPacket$[ebp+3], eax
  00033	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 ef	 mov	 DWORD PTR _kPacket$[ebp+7], eax
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 400  : 	if (!Recv(iFixedHeaderSize, &kPacket))

  0003e	8d 45 e8	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	50		 push	 eax
  00049	6a 07		 push	 7
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00052	84 c0		 test	 al, al
  00054	74 23		 je	 SHORT $LN6@AuthState_

; 401  : 		return false;
; 402  : 
; 403  : 	if (!Recv(kPacket.iKeyStreamLen, kPacket.m_pStream))

  00056	ff 75 ef	 push	 DWORD PTR _kPacket$[ebp+7]
  00059	8b ce		 mov	 ecx, esi
  0005b	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+3]
  0005e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00063	84 c0		 test	 al, al
  00065	74 12		 je	 SHORT $LN6@AuthState_

; 404  : 		return false;
; 405  : 
; 406  : 	CEterPackManager::Instance().RetrieveHybridCryptPackKeys( kPacket.m_pStream ); 

  00067	ff 75 ef	 push	 DWORD PTR _kPacket$[ebp+7]
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00070	e8 00 00 00 00	 call	 ?RetrieveHybridCryptPackKeys@CEterPackManager@@QAEXPBE@Z ; CEterPackManager::RetrieveHybridCryptPackKeys

; 407  : 	return true;

  00075	b3 01		 mov	 bl, 1
  00077	eb 02		 jmp	 SHORT $LN7@AuthState_
$LN6@AuthState_:
  00079	32 db		 xor	 bl, bl
$LN7@AuthState_:
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h

; 2639 : 		if( m_pStream )

  0007b	8b 45 ef	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  0007e	85 c0		 test	 eax, eax
  00080	74 09		 je	 SHORT $LN14@AuthState_

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00088	83 c4 04	 add	 esp, 4
$LN14@AuthState_:
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 408  : }

  0008b	8a c3		 mov	 al, bl
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPacketGCHybridCryptKeys@@QAE@XZ ; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ENDP ; CAccountConnector::__AuthState_RecvHybridCryptKeys
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
_TEXT	SEGMENT
_kPacket$ = -24						; size = 11
__$EHRec$ = -12						; size = 12
_iTotalSize$ = 8					; size = 4
?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z PROC ; CAccountConnector::__AuthState_RecvHybridCryptSDB, COMDAT
; _this$ = ecx

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 412  : 	int iFixedHeaderSize = TPacketGCHybridSDB::GetFixedHeaderSize();
; 413  : 
; 414  : 	TPacketGCHybridSDB kPacket(iTotalSize-iFixedHeaderSize);

  00029	8b 45 08	 mov	 eax, DWORD PTR _iTotalSize$[ebp]
  0002c	83 c0 f9	 add	 eax, -7			; fffffff9H
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h

; 2666 : 		m_pStream = new BYTE[iStreamSize];

  0002f	50		 push	 eax
  00030	89 45 eb	 mov	 DWORD PTR _kPacket$[ebp+3], eax
  00033	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 ef	 mov	 DWORD PTR _kPacket$[ebp+7], eax
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 416  : 	if (!Recv(iFixedHeaderSize, &kPacket))

  0003e	8d 45 e8	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	50		 push	 eax
  00049	6a 07		 push	 7
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00052	84 c0		 test	 al, al
  00054	74 23		 je	 SHORT $LN6@AuthState_

; 417  : 		return false;
; 418  : 
; 419  : 	if (!Recv(kPacket.iSDBStreamLen, kPacket.m_pStream))

  00056	ff 75 ef	 push	 DWORD PTR _kPacket$[ebp+7]
  00059	8b ce		 mov	 ecx, esi
  0005b	ff 75 eb	 push	 DWORD PTR _kPacket$[ebp+3]
  0005e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00063	84 c0		 test	 al, al
  00065	74 12		 je	 SHORT $LN6@AuthState_

; 420  : 		return false;
; 421  : 
; 422  : 	CEterPackManager::Instance().RetrieveHybridCryptPackSDB( kPacket.m_pStream ); 

  00067	ff 75 ef	 push	 DWORD PTR _kPacket$[ebp+7]
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00070	e8 00 00 00 00	 call	 ?RetrieveHybridCryptPackSDB@CEterPackManager@@QAEXPBE@Z ; CEterPackManager::RetrieveHybridCryptPackSDB

; 423  : 	return true;

  00075	b3 01		 mov	 bl, 1
  00077	eb 02		 jmp	 SHORT $LN7@AuthState_
$LN6@AuthState_:
  00079	32 db		 xor	 bl, bl
$LN7@AuthState_:
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\Packet.h

; 2670 : 		delete[] m_pStream;

  0007b	ff 75 ef	 push	 DWORD PTR _kPacket$[ebp+7]
  0007e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00083	83 c4 04	 add	 esp, 4
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 423  : 	return true;

  00086	8a c3		 mov	 al, bl

; 424  : }

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPacketGCHybridSDB@@QAE@XZ ; SPacketGCHybridSDB::~SPacketGCHybridSDB
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ENDP ; CAccountConnector::__AuthState_RecvHybridCryptSDB
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kPacketPing$ = -1					; size = 1
?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_RecvPing, COMDAT
; _this$ = ecx

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 429  : 	TPacketGCPing kPacketPing;
; 430  : 	if (!Recv(sizeof(kPacketPing), &kPacketPing))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _kPacketPing$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN2@AuthState_
  00016	5e		 pop	 esi

; 436  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN2@AuthState_:

; 431  : 		return false;
; 432  : 
; 433  : 	__AuthState_SendPong();

  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?__AuthState_SendPong@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_SendPong

; 434  : 
; 435  : 	return true;

  00022	b0 01		 mov	 al, 1
  00024	5e		 pop	 esi

; 436  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_RecvPing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_SendPong@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kPacketPong$ = -1					; size = 1
?__AuthState_SendPong@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_SendPong, COMDAT
; _this$ = ecx

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 440  : 	TPacketCGPong kPacketPong;
; 441  : 	kPacketPong.bHeader = HEADER_CG_PONG;
; 442  : 	if (!Send(sizeof(kPacketPong), &kPacketPong))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _kPacketPong$[ebp]
  00008	c6 45 ff fe	 mov	 BYTE PTR _kPacketPong$[ebp], 254 ; 000000feH
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	8b f1		 mov	 esi, ecx
  00011	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00016	84 c0		 test	 al, al
  00018	75 05		 jne	 SHORT $LN2@AuthState_
  0001a	5e		 pop	 esi

; 449  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN2@AuthState_:

; 443  : 		return false;
; 444  : 
; 445  : 	if (IsSecurityMode())

  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 ?IsSecurityMode@CNetworkStream@@QAE_NXZ ; CNetworkStream::IsSecurityMode
  00026	84 c0		 test	 al, al
  00028	74 0c		 je	 SHORT $LN3@AuthState_

; 446  : 		return SendSequence();

  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00031	5e		 pop	 esi

; 449  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@AuthState_:

; 447  : 
; 448  : 	return true;

  00036	b0 01		 mov	 al, 1
  00038	5e		 pop	 esi

; 449  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?__AuthState_SendPong@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_SendPong
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kAuthSuccessPacket$ = -8				; size = 6
?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvAuthSuccess, COMDAT
; _this$ = ecx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 453  : 	TPacketGCAuthSuccess kAuthSuccessPacket;
; 454  : 	if (!Recv(sizeof(kAuthSuccessPacket), &kAuthSuccessPacket))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _kAuthSuccessPacket$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	6a 06		 push	 6
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00014	84 c0		 test	 al, al
  00016	75 05		 jne	 SHORT $LN2@AuthState_
  00018	5e		 pop	 esi

; 476  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN2@AuthState_:

; 455  : 		return false;
; 456  : 
; 457  : 	if (!kAuthSuccessPacket.bResult)

  0001d	80 7d fd 00	 cmp	 BYTE PTR _kAuthSuccessPacket$[ebp+5], 0
  00021	75 2f		 jne	 SHORT $LN3@AuthState_

; 458  : 	{
; 459  : 		if (m_poHandler)

  00023	83 be d4 00 00
	00 00		 cmp	 DWORD PTR [esi+212], 0
  0002a	74 79		 je	 SHORT $LN4@AuthState_

; 460  : 			PyCallClassMemberFunc(m_poHandler, "OnLoginFailure", Py_BuildValue("(s)", "BESAMEKEY"));

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_09FJACDEDF@BESAMEKEY@
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OOEAIINI@OnLoginFailure@
  00042	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  00048	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0004d	83 c4 14	 add	 esp, 20			; 00000014H

; 461  : 	}

  00050	eb 53		 jmp	 SHORT $LN4@AuthState_
$LN3@AuthState_:

; 462  : 	else
; 463  : 	{
; 464  : 		DWORD dwPanamaKey = kAuthSuccessPacket.dwLoginKey ^ g_adwEncryptKey[0] ^ g_adwEncryptKey[1] ^ g_adwEncryptKey[2] ^ g_adwEncryptKey[3];

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_adwEncryptKey@@3PAKA
  00057	33 05 04 00 00
	00		 xor	 eax, DWORD PTR ?g_adwEncryptKey@@3PAKA+4
  0005d	33 05 08 00 00
	00		 xor	 eax, DWORD PTR ?g_adwEncryptKey@@3PAKA+8
  00063	33 05 0c 00 00
	00		 xor	 eax, DWORD PTR ?g_adwEncryptKey@@3PAKA+12
  00069	33 45 f9	 xor	 eax, DWORD PTR _kAuthSuccessPacket$[ebp+1]

; 465  : 		CEterPackManager::instance().DecryptPackIV(dwPanamaKey);

  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?DecryptPackIV@CEterPackManager@@QAE_NK@Z ; CEterPackManager::DecryptPackIV

; 466  : 
; 467  : 		CPythonNetworkStream & rkNet = CPythonNetworkStream::Instance();
; 468  : 		rkNet.SetLoginKey(kAuthSuccessPacket.dwLoginKey);

  00078	ff 75 f9	 push	 DWORD PTR _kAuthSuccessPacket$[ebp+1]
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00081	e8 00 00 00 00	 call	 ?SetLoginKey@CPythonNetworkStream@@QAEXK@Z ; CPythonNetworkStream::SetLoginKey
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00086	83 be c8 00 00
	00 0f		 cmp	 DWORD PTR [esi+200], 15	; 0000000fH

; 2356 :         return _Mypair._Myval2._Myptr();

  0008d	8d 86 b4 00 00
	00		 lea	 eax, DWORD PTR [esi+180]

; 445  :         if (_Large_mode_engaged()) {

  00093	76 02		 jbe	 SHORT $LN13@AuthState_

; 446  :             _Result = _Unfancy(_Bx._Ptr);

  00095	8b 00		 mov	 eax, DWORD PTR [eax]
$LN13@AuthState_:
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 469  : 		rkNet.Connect(m_strAddr.c_str(), m_iPort);

  00097	6a 03		 push	 3
  00099	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect
$LN4@AuthState_:

; 470  : 	}
; 471  : 
; 472  : 	Disconnect();

  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect

; 473  : 	__OfflineState_Set();

  000ac	8b ce		 mov	 ecx, esi
  000ae	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 474  : 
; 475  : 	return true;

  000b3	b0 01		 mov	 al, 1
  000b5	5e		 pop	 esi

; 476  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvAuthSuccess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_packet_failure$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvAuthFailure, COMDAT
; _this$ = ecx

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 511  : 	TPacketGCLoginFailure packet_failure;
; 512  : 	if (!Recv(sizeof(TPacketGCLoginFailure), &packet_failure))

  00011	8d 45 f0	 lea	 eax, DWORD PTR _packet_failure$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 0a		 push	 10			; 0000000aH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN2@AuthState_
  00022	5e		 pop	 esi

; 517  : 
; 518  : //	__OfflineState_Set();
; 519  : 
; 520  : 	return true;
; 521  : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@AuthState_:

; 513  : 		return false;
; 514  : 
; 515  : 	if (m_poHandler)

  00031	83 be d4 00 00
	00 00		 cmp	 DWORD PTR [esi+212], 0
  00038	74 23		 je	 SHORT $LN3@AuthState_

; 516  : 		PyCallClassMemberFunc(m_poHandler, "OnLoginFailure", Py_BuildValue("(s)", packet_failure.szStatus));

  0003a	8d 45 f1	 lea	 eax, DWORD PTR _packet_failure$[ebp+1]
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OOEAIINI@OnLoginFailure@
  0004f	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  00055	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0005a	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@AuthState_:

; 517  : 
; 518  : //	__OfflineState_Set();
; 519  : 
; 520  : 	return true;
; 521  : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	b0 01		 mov	 al, 1
  00062	33 cd		 xor	 ecx, ebp
  00064	5e		 pop	 esi
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvAuthFailure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kMatrixQuizPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz, COMDAT
; _this$ = ecx

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 525  : 	TPacketGCRunupMatrixQuiz kMatrixQuizPacket;
; 526  : 	if (!Recv(sizeof(TPacketGCRunupMatrixQuiz), &kMatrixQuizPacket))

  00011	8d 45 f0	 lea	 eax, DWORD PTR _kMatrixQuizPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 0a		 push	 10			; 0000000aH
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN2@AuthState_
  00022	5e		 pop	 esi

; 530  : 	return true;
; 531  : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@AuthState_:

; 527  : 		return false;
; 528  : 
; 529  : 	PyCallClassMemberFunc(m_poHandler, "BINARY_OnRunupMatrixQuiz", Py_BuildValue("(s)", kMatrixQuizPacket.szQuiz));	

  00031	8d 45 f1	 lea	 eax, DWORD PTR _kMatrixQuizPacket$[ebp+1]
  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@
  00046	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  0004c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 530  : 	return true;
; 531  : }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	83 c4 14	 add	 esp, 20			; 00000014H
  00057	33 cd		 xor	 ecx, ebp
  00059	b0 01		 mov	 al, 1
  0005b	5e		 pop	 esi
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kRequestPacket$ = -1					; size = 1
?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 535  : 	TPacketGCNEWCIBNPasspodRequest kRequestPacket;
; 536  : 	if (!Recv(sizeof(kRequestPacket), &kRequestPacket))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _kRequestPacket$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN2@AuthState_
  00016	5e		 pop	 esi

; 541  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN2@AuthState_:

; 537  : 		return false;
; 538  : 
; 539  : 	PyCallClassMemberFunc(m_poHandler, "BINARY_OnNEWCIBNPasspodRequest", Py_BuildValue("()"));	

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@
  0002c	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  00032	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 540  : 	return true;

  0003a	b0 01		 mov	 al, 1
  0003c	5e		 pop	 esi

; 541  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kMatrixCardPacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvChinaMatrixCard, COMDAT
; _this$ = ecx

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 548  : 	TPacketGCChinaMatrixCard kMatrixCardPacket;
; 549  : 	if (!Recv(sizeof(TPacketGCChinaMatrixCard), &kMatrixCardPacket))

  00011	8d 45 f0	 lea	 eax, DWORD PTR _kMatrixCardPacket$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	50		 push	 eax
  00017	6a 09		 push	 9
  00019	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0001e	84 c0		 test	 al, al
  00020	75 0f		 jne	 SHORT $LN2@AuthState_
  00022	5e		 pop	 esi

; 563  : 	}
; 564  : 
; 565  : 	return true;
; 566  : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@AuthState_:

; 550  : 		return false;
; 551  : 
; 552  : 	if (m_poHandler)

  00031	83 be d4 00 00
	00 00		 cmp	 DWORD PTR [esi+212], 0
  00038	74 59		 je	 SHORT $LN3@AuthState_

; 553  : 	{
; 554  : 		PyObject * pyValue = Py_BuildValue("(iiiiiiii)",	ROW(kMatrixCardPacket.dwRows, 0),

  0003a	8b 4d f5	 mov	 ecx, DWORD PTR _kMatrixCardPacket$[ebp+5]
  0003d	0f b6 c1	 movzx	 eax, cl
  00040	50		 push	 eax
  00041	8b c1		 mov	 eax, ecx
  00043	c1 e8 08	 shr	 eax, 8
  00046	0f b6 c0	 movzx	 eax, al
  00049	50		 push	 eax
  0004a	8b c1		 mov	 eax, ecx
  0004c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0004f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00052	0f b6 c0	 movzx	 eax, al
  00055	50		 push	 eax
  00056	51		 push	 ecx
  00057	8b 4d f1	 mov	 ecx, DWORD PTR _kMatrixCardPacket$[ebp+1]
  0005a	0f b6 c1	 movzx	 eax, cl
  0005d	50		 push	 eax
  0005e	8b c1		 mov	 eax, ecx
  00060	c1 e8 08	 shr	 eax, 8
  00063	0f b6 c0	 movzx	 eax, al
  00066	50		 push	 eax
  00067	8b c1		 mov	 eax, ecx
  00069	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0006c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0006f	0f b6 c0	 movzx	 eax, al
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue

; 555  : 															ROW(kMatrixCardPacket.dwRows, 1),
; 556  : 															ROW(kMatrixCardPacket.dwRows, 2),
; 557  : 															ROW(kMatrixCardPacket.dwRows, 3),
; 558  : 															COL(kMatrixCardPacket.dwCols, 0),
; 559  : 															COL(kMatrixCardPacket.dwCols, 1),
; 560  : 															COL(kMatrixCardPacket.dwCols, 2),
; 561  : 															COL(kMatrixCardPacket.dwCols, 3));
; 562  : 		PyCallClassMemberFunc(m_poHandler, "OnMatrixCard", pyValue);

  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PIKEFLJP@OnMatrixCard@
  00085	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  0008b	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00090	83 c4 30	 add	 esp, 48			; 00000030H
$LN3@AuthState_:

; 563  : 	}
; 564  : 
; 565  : 	return true;
; 566  : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	b0 01		 mov	 al, 1
  00098	33 cd		 xor	 ecx, ebp
  0009a	5e		 pop	 esi
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvChinaMatrixCard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_dataLength$ = -536					; size = 4
_packet$ = -532						; size = 261
_packetToSend$ = -268					; size = 261
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvKeyAgreement, COMDAT
; _this$ = ecx

; 570  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 571  : 	TPacketKeyAgreement packet;
; 572  : 	if (!Recv(sizeof(packet), &packet))

  00014	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	68 05 01 00 00	 push	 261			; 00000105H
  00022	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00027	84 c0		 test	 al, al
  00029	75 0f		 jne	 SHORT $LN2@AuthState_
  0002b	5e		 pop	 esi

; 611  : }

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002f	33 cd		 xor	 ecx, ebp
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN2@AuthState_:

; 573  : 	{
; 574  : 		return false;
; 575  : 	}
; 576  : 
; 577  : 	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);

  0003a	0f b7 85 ef fd
	ff ff		 movzx	 eax, WORD PTR _packet$[ebp+3]
  00041	57		 push	 edi
  00042	50		 push	 eax
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@
  00048	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0004d	83 c4 08	 add	 esp, 8

; 578  : 
; 579  : 	TPacketKeyAgreement packetToSend;
; 580  : 	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;

  00050	c7 85 e8 fd ff
	ff 00 01 00 00	 mov	 DWORD PTR _dataLength$[ebp], 256 ; 00000100H

; 581  : 	size_t agreedLength = Prepare(packetToSend.data, &dataLength);

  0005a	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _dataLength$[ebp]
  00060	8b ce		 mov	 ecx, esi
  00062	50		 push	 eax
  00063	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _packetToSend$[ebp+5]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?Prepare@CNetworkStream@@IAEIPAXPAI@Z ; CNetworkStream::Prepare
  0006f	8b f8		 mov	 edi, eax

; 582  : 	if (agreedLength == 0)

  00071	85 ff		 test	 edi, edi
  00073	0f 84 9b 00 00
	00		 je	 $LN4@AuthState_

; 583  : 	{
; 584  : 		//  
; 585  : 		Disconnect();
; 586  : 		return false;
; 587  : 	}
; 588  : 	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
; 589  : 
; 590  : 	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))

  00079	0f b7 8d ef fd
	ff ff		 movzx	 ecx, WORD PTR _packet$[ebp+3]
  00080	8d 85 f1 fd ff
	ff		 lea	 eax, DWORD PTR _packet$[ebp+5]
  00086	51		 push	 ecx
  00087	0f b7 8d ed fd
	ff ff		 movzx	 ecx, WORD PTR _packet$[ebp+1]
  0008e	50		 push	 eax
  0008f	51		 push	 ecx
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?Activate@CNetworkStream@@IAE_NIPBXI@Z ; CNetworkStream::Activate
  00097	84 c0		 test	 al, al
  00099	74 79		 je	 SHORT $LN4@AuthState_

; 591  : 	{
; 592  : 		// Key agreement ,  
; 593  : 		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;
; 594  : 		packetToSend.wAgreedLength = (WORD)agreedLength;
; 595  : 		packetToSend.wDataLength = (WORD)dataLength;

  0009b	66 8b 85 e8 fd
	ff ff		 mov	 ax, WORD PTR _dataLength$[ebp]

; 596  : 
; 597  : 		if (!Send(sizeof(packetToSend), &packetToSend))

  000a2	8b ce		 mov	 ecx, esi
  000a4	66 89 85 f7 fe
	ff ff		 mov	 WORD PTR _packetToSend$[ebp+3], ax
  000ab	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _packetToSend$[ebp]
  000b1	50		 push	 eax
  000b2	68 05 01 00 00	 push	 261			; 00000105H
  000b7	c6 85 f4 fe ff
	ff fb		 mov	 BYTE PTR _packetToSend$[ebp], 251 ; 000000fbH
  000be	66 89 bd f5 fe
	ff ff		 mov	 WORD PTR _packetToSend$[ebp+1], di
  000c5	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000ca	84 c0		 test	 al, al
  000cc	75 1f		 jne	 SHORT $LN6@AuthState_

; 598  : 		{
; 599  : 			Tracen(" CAccountConnector::__AuthState_RecvKeyAgreement - SendKeyAgreement Error");

  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@
  000d3	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  000d8	83 c4 04	 add	 esp, 4

; 608  : 		return false;

  000db	32 c0		 xor	 al, al
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi

; 611  : }

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
$LN6@AuthState_:

; 600  : 			return false;
; 601  : 		}
; 602  : 		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);

  000ed	0f b7 85 f7 fe
	ff ff		 movzx	 eax, WORD PTR _packetToSend$[ebp+3]
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@
  000fa	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000ff	83 c4 08	 add	 esp, 8

; 609  : 	}
; 610  : 	return true;

  00102	b0 01		 mov	 al, 1
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi

; 611  : }

  00106	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	33 cd		 xor	 ecx, ebp
  0010b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$LN4@AuthState_:

; 603  : 	}
; 604  : 	else
; 605  : 	{
; 606  : 		//   
; 607  : 		Disconnect();

  00114	8b ce		 mov	 ecx, esi
  00116	e8 00 00 00 00	 call	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect

; 611  : }

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	32 c0		 xor	 al, al
  00120	5f		 pop	 edi
  00121	33 cd		 xor	 ecx, ebp
  00123	5e		 pop	 esi
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvKeyAgreement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_packet$ = -4						; size = 4
?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted, COMDAT
; _this$ = ecx

; 614  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 615  : 	TPacketKeyAgreementCompleted packet;
; 616  : 	if (!Recv(sizeof(packet), &packet))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _packet$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 04		 push	 4
  0000d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00012	84 c0		 test	 al, al
  00014	75 05		 jne	 SHORT $LN2@AuthState_
  00016	5e		 pop	 esi

; 626  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN2@AuthState_:

; 617  : 	{
; 618  : 		return false;
; 619  : 	}
; 620  : 
; 621  : 	Tracenf("KEY_AGREEMENT_COMPLETED RECV");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@
  00020	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00025	83 c4 04	 add	 esp, 4

; 622  : 
; 623  : 	ActivateCipher();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?ActivateCipher@CNetworkStream@@IAEXXZ ; CNetworkStream::ActivateCipher

; 624  : 
; 625  : 	return true;

  0002f	b0 01		 mov	 al, 1
  00031	5e		 pop	 esi

; 626  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z
_TEXT	SEGMENT
_bHeader$ = -1						; size = 1
_uHeader$ = 8						; size = 4
_uPacketSize$ = 12					; size = 4
_pfnDispatchPacket$ = 16				; size = 8
?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z PROC ; CAccountConnector::__AnalyzePacket, COMDAT
; _this$ = ecx

; 630  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 631  : 	BYTE bHeader;
; 632  : 	if (!Peek(sizeof(bHeader), &bHeader))

  00005	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00012	84 c0		 test	 al, al
  00014	74 27		 je	 SHORT $LN6@AnalyzePac

; 633  : 		return true;
; 634  : 
; 635  : 	if (bHeader!=uHeader)

  00016	0f b6 45 ff	 movzx	 eax, BYTE PTR _bHeader$[ebp]
  0001a	3b 45 08	 cmp	 eax, DWORD PTR _uHeader$[ebp]
  0001d	75 1e		 jne	 SHORT $LN6@AnalyzePac

; 636  : 		return true;
; 637  : 
; 638  : 	if (!Peek(uPacketSize))

  0001f	ff 75 0c	 push	 DWORD PTR _uPacketSize$[ebp]
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  00029	84 c0		 test	 al, al
  0002b	74 10		 je	 SHORT $LN6@AnalyzePac

; 640  : 
; 641  : 	return (this->*pfnDispatchPacket)();

  0002d	8b 4d 14	 mov	 ecx, DWORD PTR _pfnDispatchPacket$[ebp+4]
  00030	8d 0c 31	 lea	 ecx, DWORD PTR [ecx+esi]
  00033	ff 55 10	 call	 DWORD PTR _pfnDispatchPacket$[ebp]
  00036	5e		 pop	 esi

; 642  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 10 00	 ret	 16			; 00000010H
$LN6@AnalyzePac:

; 639  : 		return true;

  0003d	b0 01		 mov	 al, 1
  0003f	5e		 pop	 esi

; 642  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ENDP ; CAccountConnector::__AnalyzePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z
_TEXT	SEGMENT
_dynamicHeader$ = -8					; size = 3
_bHeader$ = -1						; size = 1
_uHeader$ = 8						; size = 4
_pfnDispatchPacket$ = 12				; size = 8
?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z PROC ; CAccountConnector::__AnalyzeVarSizePacket, COMDAT
; _this$ = ecx

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 646  : 	BYTE bHeader;
; 647  : 	if (!Peek(sizeof(bHeader), &bHeader))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	8b f1		 mov	 esi, ecx
  0000f	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00014	84 c0		 test	 al, al
  00016	74 41		 je	 SHORT $LN7@AnalyzeVar

; 648  : 		return true;
; 649  : 
; 650  : 	if (bHeader!=uHeader)

  00018	0f b6 45 ff	 movzx	 eax, BYTE PTR _bHeader$[ebp]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR _uHeader$[ebp]
  0001f	75 38		 jne	 SHORT $LN7@AnalyzeVar

; 651  : 		return true;
; 652  : 
; 653  : 	TDynamicSizePacketHeader dynamicHeader;
; 654  : 
; 655  : 	if (!Peek(sizeof(dynamicHeader), &dynamicHeader))

  00021	8d 45 f8	 lea	 eax, DWORD PTR _dynamicHeader$[ebp]
  00024	8b ce		 mov	 ecx, esi
  00026	50		 push	 eax
  00027	6a 03		 push	 3
  00029	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  0002e	84 c0		 test	 al, al
  00030	74 27		 je	 SHORT $LN7@AnalyzeVar

; 656  : 		return true;
; 657  : 
; 658  : 	if (!Peek(dynamicHeader.size))

  00032	0f b7 45 f9	 movzx	 eax, WORD PTR _dynamicHeader$[ebp+1]
  00036	8b ce		 mov	 ecx, esi
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  0003e	84 c0		 test	 al, al
  00040	74 17		 je	 SHORT $LN7@AnalyzeVar

; 660  : 
; 661  : 	return (this->*pfnDispatchPacket)(dynamicHeader.size);

  00042	8b 4d 10	 mov	 ecx, DWORD PTR _pfnDispatchPacket$[ebp+4]
  00045	0f b7 45 f9	 movzx	 eax, WORD PTR _dynamicHeader$[ebp+1]
  00049	8b 55 0c	 mov	 edx, DWORD PTR _pfnDispatchPacket$[ebp]
  0004c	50		 push	 eax
  0004d	8d 0c 31	 lea	 ecx, DWORD PTR [ecx+esi]
  00050	ff d2		 call	 edx
  00052	5e		 pop	 esi

; 662  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
$LN7@AnalyzeVar:

; 659  : 		return true;

  00059	b0 01		 mov	 al, 1
  0005b	5e		 pop	 esi

; 662  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ENDP ; CAccountConnector::__AnalyzeVarSizePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__OfflineState_Set@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
?__OfflineState_Set@CAccountConnector@@IAEXXZ PROC	; CAccountConnector::__OfflineState_Set, COMDAT
; _this$ = ecx

; 667  : 	__Inialize();

  00000	e9 00 00 00 00	 jmp	 ?__Inialize@CAccountConnector@@IAEXXZ ; CAccountConnector::__Inialize
?__OfflineState_Set@CAccountConnector@@IAEXXZ ENDP	; CAccountConnector::__OfflineState_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__HandshakeState_Set@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
?__HandshakeState_Set@CAccountConnector@@IAEXXZ PROC	; CAccountConnector::__HandshakeState_Set, COMDAT
; _this$ = ecx

; 672  : 	m_eState=STATE_HANDSHAKE;

  00000	c7 81 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+128], 1

; 673  : }

  0000a	c3		 ret	 0
?__HandshakeState_Set@CAccountConnector@@IAEXXZ ENDP	; CAccountConnector::__HandshakeState_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_Set@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
?__AuthState_Set@CAccountConnector@@IAEXXZ PROC		; CAccountConnector::__AuthState_Set, COMDAT
; _this$ = ecx

; 677  : 	m_eState=STATE_AUTH;

  00000	c7 81 80 00 00
	00 02 00 00 00	 mov	 DWORD PTR [ecx+128], 2

; 678  : }

  0000a	c3		 ret	 0
?__AuthState_Set@CAccountConnector@@IAEXXZ ENDP		; CAccountConnector::__AuthState_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?OnConnectFailure@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
?OnConnectFailure@CAccountConnector@@MAEXXZ PROC	; CAccountConnector::OnConnectFailure, COMDAT
; _this$ = ecx

; 681  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 682  : 	if (m_poHandler)

  00003	83 be d4 00 00
	00 00		 cmp	 DWORD PTR [esi+212], 0
  0000a	74 1f		 je	 SHORT $LN2@OnConnectF

; 683  : 		PyCallClassMemberFunc(m_poHandler, "OnConnectFailure", Py_BuildValue("()"));

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JEKGEMCL@OnConnectFailure@
  0001d	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  00023	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00028	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@OnConnectF:

; 684  : 
; 685  : 	__OfflineState_Set();

  0002b	8b ce		 mov	 ecx, esi
  0002d	5e		 pop	 esi
  0002e	e9 00 00 00 00	 jmp	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set
?OnConnectFailure@CAccountConnector@@MAEXXZ ENDP	; CAccountConnector::OnConnectFailure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?OnConnectSuccess@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
?OnConnectSuccess@CAccountConnector@@MAEXXZ PROC	; CAccountConnector::OnConnectSuccess, COMDAT
; _this$ = ecx

; 690  : 	m_eState = STATE_HANDSHAKE;

  00000	c7 81 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+128], 1

; 691  : }

  0000a	c3		 ret	 0
?OnConnectSuccess@CAccountConnector@@MAEXXZ ENDP	; CAccountConnector::OnConnectSuccess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?OnRemoteDisconnect@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
?OnRemoteDisconnect@CAccountConnector@@MAEXXZ PROC	; CAccountConnector::OnRemoteDisconnect, COMDAT
; _this$ = ecx

; 694  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 695  : 	// Matrix Card Number    close    .
; 696  : 	if (m_isWaitKey)

  00003	83 be d0 00 00
	00 00		 cmp	 DWORD PTR [esi+208], 0
  0000a	74 2a		 je	 SHORT $LN3@OnRemoteDi

; 697  : 	{
; 698  : 		if (m_poHandler)

  0000c	83 be d4 00 00
	00 00		 cmp	 DWORD PTR [esi+212], 0
  00013	74 21		 je	 SHORT $LN3@OnRemoteDi

; 699  : 		{
; 700  : 			PyCallClassMemberFunc(m_poHandler, "OnExit", Py_BuildValue("()"));

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_06NAODFICM@OnExit@
  00026	ff b6 d4 00 00
	00		 push	 DWORD PTR [esi+212]
  0002c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	5e		 pop	 esi

; 706  : }

  00035	c3		 ret	 0
$LN3@OnRemoteDi:
  00036	5e		 pop	 esi

; 701  : 			return;
; 702  : 		}
; 703  : 	}
; 704  : 
; 705  : 	__OfflineState_Set();

  00037	e9 00 00 00 00	 jmp	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set
?OnRemoteDisconnect@CAccountConnector@@MAEXXZ ENDP	; CAccountConnector::OnRemoteDisconnect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?OnDisconnect@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
?OnDisconnect@CAccountConnector@@MAEXXZ PROC		; CAccountConnector::OnDisconnect, COMDAT
; _this$ = ecx

; 710  : 	__OfflineState_Set();

  00000	e9 00 00 00 00	 jmp	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set
?OnDisconnect@CAccountConnector@@MAEXXZ ENDP		; CAccountConnector::OnDisconnect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ?__Inialize@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
?__Inialize@CAccountConnector@@IAEXXZ PROC		; CAccountConnector::__Inialize, COMDAT
; _this$ = ecx

; 726  : 	m_eState=STATE_OFFLINE;

  00000	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], 0

; 727  : 	m_isWaitKey = FALSE;

  0000a	c7 81 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+208], 0

; 728  : }

  00014	c3		 ret	 0
?__Inialize@CAccountConnector@@IAEXXZ ENDP		; CAccountConnector::__Inialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ??0CAccountConnector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CAccountConnector@@QAE@XZ PROC			; CAccountConnector::CAccountConnector, COMDAT
; _this$ = ecx

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CAccountConnector@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	e8 00 00 00 00	 call	 ??0CNetworkStream@@QAE@XZ ; CNetworkStream::CNetworkStream
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002e	8b c6		 mov	 eax, esi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 731  : {

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00037	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, eax ; CSingleton<CAccountConnector>::ms_singleton
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 731  : {

  0003c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CAccountConnector@@6BCNetworkStream@@@
  00042	0f 57 c0	 xorps	 xmm0, xmm0
  00045	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0004c	0f 11 86 84 00
	00 00		 movups	 XMMWORD PTR [esi+132], xmm0

; 860  :         _My_data._Mysize = 0;

  00053	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  0005d	c7 86 98 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+152], 15	; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00067	c6 86 84 00 00
	00 00		 mov	 BYTE PTR [esi+132], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0006e	0f 11 86 9c 00
	00 00		 movups	 XMMWORD PTR [esi+156], xmm0

; 860  :         _My_data._Mysize = 0;

  00075	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  0007f	c7 86 b0 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+176], 15	; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00089	c6 86 9c 00 00
	00 00		 mov	 BYTE PTR [esi+156], 0
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 731  : {

  00090	8d 86 b4 00 00
	00		 lea	 eax, DWORD PTR [esi+180]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00096	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00099	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]

; 861  :         _My_data._Myres  = _Small_string_capacity;

  0009c	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a9	c6 00 00	 mov	 BYTE PTR [eax], 0
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 731  : {

  000ac	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 732  : 	m_poHandler = NULL;

  000b0	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000ba	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  000be	76 02		 jbe	 SHORT $LN83@CAccountCo

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
$LN83@CAccountCo:

; 1621 :             _Mypair._Myval2._Mysize = _Count;

  000c2	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 736  : 	SetLoginInfo("", "");

  000c8	8b ce		 mov	 ecx, esi
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1623 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000cf	c6 00 00	 mov	 BYTE PTR [eax], 0
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 736  : 	SetLoginInfo("", "");

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000d7	c7 86 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+204], 0
  000e1	e8 00 00 00 00	 call	 ?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z ; CAccountConnector::SetLoginInfo

; 737  : 	SetRecvBufferSize(1024 * 128);

  000e6	68 00 00 02 00	 push	 131072			; 00020000H
  000eb	8b ce		 mov	 ecx, esi
  000ed	e8 00 00 00 00	 call	 ?SetRecvBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetRecvBufferSize

; 738  : 	SetSendBufferSize(2048);

  000f2	68 00 08 00 00	 push	 2048			; 00000800H
  000f7	8b ce		 mov	 ecx, esi
  000f9	e8 00 00 00 00	 call	 ?SetSendBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetSendBufferSize

; 739  : 	__Inialize();

  000fe	8b ce		 mov	 ecx, esi
  00100	e8 00 00 00 00	 call	 ?__Inialize@CAccountConnector@@IAEXXZ ; CAccountConnector::__Inialize

; 740  : }

  00105	8b c6		 mov	 eax, esi
  00107	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00111	59		 pop	 ecx
  00112	5e		 pop	 esi
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CAccountConnector@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
__unwindfunclet$??0CAccountConnector@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCAccountConnector@@@@UAE@XZ ; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>
__unwindfunclet$??0CAccountConnector@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CAccountConnector@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CAccountConnector@@QAE@XZ$4:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
  00040	cc		 int	 3
  00041	cc		 int	 3
__ehhandler$??0CAccountConnector@@QAE@XZ:
  00042	90		 npad	 1
  00043	90		 npad	 1
  00044	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00048	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004b	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0004e	33 c8		 xor	 ecx, eax
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CAccountConnector@@QAE@XZ
  0005a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CAccountConnector@@QAE@XZ ENDP			; CAccountConnector::CAccountConnector
; Function compile flags: /Ogtp
;	COMDAT ??_GCAccountConnector@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCAccountConnector@@UAEPAXI@Z PROC			; CAccountConnector::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CAccountConnector@@UAE@XZ ; CAccountConnector::~CAccountConnector
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 d8 00 00 00	 push	 216			; 000000d8H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCAccountConnector@@UAEPAXI@Z ENDP			; CAccountConnector::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp
;	COMDAT ??1CAccountConnector@@UAE@XZ
_TEXT	SEGMENT
??1CAccountConnector@@UAE@XZ PROC			; CAccountConnector::~CAccountConnector, COMDAT
; _this$ = ecx

; 743  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CAccountConnector@@6BCNetworkStream@@@
  00009	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@

; 744  : 	__OfflineState_Set();

  00010	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 745  : }

  00015	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  0001b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 745  : }

  00020	8d 8e 9c 00 00
	00		 lea	 ecx, DWORD PTR [esi+156]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00026	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 745  : }

  0002b	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1383 :         _Tidy_deallocate();

  00031	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h

; 19   : 	{ 

  00036	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 745  : }

  0003d	8b ce		 mov	 ecx, esi
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h

; 21   : 		ms_singleton = 0; 

  0003f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, 0 ; CSingleton<CAccountConnector>::ms_singleton
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\AccountConnector.cpp

; 745  : }

  00049	5e		 pop	 esi
  0004a	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
??1CAccountConnector@@UAE@XZ ENDP			; CAccountConnector::~CAccountConnector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ?instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ
_TEXT	SEGMENT
?instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ PROC ; CSingleton<CEterPackManager>::instance, COMDAT

; 37   : 		assert(ms_singleton);
; 38   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton

; 39   : 	}

  00005	c3		 ret	 0
?instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ ENDP ; CSingleton<CEterPackManager>::instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ PROC ; CSingleton<CEterPackManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ ENDP ; CSingleton<CEterPackManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonNetworkStream@@@@SAAAVCPythonNetworkStream@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonNetworkStream@@@@SAAAVCPythonNetworkStream@@XZ PROC ; CSingleton<CPythonNetworkStream>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonNetworkStream@@@@SAAAVCPythonNetworkStream@@XZ ENDP ; CSingleton<CPythonNetworkStream>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCAccountConnector@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCAccountConnector@@@@UAE@XZ PROC	; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, 0 ; CSingleton<CAccountConnector>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCAccountConnector@@@@UAE@XZ ENDP	; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ??0?$CSingleton@VCAccountConnector@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCAccountConnector@@@@QAE@XZ PROC	; CSingleton<CAccountConnector>::CSingleton<CAccountConnector>, COMDAT
; _this$ = ecx

; 12   : 	{ 
; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00000	8d 41 84	 lea	 eax, DWORD PTR [ecx-124]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@
  00009	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, eax ; CSingleton<CAccountConnector>::ms_singleton

; 16   : 	} 

  0000e	8b c1		 mov	 eax, ecx
  00010	c3		 ret	 0
??0?$CSingleton@VCAccountConnector@@@@QAE@XZ ENDP	; CSingleton<CAccountConnector>::CSingleton<CAccountConnector>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z PROC	; CSingleton<CAccountConnector>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1

; 19   : 	{ 

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, 0 ; CSingleton<CAccountConnector>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@
  0001a	74 0b		 je	 SHORT $LN8@scalar
  0001c	6a 04		 push	 4
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z ENDP	; CSingleton<CAccountConnector>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_ECAccountConnector@@WHM@AEPAXI@Z
_TEXT	SEGMENT
??_ECAccountConnector@@WHM@AEPAXI@Z PROC		; [thunk]:CAccountConnector::`vector deleting destructor', COMDAT
  00000	83 e9 7c	 sub	 ecx, 124		; 0000007cH
  00003	e9 00 00 00 00	 jmp	 ??_ECAccountConnector@@UAEPAXI@Z
??_ECAccountConnector@@WHM@AEPAXI@Z ENDP		; [thunk]:CAccountConnector::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 453  :         return _Myres > _Small_string_capacity;

  00000	83 79 14 0f	 cmp	 DWORD PTR [ecx+20], 15	; 0000000fH

; 435  :         value_type* _Result = _Bx._Buf;
; 436  :         if (_Large_mode_engaged()) {

  00004	76 03		 jbe	 SHORT $LN8@Myptr

; 437  :             _Result = _Unfancy(_Bx._Ptr);
; 438  :         }
; 439  : 
; 440  :         return _Result;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 441  :     }

  00008	c3		 ret	 0
$LN8@Myptr:

; 437  :             _Result = _Unfancy(_Bx._Ptr);
; 438  :         }
; 439  : 
; 440  :         return _Result;

  00009	8b c1		 mov	 eax, ecx

; 441  :     }

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 136  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 138  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 139  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 140  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 141  : #if _HAS_CXX20
; 142  :         if (_STD is_constant_evaluated()) {
; 143  :             // dest: [_First1, _First1 + _Count)
; 144  :             // src: [_First2, _First2 + _Count)
; 145  :             // We need to handle overlapping ranges.
; 146  :             // If _First1 is in the src range, we need a backward loop.
; 147  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 148  : 
; 149  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 150  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 151  :             bool _Loop_forward = true;
; 152  : 
; 153  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 154  :                 if (_First1 == _Src) {
; 155  :                     _Loop_forward = false;
; 156  :                     break;
; 157  :                 }
; 158  :             }
; 159  : 
; 160  :             if (_Loop_forward) {
; 161  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 162  :                     _First1[_Idx] = _First2[_Idx];
; 163  :                 }
; 164  :             } else {
; 165  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 166  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 167  :                 }
; 168  :             }
; 169  : 
; 170  :             return _First1;
; 171  :         }
; 172  : #endif // _HAS_CXX20
; 173  : 
; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00003	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __First2$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First1$[ebp]
  0000c	e8 00 00 00 00	 call	 _memmove

; 175  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 176  : 
; 177  :         return _First1;

  00011	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 178  :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2990 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00006	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0000b	83 ca 0f	 or	 edx, 15			; 0000000fH

; 2990 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  0000e	56		 push	 esi

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000f	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00012	3b d0		 cmp	 edx, eax

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00014	77 1d		 ja	 SHORT $LN4@Calculate_

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00016	8b ce		 mov	 ecx, esi
  00018	d1 e9		 shr	 ecx, 1
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b f0		 cmp	 esi, eax
  0001e	76 0a		 jbe	 SHORT $LN6@Calculate_

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00020	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00025	5e		 pop	 esi

; 2992 :     }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN6@Calculate_:

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0002a	03 ce		 add	 ecx, esi
  0002c	3b d1		 cmp	 edx, ecx
  0002e	0f 42 d1	 cmovb	 edx, ecx

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00031	8b c2		 mov	 eax, edx
$LN4@Calculate_:
  00033	5e		 pop	 esi

; 2992 :     }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT
; _this$dead$ = ecx

; 1630 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_LAMBDA {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1630 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_LAMBDA {

  00007	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1632 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00018	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 1633 :             },

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT
; _this$ = ecx

; 2995 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2996 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 2997 :         // _Fn(_New_ptr, _New_size, _Args...)
; 2998 :         if (_New_size > max_size()) {

  00004	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000f	0f 87 b3 00 00
	00		 ja	 $LN70@Reallocate

; 3000 :         }
; 3001 : 
; 3002 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00015	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00018	53		 push	 ebx
  00019	56		 push	 esi

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0001a	8b f0		 mov	 esi, eax

; 3000 :         }
; 3001 : 
; 3002 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001c	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0001f	83 ce 0f	 or	 esi, 15			; 0000000fH
  00022	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00028	76 12		 jbe	 SHORT $LN10@Reallocate

; 2980 :             return _Max;

  0002a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0002f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003a	eb 49		 jmp	 SHORT $LN68@Reallocate
$LN10@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0003c	8b d1		 mov	 edx, ecx
  0003e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00043	d1 ea		 shr	 edx, 1
  00045	2b c2		 sub	 eax, edx
  00047	3b c8		 cmp	 ecx, eax
  00049	76 12		 jbe	 SHORT $LN11@Reallocate

; 2984 :             return _Max;

  0004b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00050	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0005b	eb 28		 jmp	 SHORT $LN68@Reallocate
$LN11@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00060	3b f0		 cmp	 esi, eax
  00062	0f 42 f0	 cmovb	 esi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  00065	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

  00068	85 c0		 test	 eax, eax
  0006a	75 04		 jne	 SHORT $LN28@Reallocate

; 228  :         return nullptr;

  0006c	33 db		 xor	 ebx, ebx
  0006e	eb 1a		 jmp	 SHORT $LN27@Reallocate
$LN28@Reallocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00070	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00075	72 08		 jb	 SHORT $LN30@Reallocate

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	eb 06		 jmp	 SHORT $LN68@Reallocate
$LN30@Reallocate:

; 136  :         return ::operator new(_Bytes);

  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN68@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3009 :         _Mypair._Myval2._Mysize = _New_size;

  00085	8b d8		 mov	 ebx, eax
  00087	83 c4 04	 add	 esp, 4
$LN27@Reallocate:
  0008a	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008d	50		 push	 eax
  0008e	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3009 :         _Mypair._Myval2._Mysize = _New_size;

  00091	89 47 10	 mov	 DWORD PTR [edi+16], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00094	53		 push	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3010 :         _Mypair._Myval2._Myres  = _New_capacity;

  00095	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00098	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1632 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0009d	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1632 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000a3	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0

; 3011 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3012 :         if (_Old_capacity > _Small_string_capacity) {

  000a7	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000aa	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000ad	76 0c		 jbe	 SHORT $LN3@Reallocate

; 3013 :             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);

  000af	50		 push	 eax
  000b0	ff 37		 push	 DWORD PTR [edi]
  000b2	57		 push	 edi
  000b3	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Reallocate:

; 3014 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3015 :         } else {
; 3016 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
; 3017 :         }
; 3018 : 
; 3019 :         _ASAN_STRING_CREATE(*this);
; 3020 :         return *this;

  000bb	5e		 pop	 esi
  000bc	89 1f		 mov	 DWORD PTR [edi], ebx
  000be	8b c7		 mov	 eax, edi
  000c0	5b		 pop	 ebx

; 3021 :     }

  000c1	5f		 pop	 edi
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 0c 00	 ret	 12			; 0000000cH
$LN70@Reallocate:

; 2999 :             _Xlen_string(); // result too long

  000c8	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN67@Reallocate:
  000cd	cc		 int	 3
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
$T2 = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1616 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1617 :         // assign [_Ptr, _Ptr + _Count)
; 1618 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 435  :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 453  :         return _Myres > _Small_string_capacity;

  00018	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 436  :         if (_Large_mode_engaged()) {

  0001b	76 02		 jbe	 SHORT $LN5@assign

; 437  :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1621 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1623 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1633 :             },
; 1634 :             _Ptr);
; 1635 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 2998 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 a5 00 00
	00		 ja	 $LN119@assign

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 12		 jbe	 SHORT $LN36@assign

; 2980 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	eb 45		 jmp	 SHORT $LN117@assign
$LN36@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	8b d1		 mov	 edx, ecx
  0006b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00070	d1 ea		 shr	 edx, 1
  00072	2b c2		 sub	 eax, edx
  00074	3b c8		 cmp	 ecx, eax
  00076	76 12		 jbe	 SHORT $LN37@assign

; 2984 :             return _Max;

  00078	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0007d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00088	eb 24		 jmp	 SHORT $LN117@assign
$LN37@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008d	3b f8		 cmp	 edi, eax
  0008f	0f 42 f8	 cmovb	 edi, eax

; 825  :         ++_Capacity; // Take null terminator into consideration

  00092	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

  00095	85 c0		 test	 eax, eax
  00097	74 18		 je	 SHORT $LN116@assign
$LN54@assign:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00099	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0009e	72 08		 jb	 SHORT $LN56@assign

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a6	eb 06		 jmp	 SHORT $LN117@assign
$LN56@assign:

; 136  :         return ::operator new(_Bytes);

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN117@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3009 :         _Mypair._Myval2._Mysize = _New_size;

  000ae	83 c4 04	 add	 esp, 4
$LN116@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b1	53		 push	 ebx
  000b2	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3009 :         _Mypair._Myval2._Mysize = _New_size;

  000b5	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b8	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3009 :         _Mypair._Myval2._Mysize = _New_size;

  000b9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 3010 :         _Mypair._Myval2._Myres  = _New_capacity;

  000bc	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	e8 00 00 00 00	 call	 _memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1632 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c4	8b 7d 0c	 mov	 edi, DWORD PTR $T2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3012 :         if (_Old_capacity > _Small_string_capacity) {

  000ca	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 1632 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000cd	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3012 :         if (_Old_capacity > _Small_string_capacity) {

  000d1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000d4	76 0c		 jbe	 SHORT $LN29@assign

; 3013 :             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);

  000d6	50		 push	 eax
  000d7	ff 36		 push	 DWORD PTR [esi]
  000d9	56		 push	 esi
  000da	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@assign:

; 1624 :             _ASAN_STRING_CREATE(*this);
; 1625 :             return *this;
; 1626 :         }
; 1627 : 
; 1628 :         return _Reallocate_for(

  000e2	89 3e		 mov	 DWORD PTR [esi], edi

; 1633 :             },
; 1634 :             _Ptr);
; 1635 :     }

  000e4	8b c6		 mov	 eax, esi
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
$LN119@assign:

; 2999 :             _Xlen_string(); // result too long

  000ef	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN114@assign:
  000f4	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1637 :     _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1637 :     _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL6@assign:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL6@assign
  00017	2b c7		 sub	 eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 1639 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1445 :     _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1445 :     _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL8@operator:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL8@operator
  00017	2b c7		 sub	 eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1446 :         return assign(_Ptr);

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 1447 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1186 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 457  :         // start the lifetime of the array elements
; 458  : #if _HAS_CXX20
; 459  :         if (_STD is_constant_evaluated()) {
; 460  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 461  :                 _Bx._Buf[_Idx] = value_type();
; 462  :             }
; 463  :         }
; 464  : #endif // _HAS_CXX20
; 465  :     }

  00000	c2 00 00	 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 856  :         auto& _My_data = _Mypair._Myval2;
; 857  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 858  : 
; 859  :         // initialize basic_string data members
; 860  :         _My_data._Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00007	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0000e	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 866  :     }

  00011	c3		 ret	 0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 708  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 709  :         _Construct_empty();
; 710  :     }

  00003	8b c1		 mov	 eax, ecx

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 860  :         _My_data._Mysize = 0;

  00008	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  0000f	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00016	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 709  :         _Construct_empty();
; 710  :     }

  00019	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 453  :         return _Myres > _Small_string_capacity;

  00000	83 79 14 0f	 cmp	 DWORD PTR [ecx+20], 15	; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;
; 445  :         if (_Large_mode_engaged()) {

  00004	76 03		 jbe	 SHORT $LN8@Myptr

; 446  :             _Result = _Unfancy(_Bx._Ptr);
; 447  :         }
; 448  : 
; 449  :         return _Result;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 450  :     }

  00008	c3		 ret	 0
$LN8@Myptr:

; 446  :             _Result = _Unfancy(_Bx._Ptr);
; 447  :         }
; 448  : 
; 449  :         return _Result;

  00009	8b c1		 mov	 eax, ecx

; 450  :     }

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 453  :         return _Myres > _Small_string_capacity;

  00000	83 79 14 0f	 cmp	 DWORD PTR [ecx+20], 15	; 0000000fH

; 445  :         if (_Large_mode_engaged()) {

  00004	76 03		 jbe	 SHORT $LN11@c_str

; 2356 :         return _Mypair._Myval2._Myptr();

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2357 :     }

  00008	c3		 ret	 0
$LN11@c_str:

; 2356 :         return _Mypair._Myval2._Myptr();

  00009	8b c1		 mov	 eax, ecx

; 2357 :     }

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 974  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00008	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	8b c1		 mov	 eax, ecx

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

  00008	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000f	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00016	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

  00008	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000f	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 531  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2977 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Requested$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR __Max$[ebp]
  00009	83 c9 0f	 or	 ecx, 15			; 0000000fH
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	3b ca		 cmp	 ecx, edx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00010	77 1d		 ja	 SHORT $LN9@Calculate_

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00012	8b 7d 0c	 mov	 edi, DWORD PTR __Old$[ebp]
  00015	8b c2		 mov	 eax, edx
  00017	8b f7		 mov	 esi, edi
  00019	d1 ee		 shr	 esi, 1
  0001b	2b c6		 sub	 eax, esi
  0001d	3b f8		 cmp	 edi, eax
  0001f	77 0e		 ja	 SHORT $LN9@Calculate_

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00021	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00024	3b c8		 cmp	 ecx, eax
  00026	5f		 pop	 edi
  00027	0f 42 c8	 cmovb	 ecx, eax
  0002a	8b c1		 mov	 eax, ecx

; 2988 :     }

  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN9@Calculate_:
  0002f	5f		 pop	 edi

; 2984 :             return _Max;

  00030	8b c2		 mov	 eax, edx

; 2988 :     }

  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	83 c8 ff	 or	 eax, -1

; 747  :     }

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1543 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1544 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3111 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 3112 :     }

  00002	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8b 10		 mov	 edx, DWORD PTR [eax]
  0000b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000d	0f 42 c1	 cmovb	 eax, ecx

; 78   : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 42 c2	 cmovb	 eax, edx

; 102  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$_Max_limit@H@std@@YAHXZ
_TEXT	SEGMENT
??$_Max_limit@H@std@@YAHXZ PROC				; std::_Max_limit<int>, COMDAT

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

  00005	c3		 ret	 0
??$_Max_limit@H@std@@YAHXZ ENDP				; std::_Max_limit<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 2378 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 2379 :         const size_type _Storage_max = // can always store small string
; 2380 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2381 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 2382 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2383 :         );
; 2384 :     }

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 67   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0000f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 69   :     }

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 133  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 66   :         : _Data()

  00009	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 134  :     }

  00011	8b c1		 mov	 eax, ecx
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN9@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN9@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 __invoke_watson
$LN7@Allocate_m:
  0003a	cc		 int	 3
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 135  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  :     }

  00003	5d		 pop	 ebp

; 136  :         return ::operator new(_Bytes);

  00004	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN2@Allocate

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN2@Allocate:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0000c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00011	72 09		 jb	 SHORT $LN4@Allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00013	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

  00016	5d		 pop	 ebp

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00017	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN4@Allocate:

; 136  :         return ::operator new(_Bytes);

  0001c	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

  0001f	5d		 pop	 ebp

; 136  :         return ::operator new(_Bytes);

  00020	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 123  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  :     if (_Bytes == 0) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	50		 push	 eax
  0000f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00014	72 0c		 jb	 SHORT $LN6@allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN6@allocate:

; 136  :         return ::operator new(_Bytes);

  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2294 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2295 : #if _HAS_CXX23
; 2296 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2297 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2298 :         _Count                  = _Allocated;
; 2299 :         return _Ptr;
; 2300 :     } else
; 2301 : #endif // _HAS_CXX23
; 2302 :     {
; 2303 :         return _Al.allocate(_Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 227  :     if (_Bytes == 0) {

  00008	85 c0		 test	 eax, eax
  0000a	75 02		 jne	 SHORT $LN6@Allocate_a

; 2304 :     }
; 2305 : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN6@Allocate_a:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	50		 push	 eax
  0000f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00014	72 0a		 jb	 SHORT $LN8@Allocate_a

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>

; 2304 :     }
; 2305 : }

  0001b	83 c4 04	 add	 esp, 4
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN8@Allocate_a:

; 136  :         return ::operator new(_Bytes);

  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 2304 :     }
; 2305 : }

  00025	83 c4 04	 add	 esp, 4
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@D$$V@std@@YAPADQAD@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
??$construct_at@D$$V@std@@YAPADQAD@Z PROC		; std::construct_at<char>, COMDAT

; 462  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00006	c6 00 00	 mov	 BYTE PTR [eax], 0

; 464  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$construct_at@D$$V@std@@YAPADQAD@Z ENDP		; std::construct_at<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 823  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 824  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 825  :         ++_Capacity; // Take null terminator into consideration

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00007	83 06 01	 add	 DWORD PTR [esi], 1
  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

  0000c	75 07		 jne	 SHORT $LN12@Allocate_f
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 846  :         return _Fancy_ptr;

  0000e	ff 0e		 dec	 DWORD PTR [esi]
  00010	33 c0		 xor	 eax, eax
  00012	5e		 pop	 esi

; 847  :     }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN12@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00015	50		 push	 eax
  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 0d		 jb	 SHORT $LN14@Allocate_f

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0001d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 847  :     }

  00022	83 c4 04	 add	 esp, 4
  00025	ff 0e		 dec	 DWORD PTR [esi]
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN14@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 847  :     }

  0002f	83 c4 04	 add	 esp, 4
  00032	ff 0e		 dec	 DWORD PTR [esi]
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1501 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1503 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PADABQAD@std@@YAPAPADQAPADABQAD@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@PADABQAD@std@@YAPAPADQAPADABQAD@Z PROC	; std::construct_at<char *,char * const &>, COMDAT

; 462  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$construct_at@PADABQAD@std@@YAPAPADQAPADABQAD@Z ENDP	; std::construct_at<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 164  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 165  :         (void)_Size;
; 166  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 167  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1524 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1525 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1526 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 469  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 105  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 107  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 108  :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 109  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 110  : #if _HAS_CXX20
; 111  :         if (_STD is_constant_evaluated()) {
; 112  :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 113  :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 114  :                 _First1[_Idx] = _First2[_Idx];
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // _HAS_CXX20
; 120  : 
; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00003	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __First2$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First1$[ebp]
  0000c	e8 00 00 00 00	 call	 _memcpy

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

  00011	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 125  :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 68   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 70   : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Convert_size@II@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@II@std@@YAII@Z PROC			; std::_Convert_size<unsigned int,unsigned int>, COMDAT

; 1120 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1121 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1122 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1123 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1124 : 
; 1125 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1126 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1127 :             _Xlength_error("size is too long for _Size_type");
; 1128 :         }
; 1129 :     }
; 1130 : 
; 1131 :     return static_cast<_Size_type>(_Len);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 1132 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Convert_size@II@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 443  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 444  :         // find length of null-terminated string
; 445  : #if _HAS_CXX17
; 446  : #ifdef __cpp_char8_t
; 447  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 448  : #if _HAS_U8_INTRINSICS
; 449  :             return __builtin_u8strlen(_First);
; 450  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 451  :             return _Primary_char_traits::length(_First);
; 452  : #endif // ^^^ no u8 intrinsics ^^^
; 453  :         } else
; 454  : #endif // defined(__cpp_char8_t)
; 455  :         {
; 456  :             return __builtin_strlen(_First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@length:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL4@length
  00017	2b c2		 sub	 eax, edx

; 457  :         }
; 458  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 459  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 460  : #endif // ^^^ !_HAS_CXX17 ^^^
; 461  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	c2 00 00	 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c2 00 00	 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c2 00 00	 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1184 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 453  :         return _Myres > _Small_string_capacity;

  00000	83 79 14 0f	 cmp	 DWORD PTR [ecx+20], 15	; 0000000fH
  00004	0f 97 c0	 seta	 al

; 454  :     }

  00007	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1539 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1540 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3107 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 3108 :     }

  00002	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	83 00 23	 add	 DWORD PTR [eax], 35	; 00000023H
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00011	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00013	83 c0 fc	 add	 eax, -4			; fffffffcH
  00016	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00019	77 04		 ja	 SHORT $LN3@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0001b	89 11		 mov	 DWORD PTR [ecx], edx

; 221  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN3@Adjust_man:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 __invoke_watson
$LN5@Adjust_man:
  0002e	cc		 int	 3
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Deallocate@$07@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07@std@@YAXPAXI@Z PROC			; std::_Deallocate<8>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 15		 jb	 SHORT $LN11@Deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	77 11		 ja	 SHORT $LN15@Deallocate
  00021	eb 03		 jmp	 SHORT $LN9@Deallocate
$LN11@Deallocate:

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00023	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN9@Deallocate:

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

  00026	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  00029	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 290  :     }
; 291  : }

  0002c	5d		 pop	 ebp

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

  0002d	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
$LN15@Deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	e8 00 00 00 00	 call	 __invoke_watson
$LN13@Deallocate:
  00041	cc		 int	 3
??$_Deallocate@$07@std@@YAXPAXI@Z ENDP			; std::_Deallocate<8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00009	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000f	72 12		 jb	 SHORT $LN12@deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00011	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00014	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	77 10		 ja	 SHORT $LN11@deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00021	8b c2		 mov	 eax, edx
$LN12@deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8

; 986  :     }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN11@deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	e8 00 00 00 00	 call	 __invoke_watson
$LN15@deallocate:
  00040	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 850  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Capacity$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Old_ptr$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00009	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00010	72 12		 jb	 SHORT $LN15@Deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00012	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00015	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00018	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00020	77 0e		 ja	 SHORT $LN14@Deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00022	8b c2		 mov	 eax, edx
$LN15@Deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 853  :     }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN14@Deallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 __invoke_watson
$LN19@Deallocate:
  0003f	cc		 int	 3
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }

  00000	c2 00 00	 ret	 0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 183  :     return __builtin_is_constant_evaluated();

  00000	32 c0		 xor	 al, al

; 184  : }

  00002	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Char_traits@DH@std@@SAXAADABD@Z PROC		; std::_Char_traits<char,int>::assign, COMDAT

; 228  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :         _Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 230  :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAXAADABD@Z ENDP		; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 496  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 497  : #if _HAS_CXX20
; 498  :         if (_STD is_constant_evaluated()) {
; 499  :             return _Primary_char_traits::assign(_Left, _Right);
; 500  :         }
; 501  : #endif // _HAS_CXX20
; 502  :         _Left = _Right;
; 503  :     }

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3080 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 453  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3081 :         auto& _My_data = _Mypair._Myval2;
; 3082 :         _My_data._Orphan_all();
; 3083 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN14@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN21@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN14@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3094 :     }

  00044	c3		 ret	 0
$LN21@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	e8 00 00 00 00	 call	 __invoke_watson
$LN30@Tidy_deall:
  00054	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1383 :         _Tidy_deallocate();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
