; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35217.0 

	TITLE	d:\_m2work\server client tmp4\clientvs22\vs_files\userinterface\distribute\cameraprocedure.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
PUBLIC	??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R0?AVSpherePackCallback@@@8			; SpherePackCallback `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@SpherePackCallback@@8		; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2SpherePackCallback@@8			; SpherePackCallback::`RTTI Base Class Array'
PUBLIC	??_R3SpherePackCallback@@8			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4SpherePackCallback@@6B@			; SpherePackCallback::`RTTI Complete Object Locator'
PUBLIC	??_7SpherePackCallback@@6B@			; SpherePackCallback::`vftable'
PUBLIC	??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
PUBLIC	?CAMERA_MAX_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MAX_DISTANCE
PUBLIC	?CAMERA_MIN_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MIN_DISTANCE
EXTRN	?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::RangeTest
EXTRN	?SetTargetHeight@CCamera@@QAEXM@Z:PROC		; CCamera::SetTargetHeight
EXTRN	?SetDistance@CCamera@@QAEXM@Z:PROC		; CCamera::SetDistance
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?RotateEyeAroundTarget@CCamera@@QAEXMM@Z:PROC	; CCamera::RotateEyeAroundTarget
EXTRN	?fMIN@@YAMMM@Z:PROC				; fMIN
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z:PROC ; CGraphicObjectInstance::CollisionDynamicSphere
EXTRN	?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z:PROC	; CCamera::SetEye
EXTRN	?GetHeight@CMapManager@@QAEMMM@Z:PROC		; CMapManager::GetHeight
EXTRN	?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z:PROC ; CCamera::SetCameraState
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A DD 01H DUP (?) ; CSingleton<CPythonBackground>::ms_singleton
_BSS	ENDS
?CAMERA_MIN_DISTANCE@CCamera@@0MA DD 043480000r	; 200	; CCamera::CAMERA_MIN_DISTANCE
?CAMERA_MAX_DISTANCE@CCamera@@0MA DD 0451c4000r	; 2500	; CCamera::CAMERA_MAX_DISTANCE
_DATA	ENDS
;	COMDAT ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ DD FLAT:??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
	DD	FLAT:??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT
??_7SpherePackCallback@@6B@ DD FLAT:??_R4SpherePackCallback@@6B@ ; SpherePackCallback::`vftable'
	DD	FLAT:??_ESpherePackCallback@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_R4SpherePackCallback@@6B@
rdata$r	SEGMENT
??_R4SpherePackCallback@@6B@ DD 00H			; SpherePackCallback::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpherePackCallback@@@8
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3SpherePackCallback@@8
rdata$r	SEGMENT
??_R3SpherePackCallback@@8 DD 00H			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R2SpherePackCallback@@8
rdata$r	SEGMENT
??_R2SpherePackCallback@@8 DD FLAT:??_R1A@?0A@EA@SpherePackCallback@@8 ; SpherePackCallback::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpherePackCallback@@8 DD FLAT:??_R0?AVSpherePackCallback@@@8 ; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpherePackCallback@@@8
data$rs	SEGMENT
??_R0?AVSpherePackCallback@@@8 DD FLAT:??_7type_info@@6B@ ; SpherePackCallback `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpherePackCallback@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ DD 00H ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
data$rs	SEGMENT
??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UCameraCollisionChecker@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UCameraCollisionChecker@@@@8 DD 00H	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
PUBLIC	_floorf
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
PUBLIC	_sqrtf
PUBLIC	??0Vector3d@@QAE@XZ				; Vector3d::Vector3d
PUBLIC	?Set@Vector3d@@QAEXMMM@Z			; Vector3d::Set
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
PUBLIC	??XD3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator*=
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	_fabsf
PUBLIC	?GetUserData@SpherePack@@QBEPAXXZ		; SpherePack::GetUserData
PUBLIC	??1SpherePackCallback@@UAE@XZ			; SpherePackCallback::~SpherePackCallback
PUBLIC	?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::PointTest2dCallback
PUBLIC	?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::RangeTestCallback
PUBLIC	?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; SpherePackCallback::RayTraceCallback
PUBLIC	?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::VisibilityCallback
PUBLIC	??_GSpherePackCallback@@UAEPAXI@Z		; SpherePackCallback::`scalar deleting destructor'
PUBLIC	??0SpherePackCallback@@QAE@XZ			; SpherePackCallback::SpherePackCallback
PUBLIC	??$construct_at@UD3DXVECTOR3@@U1@@std@@YAPAUD3DXVECTOR3@@QAU1@$$QAU1@@Z ; std::construct_at<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QBEABV?$allocator@UD3DXVECTOR3@@@2@XZ ; std::_Compressed_pair<std::allocator<D3DXVECTOR3>,std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >,1>::_Get_first
PUBLIC	??$_Get_size_of_n@$0M@@std@@YAII@Z		; std::_Get_size_of_n<12>
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@$$QAU3@@Z ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ; std::forward<D3DXVECTOR3>
PUBLIC	??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
PUBLIC	??$move@AAPAUD3DXVECTOR3@@@std@@YA$$QAPAUD3DXVECTOR3@@AAPAU1@@Z ; std::move<D3DXVECTOR3 * &>
PUBLIC	??$to_address@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QAU1@@Z ; std::to_address<D3DXVECTOR3>
PUBLIC	?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::allocate
PUBLIC	?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity
PUBLIC	?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEABV?$allocator@UD3DXVECTOR3@@@2@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@PAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::~_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@XZ ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Release
PUBLIC	??$_Emplace_back@UD3DXVECTOR3@@@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEX$$QAUD3DXVECTOR3@@@Z ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Emplace_back<D3DXVECTOR3>
PUBLIC	??$_To_address@PAUD3DXVECTOR3@@@std@@YA?A_PABQAUD3DXVECTOR3@@@Z ; std::_To_address<D3DXVECTOR3 *>
PUBLIC	??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
PUBLIC	??$move@AAUD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ; std::move<D3DXVECTOR3 &>
PUBLIC	??$construct_at@UD3DXVECTOR3@@ABU1@@std@@YAPAUD3DXVECTOR3@@QAU1@ABU1@@Z ; std::construct_at<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	??$addressof@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@AAU1@@Z ; std::addressof<D3DXVECTOR3>
PUBLIC	?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range
PUBLIC	??1_Reallocation_guard@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ; std::_Compressed_pair<std::allocator<D3DXVECTOR3>,std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >,1>::_Get_first
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Get_unwrapped@ABQAUD3DXVECTOR3@@@std@@YA?A_TABQAUD3DXVECTOR3@@@Z ; std::_Get_unwrapped<D3DXVECTOR3 * const &>
PUBLIC	??$construct@UD3DXVECTOR3@@ABU1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	??$_Unfancy@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ; std::_Unfancy<D3DXVECTOR3>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Construct_in_place@UD3DXVECTOR3@@ABU1@@std@@YAXAAUD3DXVECTOR3@@ABU1@@Z ; std::_Construct_in_place<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate
PUBLIC	?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
PUBLIC	??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_back_with_unused_capacity<D3DXVECTOR3 const &>
PUBLIC	??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z ; std::forward<D3DXVECTOR3 const &>
PUBLIC	??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
PUBLIC	?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
PUBLIC	??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
PUBLIC	?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<CameraCollisionChecker>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
PUBLIC	??$_Emplace_one_at_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_one_at_back<D3DXVECTOR3 const &>
PUBLIC	?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ; CSingleton<CCullingManager>::Instance
PUBLIC	??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back
PUBLIC	?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ ; CSingleton<CPythonBackground>::Instance
PUBLIC	?Update@CCamera@@QAEXXZ				; CCamera::Update
PUBLIC	??0CDynamicSphereInstance@@QAE@XZ		; CDynamicSphereInstance::CDynamicSphereInstance
PUBLIC	??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
PUBLIC	?ProcessTerrainCollision@CCamera@@AAEXXZ	; CCamera::ProcessTerrainCollision
PUBLIC	?GetDistance@CCamera@@QBEMXZ			; CCamera::GetDistance
EXTRN	??_ESpherePackCallback@@UAEPAXI@Z:PROC		; SpherePackCallback::`vector deleting destructor'
EXTRN	??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z:PROC ; RangeTester<CameraCollisionChecker>::`vector deleting destructor'
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\Camera.h
;	COMDAT ?GetDistance@CCamera@@QBEMXZ
_TEXT	SEGMENT
?GetDistance@CCamera@@QBEMXZ PROC			; CCamera::GetDistance, COMDAT
; _this$ = ecx

; 186  : 		float GetDistance() const { return m_fDistance; }

  00000	f3 0f 10 81 34
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+308]
  00008	c3		 ret	 0
?GetDistance@CCamera@@QBEMXZ ENDP			; CCamera::GetDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
;	COMDAT ?ProcessTerrainCollision@CCamera@@AAEXXZ
_TEXT	SEGMENT
tv130 = -56						; size = 4
tv903 = -56						; size = 4
tv909 = -56						; size = 8
tv911 = -56						; size = 4
tv917 = -56						; size = 8
tv784 = -44						; size = 4
_f$1$ = -44						; size = 4
tv792 = -40						; size = 4
_rPythonBackground$1$ = -36				; size = 4
$T1 = -32						; size = 4
_v3CollisionPoint$ = -28				; size = 12
_v3NewEye$2 = -16					; size = 12
_v3NewEye$3 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?ProcessTerrainCollision@CCamera@@AAEXXZ PROC		; CCamera::ProcessTerrainCollision, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 74	 sub	 esp, 116		; 00000074H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 70	 mov	 DWORD PTR __$ArrayPad$[esp+116], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx

; 15   : 	CPythonBackground & rPythonBackground = CPythonBackground::Instance();

  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0001e	57		 push	 edi
  0001f	89 4c 24 5c	 mov	 DWORD PTR _rPythonBackground$1$[esp+128], ecx

; 16   : 	D3DXVECTOR3 v3CollisionPoint;
; 17   : 
; 18   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kTargetToCameraBottomRay, &v3CollisionPoint))

  00023	8d 86 f0 02 00
	00		 lea	 eax, DWORD PTR [esi+752]
  00029	89 44 24 60	 mov	 DWORD PTR $T1[esp+128], eax
  0002d	8d 44 24 64	 lea	 eax, DWORD PTR _v3CollisionPoint$[esp+128]
  00031	50		 push	 eax
  00032	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain
  0003e	8b ce		 mov	 ecx, esi
  00040	84 c0		 test	 al, al
  00042	0f 84 f2 00 00
	00		 je	 $LN2@ProcessTer

; 19   : 	{
; 20   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00048	6a 01		 push	 1
  0004a	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  0004f	f3 0f 10 8e f0
	02 00 00	 movss	 xmm1, DWORD PTR [esi+752]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 725  :             return (float)floor(_X);

  00057	83 ec 08	 sub	 esp, 8
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0005a	f3 0f 10 56 30	 movss	 xmm2, DWORD PTR [esi+48]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  0005f	f3 0f 58 c9	 addss	 xmm1, xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00063	0f 28 c1	 movaps	 xmm0, xmm1
  00066	f3 0f 59 4e 4c	 mulss	 xmm1, DWORD PTR [esi+76]
  0006b	f3 0f 59 46 48	 mulss	 xmm0, DWORD PTR [esi+72]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00070	f3 0f 5c d0	 subss	 xmm2, xmm0
  00074	f3 0f 10 46 34	 movss	 xmm0, DWORD PTR [esi+52]
  00079	f3 0f 5c c1	 subss	 xmm0, xmm1
  0007d	f3 0f 11 54 24
	60		 movss	 DWORD PTR tv792[esp+136], xmm2
  00083	f3 0f 11 44 24
	5c		 movss	 DWORD PTR tv784[esp+136], xmm0

; 181  :     y = fy;

  00089	0f 5a c0	 cvtps2pd xmm0, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 725  :             return (float)floor(_X);

  0008c	f2 0f 11 44 24
	50		 movsd	 QWORD PTR tv917[esp+136], xmm0
  00092	dd 44 24 50	 fld	 QWORD PTR tv917[esp+136]
  00096	dd 1c 24	 fstp	 QWORD PTR [esp]
  00099	e8 00 00 00 00	 call	 _floor
  0009e	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR tv792[esp+136]
  000a4	d9 5c 24 50	 fstp	 DWORD PTR tv911[esp+136]
  000a8	d9 44 24 50	 fld	 DWORD PTR tv911[esp+136]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000ac	0f 5a c0	 cvtps2pd xmm0, xmm0
  000af	51		 push	 ecx
  000b0	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 725  :             return (float)floor(_X);

  000b4	f2 0f 11 44 24
	54		 movsd	 QWORD PTR tv909[esp+140], xmm0
  000ba	dd 44 24 54	 fld	 QWORD PTR tv909[esp+140]
  000be	dd 1c 24	 fstp	 QWORD PTR [esp]
  000c1	e8 00 00 00 00	 call	 _floor
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000c6	8b 4c 24 68	 mov	 ecx, DWORD PTR _rPythonBackground$1$[esp+140]
  000ca	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 725  :             return (float)floor(_X);

  000cd	d9 5c 24 50	 fstp	 DWORD PTR tv903[esp+136]
  000d1	d9 44 24 50	 fld	 DWORD PTR tv903[esp+136]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000d5	d9 1c 24	 fstp	 DWORD PTR [esp]
  000d8	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight

; 23   : 		D3DXVECTOR3 v3NewEye = v3CheckVector + 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  000dd	f3 0f 10 8e f0
	02 00 00	 movss	 xmm1, DWORD PTR [esi+752]
  000e5	f3 0f 58 c9	 addss	 xmm1, xmm1
  000e9	d9 5c 24 48	 fstp	 DWORD PTR tv130[esp+128]
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000ed	0f 28 c1	 movaps	 xmm0, xmm1
  000f0	f3 0f 59 46 48	 mulss	 xmm0, DWORD PTR [esi+72]

; 182  :     z = fz;

  000f5	f3 0f 58 44 24
	58		 addss	 xmm0, DWORD PTR tv792[esp+128]

; 180  :     x = fx;

  000fb	f3 0f 11 44 24
	70		 movss	 DWORD PTR _v3NewEye$2[esp+128], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00101	0f 28 c1	 movaps	 xmm0, xmm1
  00104	f3 0f 59 4e 50	 mulss	 xmm1, DWORD PTR [esi+80]
  00109	f3 0f 59 46 4c	 mulss	 xmm0, DWORD PTR [esi+76]

; 181  :     y = fy;

  0010e	f3 0f 58 4c 24
	48		 addss	 xmm1, DWORD PTR tv130[esp+128]
  00114	f3 0f 58 44 24
	54		 addss	 xmm0, DWORD PTR tv784[esp+128]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0011a	0f 2f 4e 38	 comiss	 xmm1, DWORD PTR [esi+56]
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0011e	f3 0f 11 44 24
	74		 movss	 DWORD PTR _v3NewEye$2[esp+132], xmm0

; 182  :     z = fz;

  00124	f3 0f 11 4c 24
	78		 movss	 DWORD PTR _v3NewEye$2[esp+136], xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0012a	76 1f		 jbe	 SHORT $LN3@ProcessTer

; 25   : 		{
; 26   : 			//printf("ToCameraBottom(%f, %f, %f) TCR %f, UP(%f, %f, %f), new %f > old %f", 
; 27   : 			//	v3CheckVector.x, v3CheckVector.y, v3CheckVector.z, 
; 28   : 			//	m_fTerrainCollisionRadius,
; 29   : 			//	m_v3Up.x, m_v3Up.y, m_v3Up.z,
; 30   : 			//	v3NewEye.z, m_v3Eye.z);
; 31   : 			SetEye(v3NewEye);

  0012c	8d 44 24 70	 lea	 eax, DWORD PTR _v3NewEye$2[esp+128]
  00130	8b ce		 mov	 ecx, esi
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye

; 32   : 		}
; 33   : 		/*
; 34   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 35   : 		D3DXVECTOR3 v3NewEye = v3CollisionPoint;
; 36   : 		SetEye(v3NewEye);
; 37   : 		*/
; 38   : 	}

  00138	eb 11		 jmp	 SHORT $LN3@ProcessTer
$LN2@ProcessTer:

; 39   : 	else
; 40   : 		SetCameraState(CAMERA_STATE_NORMAL);

  0013a	6a 00		 push	 0
  0013c	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
  00141	8d 86 f0 02 00
	00		 lea	 eax, DWORD PTR [esi+752]
  00147	89 44 24 60	 mov	 DWORD PTR $T1[esp+128], eax
$LN3@ProcessTer:

; 41   : 
; 42   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBottomToTerrainRay, &v3CollisionPoint))

  0014b	8b 4c 24 5c	 mov	 ecx, DWORD PTR _rPythonBackground$1$[esp+128]
  0014f	8d 44 24 64	 lea	 eax, DWORD PTR _v3CollisionPoint$[esp+128]
  00153	50		 push	 eax
  00154	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain
  00160	8b ce		 mov	 ecx, esi
  00162	84 c0		 test	 al, al
  00164	0f 84 cb 00 00
	00		 je	 $LN5@ProcessTer

; 43   : 	{
; 44   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  0016a	6a 01		 push	 1
  0016c	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00171	f3 0f 10 4e 34	 movss	 xmm1, DWORD PTR [esi+52]
  00176	f3 0f 5c 4c 24
	68		 subss	 xmm1, DWORD PTR _v3CollisionPoint$[esp+132]
  0017c	f3 0f 10 56 30	 movss	 xmm2, DWORD PTR [esi+48]
  00181	f3 0f 5c 54 24
	64		 subss	 xmm2, DWORD PTR _v3CollisionPoint$[esp+128]
  00187	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  0018c	f3 0f 5c 44 24
	6c		 subss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+136]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 46   : 		if (D3DXVec3Length(&d3dd) < 2.0f * m_fTerrainCollisionRadius)

  00192	8b 44 24 60	 mov	 eax, DWORD PTR $T1[esp+128]
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00196	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0019a	f3 0f 59 d2	 mulss	 xmm2, xmm2
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 46   : 		if (D3DXVec3Length(&d3dd) < 2.0f * m_fTerrainCollisionRadius)

  0019e	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  001a2	f3 0f 59 c0	 mulss	 xmm0, xmm0
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 46   : 		if (D3DXVec3Length(&d3dd) < 2.0f * m_fTerrainCollisionRadius)

  001a6	f3 0f 58 db	 addss	 xmm3, xmm3
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  001aa	f3 0f 58 ca	 addss	 xmm1, xmm2
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 46   : 		if (D3DXVec3Length(&d3dd) < 2.0f * m_fTerrainCollisionRadius)

  001ae	f3 0f 11 5c 24
	54		 movss	 DWORD PTR _f$1$[esp+128], xmm3
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  001b4	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 799  :             return (float)sqrt(_X);

  001b8	0f 5a c1	 cvtps2pd xmm0, xmm1
  001bb	0f 57 c9	 xorps	 xmm1, xmm1
  001be	66 0f 2e c8	 ucomisd xmm1, xmm0
  001c2	77 06		 ja	 SHORT $LN45@ProcessTer
  001c4	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  001c8	eb 05		 jmp	 SHORT $LN46@ProcessTer
$LN45@ProcessTer:
  001ca	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN46@ProcessTer:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 46   : 		if (D3DXVec3Length(&d3dd) < 2.0f * m_fTerrainCollisionRadius)

  001cf	f3 0f 10 4c 24
	54		 movss	 xmm1, DWORD PTR _f$1$[esp+128]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 799  :             return (float)sqrt(_X);

  001d5	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 46   : 		if (D3DXVec3Length(&d3dd) < 2.0f * m_fTerrainCollisionRadius)

  001d9	0f 2f c8	 comiss	 xmm1, xmm0
  001dc	76 5e		 jbe	 SHORT $LN6@ProcessTer
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001de	0f 28 c1	 movaps	 xmm0, xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 50   : 			SetEye(v3NewEye);

  001e1	8d 44 24 70	 lea	 eax, DWORD PTR _v3NewEye$3[esp+128]
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001e5	f3 0f 59 46 48	 mulss	 xmm0, DWORD PTR [esi+72]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 50   : 			SetEye(v3NewEye);

  001ea	8b ce		 mov	 ecx, esi
  001ec	50		 push	 eax
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 182  :     z = fz;

  001ed	f3 0f 58 44 24
	68		 addss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+132]

; 180  :     x = fx;

  001f3	f3 0f 11 44 24
	74		 movss	 DWORD PTR _v3NewEye$3[esp+132], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001f9	0f 28 c1	 movaps	 xmm0, xmm1
  001fc	f3 0f 59 46 4c	 mulss	 xmm0, DWORD PTR [esi+76]
  00201	f3 0f 59 4e 50	 mulss	 xmm1, DWORD PTR [esi+80]

; 180  :     x = fx;

  00206	f3 0f 58 44 24
	6c		 addss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+136]

; 181  :     y = fy;

  0020c	f3 0f 58 4c 24
	70		 addss	 xmm1, DWORD PTR _v3CollisionPoint$[esp+140]
  00212	f3 0f 11 44 24
	78		 movss	 DWORD PTR _v3NewEye$3[esp+136], xmm0

; 182  :     z = fz;

  00218	f3 0f 11 4c 24
	7c		 movss	 DWORD PTR _v3NewEye$3[esp+140], xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 50   : 			SetEye(v3NewEye);

  0021e	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye

; 55   : /*
; 56   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 57   : 	{
; 58   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 59   : 		{
; 60   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 61   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 62   : 			SetEye(v3NewEye);
; 63   : 		}
; 64   : 	}
; 65   : 
; 66   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 67   : 	{
; 68   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 69   : 		{
; 70   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 71   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 72   : 			SetEye(v3NewEye);
; 73   : 		}
; 74   : 	}
; 75   : 
; 76   : 	// Left
; 77   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 78   : 	{
; 79   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 80   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 81   : 		{
; 82   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 83   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 84   : 			SetEye(v3NewEye);
; 85   : 		}
; 86   : 	}
; 87   : 	else
; 88   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 89   : 
; 90   : 	// Right
; 91   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 92   : 	{
; 93   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 94   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 95   : 		{
; 96   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 97   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 98   : 			SetEye(v3NewEye);
; 99   : 		}
; 100  : 	}
; 101  : 	else
; 102  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 103  : 	*/
; 104  : }

  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx
  00226	8b 4c 24 70	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+116]
  0022a	33 cc		 xor	 ecx, esp
  0022c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c3		 ret	 0
$LN5@ProcessTer:

; 51   : 		}
; 52   : 	}
; 53   : 	else
; 54   : 		SetCameraState(CAMERA_STATE_NORMAL);

  00235	6a 00		 push	 0
  00237	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN6@ProcessTer:

; 55   : /*
; 56   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 57   : 	{
; 58   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 59   : 		{
; 60   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 61   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 62   : 			SetEye(v3NewEye);
; 63   : 		}
; 64   : 	}
; 65   : 
; 66   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 67   : 	{
; 68   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 69   : 		{
; 70   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 71   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 72   : 			SetEye(v3NewEye);
; 73   : 		}
; 74   : 	}
; 75   : 
; 76   : 	// Left
; 77   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 78   : 	{
; 79   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 80   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 81   : 		{
; 82   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 83   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 84   : 			SetEye(v3NewEye);
; 85   : 		}
; 86   : 	}
; 87   : 	else
; 88   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 89   : 
; 90   : 	// Right
; 91   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 92   : 	{
; 93   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 94   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 95   : 		{
; 96   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 97   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 98   : 			SetEye(v3NewEye);
; 99   : 		}
; 100  : 	}
; 101  : 	else
; 102  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 103  : 	*/
; 104  : }

  0023c	8b 4c 24 7c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+128]
  00240	5f		 pop	 edi
  00241	5e		 pop	 esi
  00242	5b		 pop	 ebx
  00243	33 cc		 xor	 ecx, esp
  00245	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
?ProcessTerrainCollision@CCamera@@AAEXXZ ENDP		; CCamera::ProcessTerrainCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
;	COMDAT ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pOpponent$ = 8						; size = 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; CameraCollisionChecker::operator(), COMDAT
; _this$ = ecx

; 116  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 117  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00009	ff 77 08	 push	 DWORD PTR [edi+8]
  0000c	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  00011	84 c0		 test	 al, al
  00013	74 3c		 je	 SHORT $LN2@operator

; 118  :  		{
; 119  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00018	56		 push	 esi
  00019	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0001c	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00027	74 1b		 je	 SHORT $LN7@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00029	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0002d	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00031	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00034	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

  00037	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 120  : 			m_isBlocked = true;

  0003b	5e		 pop	 esi
  0003c	c6 07 01	 mov	 BYTE PTR [edi], 1
  0003f	5f		 pop	 edi

; 121  :  		}
; 122  : 	}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN7@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00044	50		 push	 eax
  00045	51		 push	 ecx
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 120  : 			m_isBlocked = true;

  0004d	c6 07 01	 mov	 BYTE PTR [edi], 1
  00050	5e		 pop	 esi
$LN2@operator:
  00051	5f		 pop	 edi

; 121  :  		}
; 122  : 	}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; CameraCollisionChecker::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CDynamicSphereInstance@@QAE@XZ
_TEXT	SEGMENT
??0CDynamicSphereInstance@@QAE@XZ PROC			; CDynamicSphereInstance::CDynamicSphereInstance, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0CDynamicSphereInstance@@QAE@XZ ENDP			; CDynamicSphereInstance::CDynamicSphereInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
;	COMDAT ?Update@CCamera@@QAEXXZ
_TEXT	SEGMENT
_fNewDistance$ = -4					; size = 4
tv133 = -4						; size = 4
?Update@CCamera@@QAEXXZ PROC				; CCamera::Update, COMDAT
; _this$ = ecx

; 317  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	51		 push	 ecx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 318  : // 	ProcessBuildingCollision();
; 319  : 
; 320  : 	RotateEyeAroundTarget(m_v3AngularVelocity.z, m_v3AngularVelocity.x);

  0001a	83 ec 08	 sub	 esp, 8
  0001d	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  00025	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0002b	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	e8 00 00 00 00	 call	 ?RotateEyeAroundTarget@CCamera@@QAEXMM@Z ; CCamera::RotateEyeAroundTarget

; 321  : 
; 322  : 	float fNewDistance=fMAX(CAMERA_MIN_DISTANCE, fMIN( CAMERA_MAX_DISTANCE, GetDistance() - m_v3AngularVelocity.y ) );

  0003d	f3 0f 10 86 34
	01 00 00	 movss	 xmm0, DWORD PTR [esi+308]
  00045	83 ec 08	 sub	 esp, 8
  00048	f3 0f 5c 86 28
	03 00 00	 subss	 xmm0, DWORD PTR [esi+808]
  00050	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  00058	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0005e	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00063	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  00068	d9 5d fc	 fstp	 DWORD PTR tv133[ebp]
  0006b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv133[ebp]
  00070	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00076	c7 04 24 00 00
	48 43		 mov	 DWORD PTR [esp], 1128792064 ; 43480000H
  0007d	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX

; 323  : 	SetDistance(fNewDistance);

  00082	83 c4 04	 add	 esp, 4
  00085	8b ce		 mov	 ecx, esi
  00087	d9 5d fc	 fstp	 DWORD PTR _fNewDistance$[ebp]
  0008a	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fNewDistance$[ebp]
  0008f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00094	e8 00 00 00 00	 call	 ?SetDistance@CCamera@@QAEXM@Z ; CCamera::SetDistance

; 324  : 	
; 325  : 	if (m_bProcessTerrainCollision)

  00099	80 be 34 03 00
	00 00		 cmp	 BYTE PTR [esi+820], 0
  000a0	74 07		 je	 SHORT $LN2@Update

; 326  :  		ProcessTerrainCollision();

  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?ProcessTerrainCollision@CCamera@@AAEXXZ ; CCamera::ProcessTerrainCollision
$LN2@Update:
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 222  :     x *= f;

  000a9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000

; 223  :     y *= f;

  000b1	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  000b9	f3 0f 10 96 24
	03 00 00	 movss	 xmm2, DWORD PTR [esi+804]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 329  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  000c1	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 223  :     y *= f;

  000c9	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000cd	f3 0f 59 d1	 mulss	 xmm2, xmm1
  000d1	f3 0f 11 86 28
	03 00 00	 movss	 DWORD PTR [esi+808], xmm0

; 224  :     z *= f;

  000d9	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  000e1	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 711  :             return (float)fabs(_X);

  000e5	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 222  :     x *= f;

  000ed	f3 0f 11 96 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 711  :             return (float)fabs(_X);

  000f5	0f 54 d1	 andps	 xmm2, xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 329  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  000f8	0f 2f da	 comiss	 xmm3, xmm2
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 224  :     z *= f;

  000fb	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 329  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  00103	76 0a		 jbe	 SHORT $LN3@Update

; 330  : 		m_v3AngularVelocity.x = 0.0f;

  00105	c7 86 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+804], 0
$LN3@Update:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 711  :             return (float)fabs(_X);

  0010f	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  00117	0f 54 c1	 andps	 xmm0, xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 331  : 	if (fabs(m_v3AngularVelocity.y) < 1.0f)

  0011a	0f 2f d8	 comiss	 xmm3, xmm0
  0011d	76 0a		 jbe	 SHORT $LN4@Update

; 332  : 		m_v3AngularVelocity.y = 0.0f;

  0011f	c7 86 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+808], 0
$LN4@Update:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 711  :             return (float)fabs(_X);

  00129	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00131	0f 54 c1	 andps	 xmm0, xmm1
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 333  : 	if (fabs(m_v3AngularVelocity.z) < 1.0f)

  00134	0f 2f d8	 comiss	 xmm3, xmm0
  00137	76 0a		 jbe	 SHORT $LN5@Update

; 334  : 		m_v3AngularVelocity.z = 0.0f;

  00139	c7 86 2c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+812], 0
$LN5@Update:

; 335  : 
; 336  : 	const float CAMERA_MOVABLE_DISTANCE = CAMERA_MAX_DISTANCE - CAMERA_MIN_DISTANCE;
; 337  : 	const float CAMERA_TARGET_DELTA = CAMERA_TARGET_FACE - CAMERA_TARGET_STANDARD;
; 338  : 	float fCameraCurMovableDistance=CAMERA_MAX_DISTANCE - GetDistance();

  00143	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  0014b	0f 28 c8	 movaps	 xmm1, xmm0
  0014e	f3 0f 5c 8e 34
	01 00 00	 subss	 xmm1, DWORD PTR [esi+308]
  00156	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43480000

; 339  : 	float fNewTargetHeight = CAMERA_TARGET_STANDARD + CAMERA_TARGET_DELTA * fCameraCurMovableDistance / CAMERA_MOVABLE_DISTANCE;
; 340  : 
; 341  : 	SetTargetHeight(fNewTargetHeight);

  0015e	51		 push	 ecx
  0015f	8b ce		 mov	 ecx, esi
  00161	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42480000
  00169	f3 0f 5e c8	 divss	 xmm1, xmm0
  0016d	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@42c80000
  00175	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0017a	e8 00 00 00 00	 call	 ?SetTargetHeight@CCamera@@QAEXM@Z ; CCamera::SetTargetHeight

; 342  : 
; 343  : 	// Cinematic
; 344  : #ifdef __20040725_CAMERA_WORK__
; 345  : 	m_MovementPosition += m_MovementSpeed;
; 346  : 	
; 347  : 	if (0.0f != m_MovementPosition.m_fViewDir)
; 348  : 		MoveFront(m_MovementPosition.m_fViewDir);
; 349  : 	if (0.0f != m_MovementPosition.m_fCrossDir)
; 350  : 		MoveAlongCross(m_MovementPosition.m_fCrossDir);
; 351  : 	if (0.0f != m_MovementPosition.m_fUpDir)
; 352  : 		MoveVertical(m_MovementPosition.m_fUpDir);
; 353  : #endif
; 354  : }

  0017f	5e		 pop	 esi
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	8b e3		 mov	 esp, ebx
  00185	5b		 pop	 ebx
  00186	c3		 ret	 0
?Update@CCamera@@QAEXXZ ENDP				; CCamera::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ PROC ; CSingleton<CPythonBackground>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ ENDP ; CSingleton<CPythonBackground>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back, COMDAT
; _this$ = ecx

; 932  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00009	74 19		 je	 SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00012	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00016	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00019	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

  0001c	83 41 04 0c	 add	 DWORD PTR [ecx+4], 12	; 0000000cH

; 933  :         _Emplace_one_at_back(_Val);
; 934  :     }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN4@push_back:

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00024	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>

; 933  :         _Emplace_one_at_back(_Val);
; 934  :     }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 4e		 je	 SHORT $LN5@vector

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	c1 f8 02	 sar	 eax, 2
  00011	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0001a	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00023	72 14		 jb	 SHORT $LN19@vector
  00025	57		 push	 edi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00026	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00029	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002c	2b d7		 sub	 edx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002e	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00031	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00034	77 23		 ja	 SHORT $LN18@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00036	8b d7		 mov	 edx, edi
  00038	5f		 pop	 edi
$LN19@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00039	51		 push	 ecx
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  00040	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00046	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  00049	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2097 :             _Myend   = nullptr;

  00050	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00057	5e		 pop	 esi

; 835  :     }

  00058	c3		 ret	 0
$LN18@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	e8 00 00 00 00	 call	 __invoke_watson
$LN27@vector:
  00068	cc		 int	 3
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ PROC ; CSingleton<CCullingManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ENDP ; CSingleton<CCullingManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_one_at_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_one_at_back<D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 839  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 840  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 841  :         auto& _My_data   = _Mypair._Myval2;
; 842  :         pointer& _Mylast = _My_data._Mylast;
; 843  : 
; 844  :         if (_Mylast != _My_data._Myend) {

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00008	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0000b	74 1e		 je	 SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00010	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00014	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 868  :         _Ty& _Result = *_Mylast;

  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 869  :         ++_Mylast;

  00021	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00024	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 849  :     }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN2@Emplace_on:

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002b	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0002e	51		 push	 ecx
  0002f	8b ca		 mov	 ecx, edx
  00031	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>

; 849  :     }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??$_Emplace_one_at_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_one_at_back<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN2@PointTest2

; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
$LN2@PointTest2:

; 61   : 		}
; 62   : 	}

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN2@RangeTestC

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
$LN2@RangeTestC:

; 47   : 	}

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<CameraCollisionChecker>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00003	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	0f 2f c1	 comiss	 xmm0, xmm1
  0000e	73 06		 jae	 SHORT $LN3@RayTraceCa
  00010	0f 2f 4d 10	 comiss	 xmm1, DWORD PTR _distance$[ebp]
  00014	72 57		 jb	 SHORT $LN6@RayTraceCa
$LN3@RayTraceCa:

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00016	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00019	53		 push	 ebx
  0001a	57		 push	 edi
  0001b	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0001e	8b 58 44	 mov	 ebx, DWORD PTR [eax+68]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 117  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00021	8b cb		 mov	 ecx, ebx
  00023	ff 77 08	 push	 DWORD PTR [edi+8]
  00026	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0002b	84 c0		 test	 al, al
  0002d	74 3c		 je	 SHORT $LN26@RayTraceCa
  0002f	56		 push	 esi

; 118  :  		{
; 119  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00030	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00033	8b cb		 mov	 ecx, ebx
  00035	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

  0003a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00040	74 1c		 je	 SHORT $LN11@RayTraceCa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00042	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00046	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0004a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0004d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

  00050	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 120  : 			m_isBlocked = true;

  00054	5e		 pop	 esi
  00055	c6 07 01	 mov	 BYTE PTR [edi], 1
  00058	5f		 pop	 edi
  00059	5b		 pop	 ebx
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h

; 34   : 	};

  0005a	5d		 pop	 ebp
  0005b	c2 14 00	 ret	 20			; 00000014H
$LN11@RayTraceCa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0005e	50		 push	 eax
  0005f	51		 push	 ecx
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\CameraProcedure.cpp

; 120  : 			m_isBlocked = true;

  00067	c6 07 01	 mov	 BYTE PTR [edi], 1
  0006a	5e		 pop	 esi
$LN26@RayTraceCa:
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx
$LN6@RayTraceCa:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h

; 34   : 	};

  0006d	5d		 pop	 ebp
  0006e	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\eterlib\CullingManager.h
;	COMDAT ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ
_TEXT	SEGMENT
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ PROC	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>, COMDAT
; _this$ = ecx

; 19   : 	{}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	c3		 ret	 0
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ENDP	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy, COMDAT
; _this$ = ecx

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2082 :         auto& _Al         = _Getal();
; 2083 :         auto& _My_data    = _Mypair._Myval2;
; 2084 :         pointer& _Myfirst = _My_data._Myfirst;
; 2085 :         pointer& _Mylast  = _My_data._Mylast;
; 2086 :         pointer& _Myend   = _My_data._Myend;
; 2087 : 
; 2088 :         _My_data._Orphan_all();
; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 4e		 je	 SHORT $LN2@Tidy

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	c1 f8 02	 sar	 eax, 2
  00011	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0001a	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00023	72 14		 jb	 SHORT $LN16@Tidy
  00025	57		 push	 edi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00026	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00029	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002c	2b d7		 sub	 edx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002e	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00031	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00034	77 23		 ja	 SHORT $LN15@Tidy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00036	8b d7		 mov	 edx, edi
  00038	5f		 pop	 edi
$LN16@Tidy:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00039	51		 push	 ecx
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

  00040	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00046	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2096 :             _Mylast  = nullptr;

  00049	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2097 :             _Myend   = nullptr;

  00050	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 2099 :     }

  00057	5e		 pop	 esi
  00058	c3		 ret	 0
$LN15@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	e8 00 00 00 00	 call	 __invoke_watson
$LN23@Tidy:
  00068	cc		 int	 3
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z PROC ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 0c		 push	 12			; 0000000cH
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ENDP ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z
_TEXT	SEGMENT
??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z PROC ; std::forward<D3DXVECTOR3 const &>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z ENDP ; std::forward<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_back_with_unused_capacity<D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00009	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0000d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00010	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00014	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00017	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 868  :         _Ty& _Result = *_Mylast;

  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 869  :         ++_Mylast;

  0001d	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00020	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 870  : 
; 871  :         return _Result;

  00023	5e		 pop	 esi

; 872  :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAUD3DXVECTOR3@@ABU2@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_back_with_unused_capacity<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
tv702 = -4						; size = 4
__Whereptr$ = 8						; size = 4
__Ptr_container$1$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();
; 878  :         auto& _My_data    = _Mypair._Myval2;
; 879  :         pointer& _Myfirst = _My_data._Myfirst;
; 880  :         pointer& _Mylast  = _My_data._Mylast;
; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00015	2b d1		 sub	 edx, ecx
  00017	f7 ea		 imul	 edx
  00019	d1 fa		 sar	 edx, 1
  0001b	8b c2		 mov	 eax, edx
  0001d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00020	03 c2		 add	 eax, edx
  00022	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	2b c1		 sub	 eax, ecx
  0002a	c1 f8 02	 sar	 eax, 2
  0002d	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765
  00033	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

  00036	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0003b	0f 84 30 01 00
	00		 je	 $LN151@Emplace_re

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

  00041	8d 50 01	 lea	 edx, DWORD PTR [eax+1]

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00044	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00047	2b c1		 sub	 eax, ecx
  00049	c1 f8 02	 sar	 eax, 2
  0004c	69 f0 ab aa aa
	aa		 imul	 esi, eax, -1431655765

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00052	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H
  00057	8b ce		 mov	 ecx, esi
  00059	d1 e9		 shr	 ecx, 1
  0005b	2b c1		 sub	 eax, ecx
  0005d	3b f0		 cmp	 esi, eax
  0005f	76 0f		 jbe	 SHORT $LN8@Emplace_re

; 2012 :             return _Max; // geometric growth would overflow

  00061	bb fc ff ff ff	 mov	 ebx, -4			; fffffffcH
  00066	8b c3		 mov	 eax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006e	eb 3b		 jmp	 SHORT $LN149@Emplace_re
$LN8@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00070	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00073	8b ca		 mov	 ecx, edx
  00075	3b c2		 cmp	 eax, edx
  00077	0f 43 c8	 cmovae	 ecx, eax
  0007a	81 f9 55 55 55
	15		 cmp	 ecx, 357913941		; 15555555H
  00080	0f 87 f0 00 00
	00		 ja	 $LN152@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00086	8d 1c 49	 lea	 ebx, DWORD PTR [ecx+ecx*2]
  00089	c1 e3 02	 shl	 ebx, 2

; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0008c	8b c3		 mov	 eax, ebx

; 227  :     if (_Bytes == 0) {

  0008e	85 c0		 test	 eax, eax
  00090	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  00092	33 f6		 xor	 esi, esi
  00094	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00096	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0009b	72 08		 jb	 SHORT $LN25@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a3	eb 06		 jmp	 SHORT $LN149@Emplace_re
$LN25@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN149@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 900  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000ab	8b f0		 mov	 esi, eax
  000ad	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000b0	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000b3	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000b6	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  000b9	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 900  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000bc	89 4d fc	 mov	 DWORD PTR tv702[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  000bf	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  000c3	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  000c7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ca	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000cd	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  000d3	8b 17		 mov	 edx, DWORD PTR [edi]
  000d5	3b c8		 cmp	 ecx, eax
  000d7	75 04		 jne	 SHORT $LN3@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000d9	8b ce		 mov	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 909  :         } else { // provide basic guarantee

  000db	eb 17		 jmp	 SHORT $LN74@Emplace_re
$LN3@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000dd	56		 push	 esi
  000de	51		 push	 ecx
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR tv702[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000eb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ee	83 c1 0c	 add	 ecx, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000f1	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
$LN74@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2064 :         pointer& _Mylast  = _My_data._Mylast;

  000f4	51		 push	 ecx
  000f5	50		 push	 eax
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>

; 2065 :         pointer& _Myend   = _My_data._Myend;
; 2066 : 
; 2067 :         _My_data._Orphan_all();
; 2068 : 
; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  000fc	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00101	85 c9		 test	 ecx, ecx
  00103	74 3c		 je	 SHORT $LN96@Emplace_re

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2071 :             _ASAN_VECTOR_REMOVE;
; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00105	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00108	2b c1		 sub	 eax, ecx
  0010a	c1 f8 02	 sar	 eax, 2
  0010d	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00113	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00116	c1 e2 02	 shl	 edx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00119	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0011f	72 16		 jb	 SHORT $LN104@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00121	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00124	83 c2 23	 add	 edx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00127	2b c8		 sub	 ecx, eax
  00129	89 45 08	 mov	 DWORD PTR __Ptr_container$1$[ebp], eax

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  0012f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00132	77 2e		 ja	 SHORT $LN103@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00134	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr_container$1$[ebp]
$LN104@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00137	52		 push	 edx
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0013e	83 c4 08	 add	 esp, 8
$LN96@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2076 :         _Mylast  = _Newvec + _Newsize;

  00141	8b 45 f8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00144	40		 inc	 eax
  00145	89 37		 mov	 DWORD PTR [edi], esi
  00147	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]

; 913  :         }
; 914  : 
; 915  :         _Guard._New_begin = nullptr;
; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 917  :         return _Newvec + _Whereoff;

  0014a	8b 45 fc	 mov	 eax, DWORD PTR tv702[ebp]

; 2076 :         _Mylast  = _Newvec + _Newsize;

  0014d	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]
  00150	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  00153	8d 0c 33	 lea	 ecx, DWORD PTR [ebx+esi]
  00156	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 918  :     }

  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c2 08 00	 ret	 8
$LN103@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00162	6a 00		 push	 0
  00164	6a 00		 push	 0
  00166	6a 00		 push	 0
  00168	6a 00		 push	 0
  0016a	6a 00		 push	 0
  0016c	e8 00 00 00 00	 call	 __invoke_watson
$LN151@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 888  :             _Xlength();

  00171	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN152@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00176	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN148@Emplace_re:
  0017b	cc		 int	 3
??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1099 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1100 :     using _Ty = typename _Alloc::value_type;
; 1101 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1102 :         for (; _First != _Last; ++_First) {
; 1103 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1104 :         }
; 1105 :     }
; 1106 : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal, COMDAT
; _this$ = ecx

; 2227 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2228 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::deallocate, COMDAT
; _this$dead$ = ecx

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN12@deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 10		 ja	 SHORT $LN11@deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN12@deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8

; 986  :     }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
$LN11@deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 __invoke_watson
$LN15@deallocate:
  00046	cc		 int	 3
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@UD3DXVECTOR3@@ABU1@@std@@YAXAAUD3DXVECTOR3@@ABU1@@Z
_TEXT	SEGMENT
??$_Construct_in_place@UD3DXVECTOR3@@ABU1@@std@@YAXAAUD3DXVECTOR3@@ABU1@@Z PROC ; std::_Construct_in_place<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 477  :     }
; 478  : }

  0000e	c3		 ret	 0
??$_Construct_in_place@UD3DXVECTOR3@@ABU1@@std@@YAXAAUD3DXVECTOR3@@ABU1@@Z ENDP ; std::_Construct_in_place<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@0@AAI@Z
_TEXT	SEGMENT
??$_Allocate_at_least_helper@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<D3DXVECTOR3> >, COMDAT
; __Al$dead$ = ecx
; __Count$ = edx

; 2295 : #if _HAS_CXX23
; 2296 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2297 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2298 :         _Count                  = _Allocated;
; 2299 :         return _Ptr;
; 2300 :     } else
; 2301 : #endif // _HAS_CXX23
; 2302 :     {
; 2303 :         return _Al.allocate(_Count);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]

; 117  :         if (_Count > _Max_possible) {

  00002	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00007	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	c1 e0 02	 shl	 eax, 2

; 227  :     if (_Bytes == 0) {

  00013	85 c0		 test	 eax, eax
  00015	75 01		 jne	 SHORT $LN10@Allocate_a

; 2304 :     }
; 2305 : }

  00017	c3		 ret	 0
$LN10@Allocate_a:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	50		 push	 eax
  00019	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001e	72 09		 jb	 SHORT $LN12@Allocate_a

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00020	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>

; 2304 :     }
; 2305 : }

  00025	83 c4 04	 add	 esp, 4
  00028	c3		 ret	 0
$LN12@Allocate_a:

; 136  :         return ::operator new(_Bytes);

  00029	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 2304 :     }
; 2305 : }

  0002e	83 c4 04	 add	 esp, 4
  00031	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z PROC ; std::_Unfancy<D3DXVECTOR3>, COMDAT
; __Ptr$ = ecx

; 69   :     return _Ptr;

  00000	8b c1		 mov	 eax, ecx

; 70   : }

  00002	c3		 ret	 0
??$_Unfancy@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ENDP ; std::_Unfancy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@UD3DXVECTOR3@@ABU1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@ABU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UD3DXVECTOR3@@ABU1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000a	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 734  :     }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$construct@UD3DXVECTOR3@@ABU1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUD3DXVECTOR3@@@std@@YA?A_TABQAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUD3DXVECTOR3@@@std@@YA?A_TABQAUD3DXVECTOR3@@@Z PROC ; std::_Get_unwrapped<D3DXVECTOR3 * const &>, COMDAT
; __It$ = ecx

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAUD3DXVECTOR3@@@std@@YA?A_TABQAUD3DXVECTOR3@@@Z ENDP ; std::_Get_unwrapped<D3DXVECTOR3 * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1977 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	8b f1		 mov	 esi, ecx
  0000d	53		 push	 ebx
  0000e	57		 push	 edi
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>

; 1993 :             return _Dest + (_ULast - _UFirst);

  00015	2b fe		 sub	 edi, esi
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	f7 ef		 imul	 edi
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	d1 fa		 sar	 edx, 1
  00023	8b c2		 mov	 eax, edx
  00025	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00028	03 c2		 add	 eax, edx
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0002f	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00032	5b		 pop	 ebx

; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1999 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 2000 :     }
; 2001 : 
; 2002 :     return _Backout._Release();
; 2003 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<D3DXVECTOR3>,std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1539 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1540 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<D3DXVECTOR3>,std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 621  :             if (_New_begin != nullptr) {

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	74 2f		 je	 SHORT $LN8@Reallocati
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000a	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0000d	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 14		 jb	 SHORT $LN16@Reallocati
  00018	56		 push	 esi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 72 fc	 mov	 esi, DWORD PTR [edx-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b d6		 sub	 edx, esi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 0e		 ja	 SHORT $LN15@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b d6		 mov	 edx, esi
  0002b	5e		 pop	 esi
$LN16@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00033	83 c4 08	 add	 esp, 8
$LN8@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 625  :         }

  00036	c3		 ret	 0
$LN15@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 __invoke_watson
$LN23@Reallocati:
  00046	cc		 int	 3
??1_Reallocation_guard@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 2223 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 2184 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array, COMDAT
; _this$ = ecx

; 2059 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2060 :         // orphan all iterators, discard old array, acquire new array
; 2061 :         auto& _Al         = _Getal();
; 2062 :         auto& _My_data    = _Mypair._Myval2;
; 2063 :         pointer& _Myfirst = _My_data._Myfirst;
; 2064 :         pointer& _Mylast  = _My_data._Mylast;
; 2065 :         pointer& _Myend   = _My_data._Myend;
; 2066 : 
; 2067 :         _My_data._Orphan_all();
; 2068 : 
; 2069 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 16		 mov	 edx, DWORD PTR [esi]
  00008	85 d2		 test	 edx, edx
  0000a	74 3a		 je	 SHORT $LN8@Change_arr

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2071 :             _ASAN_VECTOR_REMOVE;
; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000f	2b c2		 sub	 eax, edx
  00011	c1 f8 02	 sar	 eax, 2
  00014	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001a	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0001d	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00020	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00026	72 14		 jb	 SHORT $LN16@Change_arr
  00028	57		 push	 edi

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  0002c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	2b d7		 sub	 edx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00034	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00037	77 2f		 ja	 SHORT $LN15@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00039	8b d7		 mov	 edx, edi
  0003b	5f		 pop	 edi
$LN16@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003c	51		 push	 ecx
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00043	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector

; 2075 :         _Myfirst = _Newvec;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 2076 :         _Mylast  = _Newvec + _Newsize;

  00049	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0004c	89 0e		 mov	 DWORD PTR [esi], ecx
  0004e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00051	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00054	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2077 :         _Myend   = _Newvec + _Newcapacity;

  00057	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0005a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0005d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00060	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00063	5e		 pop	 esi

; 2079 :     }

  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	e8 00 00 00 00	 call	 __invoke_watson
$LN23@Change_arr:
  00077	cc		 int	 3
?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2006 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00008	b9 55 55 55 15	 mov	 ecx, 357913941		; 15555555H

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000d	c1 f8 02	 sar	 eax, 2

; 2006 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

  00010	57		 push	 edi

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00011	69 f8 ab aa aa
	aa		 imul	 edi, eax, -1431655765

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00017	8b d7		 mov	 edx, edi
  00019	d1 ea		 shr	 edx, 1
  0001b	2b ca		 sub	 ecx, edx
  0001d	3b f9		 cmp	 edi, ecx
  0001f	76 0a		 jbe	 SHORT $LN2@Calculate_

; 2012 :             return _Max; // geometric growth would overflow

  00021	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H
  00026	5f		 pop	 edi

; 2018 :             return _Newsize; // geometric growth would be insufficient
; 2019 :         }
; 2020 : 
; 2021 :         return _Geometric; // geometric growth is sufficient
; 2022 :     }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN2@Calculate_:

; 2013 :         }
; 2014 : 
; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0002b	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]

; 2016 : 
; 2017 :         if (_Geometric < _Newsize) {

  0002e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00031	5f		 pop	 edi
  00032	0f 42 45 08	 cmovb	 eax, DWORD PTR __Newsize$[ebp]

; 2018 :             return _Newsize; // geometric growth would be insufficient
; 2019 :         }
; 2020 : 
; 2021 :         return _Geometric; // geometric growth is sufficient
; 2022 :     }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size, COMDAT
; _this$dead$ = ecx

; 1919 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1920 :     }

  00005	c3		 ret	 0
?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
??$addressof@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@AAU1@@Z PROC ; std::addressof<D3DXVECTOR3>, COMDAT
; __Val$ = ecx

; 1525 :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 1526 : }

  00002	c3		 ret	 0
??$addressof@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::addressof<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@UD3DXVECTOR3@@ABU1@@std@@YAPAUD3DXVECTOR3@@QAU1@ABU1@@Z
_TEXT	SEGMENT
??$construct_at@UD3DXVECTOR3@@ABU1@@std@@YAPAUD3DXVECTOR3@@QAU1@ABU1@@Z PROC ; std::construct_at<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	8b c1		 mov	 eax, ecx

; 464  : }

  00010	c3		 ret	 0
??$construct_at@UD3DXVECTOR3@@ABU1@@std@@YAPAUD3DXVECTOR3@@QAU1@ABU1@@Z ENDP ; std::construct_at<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAUD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAUD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z PROC ; std::move<D3DXVECTOR3 &>, COMDAT
; __Arg$ = ecx

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1514 : }

  00002	c3		 ret	 0
??$move@AAUD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::move<D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z PROC ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>, COMDAT

; 4762 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4763 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4764 :     const auto _First_ptr    = _STD _To_address(_First);
; 4765 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4766 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2
  00010	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765

; 4767 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4768 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4769 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4770 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 4771 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ENDP ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_To_address@PAUD3DXVECTOR3@@@std@@YA?A_PABQAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
??$_To_address@PAUD3DXVECTOR3@@@std@@YA?A_PABQAUD3DXVECTOR3@@@Z PROC ; std::_To_address<D3DXVECTOR3 *>, COMDAT
; __Val$ = ecx

; 4616 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4617 :     return _STD to_address(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 4618 : }

  00002	c3		 ret	 0
??$_To_address@PAUD3DXVECTOR3@@@std@@YA?A_PABQAUD3DXVECTOR3@@@Z ENDP ; std::_To_address<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Emplace_back@UD3DXVECTOR3@@@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEX$$QAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@UD3DXVECTOR3@@@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEX$$QAUD3DXVECTOR3@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Emplace_back<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 1843 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000d	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00014	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

  00017	83 41 04 0c	 add	 DWORD PTR [ecx+4], 12	; 0000000cH

; 1846 :     }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??$_Emplace_back@UD3DXVECTOR3@@@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEX$$QAUD3DXVECTOR3@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Emplace_back<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Release, COMDAT
; _this$ = ecx

; 1849 :         _First = _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	89 01		 mov	 DWORD PTR [ecx], eax

; 1850 :         return _Last;
; 1851 :     }

  00005	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::~_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 1839 :         _STD _Destroy_range(_First, _Last, _Al);
; 1840 :     }

  00000	c2 00 00	 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::~_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@PAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@PAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Al_$[ebp]
  0000e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00011	8b c1		 mov	 eax, ecx
  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@PAUD3DXVECTOR3@@AAV?$allocator@UD3DXVECTOR3@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >::_Uninitialized_backout_al<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 747  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEABV?$allocator@UD3DXVECTOR3@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEABV?$allocator@UD3DXVECTOR3@@@2@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal, COMDAT
; _this$ = ecx

; 2231 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2232 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEABV?$allocator@UD3DXVECTOR3@@@2@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity, COMDAT
; _this$ = ecx

; 1923 :         auto& _My_data = _Mypair._Myval2;
; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2
  00008	69 c0 ab aa aa
	aa		 imul	 eax, eax, -1431655765

; 1925 :     }

  0000e	c3		 ret	 0
?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::allocate, COMDAT
; _this$dead$ = ecx

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  :         if (_Count > _Max_possible) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0000b	77 2e		 ja	 SHORT $LN19@allocate

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	c1 e0 02	 shl	 eax, 2

; 227  :     if (_Bytes == 0) {

  00013	85 c0		 test	 eax, eax
  00015	75 04		 jne	 SHORT $LN8@allocate

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN8@allocate:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0001b	50		 push	 eax
  0001c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00021	72 0c		 jb	 SHORT $LN10@allocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00023	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00028	83 c4 04	 add	 esp, 4
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN10@allocate:

; 136  :         return ::operator new(_Bytes);

  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

  00034	83 c4 04	 add	 esp, 4
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN19@allocate:

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0003b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN16@allocate:
  00040	cc		 int	 3
?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$to_address@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QAU1@@Z
_TEXT	SEGMENT
??$to_address@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QAU1@@Z PROC ; std::to_address<D3DXVECTOR3>, COMDAT
; __Val$ = ecx

; 541  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 542  :     return _Val;

  00000	8b c1		 mov	 eax, ecx

; 543  : }

  00002	c3		 ret	 0
??$to_address@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QAU1@@Z ENDP ; std::to_address<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AAPAUD3DXVECTOR3@@@std@@YA$$QAPAUD3DXVECTOR3@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUD3DXVECTOR3@@@std@@YA$$QAPAUD3DXVECTOR3@@AAPAU1@@Z PROC ; std::move<D3DXVECTOR3 * &>, COMDAT
; __Arg$ = ecx

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1514 : }

  00002	c3		 ret	 0
??$move@AAPAUD3DXVECTOR3@@@std@@YA$$QAPAUD3DXVECTOR3@@AAPAU1@@Z ENDP ; std::move<D3DXVECTOR3 * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z PROC ; std::_Copy_memmove_tail<D3DXVECTOR3 *>, COMDAT

; 4747 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4748 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4749 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4750 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4751 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4752 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4753 :         (void) _Object_count;
; 4754 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4755 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4756 :     } else {
; 4757 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4758 :     }
; 4759 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ENDP ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z PROC ; std::forward<D3DXVECTOR3>, COMDAT
; __Arg$ = ecx

; 1502 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1503 : }

  00002	c3		 ret	 0
??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::forward<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@$$QAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000a	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 734  :     }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$construct@UD3DXVECTOR3@@U1@@?$_Default_allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@QAUD3DXVECTOR3@@$$QAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0M@@std@@YAII@Z PROC			; std::_Get_size_of_n<12>, COMDAT
; __Count$ = ecx

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {

  00000	81 f9 55 55 55
	15		 cmp	 ecx, 357913941		; 15555555H
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0000c	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0000f	c1 e0 02	 shl	 eax, 2

; 123  : }

  00012	c3		 ret	 0
??$_Get_size_of_n@$0M@@std@@YAII@Z ENDP			; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QBEABV?$allocator@UD3DXVECTOR3@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QBEABV?$allocator@UD3DXVECTOR3@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<D3DXVECTOR3>,std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1543 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1544 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UD3DXVECTOR3@@@std@@V?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@2@$00@std@@QBEABV?$allocator@UD3DXVECTOR3@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<D3DXVECTOR3>,std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@UD3DXVECTOR3@@U1@@std@@YAPAUD3DXVECTOR3@@QAU1@$$QAU1@@Z
_TEXT	SEGMENT
??$construct_at@UD3DXVECTOR3@@U1@@std@@YAPAUD3DXVECTOR3@@QAU1@$$QAU1@@Z PROC ; std::construct_at<D3DXVECTOR3,D3DXVECTOR3>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00004	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00008	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000e	8b c1		 mov	 eax, ecx

; 464  : }

  00010	c3		 ret	 0
??$construct_at@UD3DXVECTOR3@@U1@@std@@YAPAUD3DXVECTOR3@@QAU1@$$QAU1@@Z ENDP ; std::construct_at<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ??0SpherePackCallback@@QAE@XZ
_TEXT	SEGMENT
??0SpherePackCallback@@QAE@XZ PROC			; SpherePackCallback::SpherePackCallback, COMDAT
; _this$ = ecx

; 55   : 	SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SpherePackCallback@@QAE@XZ ENDP			; SpherePackCallback::SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GSpherePackCallback@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSpherePackCallback@@UAEPAXI@Z PROC			; SpherePackCallback::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GSpherePackCallback@@UAEPAXI@Z ENDP			; SpherePackCallback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::VisibilityCallback, COMDAT
; _this$ = ecx

; 61   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; SpherePackCallback::RayTraceCallback, COMDAT
; _this$ = ecx

; 68   : 	{};

  00000	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; SpherePackCallback::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::RangeTestCallback, COMDAT
; _this$ = ecx

; 74   : 	{};

  00000	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::PointTest2dCallback, COMDAT
; _this$ = ecx

; 79   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ??1SpherePackCallback@@UAE@XZ
_TEXT	SEGMENT
??1SpherePackCallback@@UAE@XZ PROC			; SpherePackCallback::~SpherePackCallback, COMDAT
; _this$ = ecx

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	c3		 ret	 0
??1SpherePackCallback@@UAE@XZ ENDP			; SpherePackCallback::~SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\spherepack.h
;	COMDAT ?GetUserData@SpherePack@@QBEPAXXZ
_TEXT	SEGMENT
?GetUserData@SpherePack@@QBEPAXXZ PROC			; SpherePack::GetUserData, COMDAT
; _this$ = ecx

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	c3		 ret	 0
?GetUserData@SpherePack@@QBEPAXXZ ENDP			; SpherePack::GetUserData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
__X$ = 8						; size = 4
tv68 = 8						; size = 4
_fabsf	PROC						; COMDAT

; 710  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 711  :             return (float)fabs(_X);

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]
  00008	0f 54 05 00 00
	00 00		 andps	 xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
  0000f	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  00014	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 712  :         }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cmath
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cmath
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
?fabs@@YAMM@Z PROC					; fabs, COMDAT
; __Xx$ = xmm0s
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 711  :             return (float)fabs(_X);

  00000	0f 54 05 00 00
	00 00		 andps	 xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cmath

; 118  : }

  00007	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??XD3DXVECTOR3@@QAEAAU0@M@Z PROC			; D3DXVECTOR3::operator*=, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  :     x *= f;

  00003	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _f$[ebp]

; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;

  00008	8b c1		 mov	 eax, ecx
  0000a	0f 28 c1	 movaps	 xmm0, xmm1
  0000d	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  00011	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00015	0f 28 c1	 movaps	 xmm0, xmm1
  00018	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [ecx+4]
  0001d	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  00022	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00027	f3 0f 11 49 08	 movss	 DWORD PTR [ecx+8], xmm1

; 226  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??XD3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC		; D3DXVec3Dot, COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00018	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001b	de c1		 faddp	 ST(1), ST(0)

; 1265 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00003	8b 45 10	 mov	 eax, DWORD PTR _pV2$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00009	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [eax+8]
  0000e	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  00013	0f 28 cb	 movaps	 xmm1, xmm3
  00016	f3 0f 10 79 04	 movss	 xmm7, DWORD PTR [ecx+4]
  0001b	0f 28 c4	 movaps	 xmm0, xmm4
  0001e	f3 0f 10 51 08	 movss	 xmm2, DWORD PTR [ecx+8]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00023	f3 0f 10 30	 movss	 xmm6, DWORD PTR [eax]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1280 : 
; 1281 :     *pOut = v;

  00027	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  0002a	f3 0f 10 29	 movss	 xmm5, DWORD PTR [ecx]
  0002e	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00032	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00036	f3 0f 5c c8	 subss	 xmm1, xmm0
  0003a	0f 28 c5	 movaps	 xmm0, xmm5
  0003d	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00041	f3 0f 59 ec	 mulss	 xmm5, xmm4
  00045	f3 0f 11 08	 movss	 DWORD PTR [eax], xmm1
  00049	0f 28 ce	 movaps	 xmm1, xmm6
  0004c	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00050	f3 0f 59 f7	 mulss	 xmm6, xmm7
  00054	f3 0f 5c c8	 subss	 xmm1, xmm0
  00058	f3 0f 5c ee	 subss	 xmm5, xmm6
  0005c	f3 0f 11 48 04	 movss	 DWORD PTR [eax+4], xmm1
  00061	f3 0f 11 68 08	 movss	 DWORD PTR [eax+8], xmm5

; 1282 :     return pOut;
; 1283 : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\vector.h
;	COMDAT ?Set@Vector3d@@QAEXMMM@Z
_TEXT	SEGMENT
?Set@Vector3d@@QAEXMMM@Z PROC				; Vector3d::Set, COMDAT
; _this$ = ecx
; _a$ = xmm1s
; _b$ = xmm2s
; _c$ = xmm3s

; 107  : 		x = a;

  00000	f3 0f 11 09	 movss	 DWORD PTR [ecx], xmm1

; 108  : 		y = b;

  00004	f3 0f 11 51 04	 movss	 DWORD PTR [ecx+4], xmm2

; 109  : 		z = c;

  00009	f3 0f 11 59 08	 movss	 DWORD PTR [ecx+8], xmm3

; 110  : 	};

  0000e	c3		 ret	 0
?Set@Vector3d@@QAEXMMM@Z ENDP				; Vector3d::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\SphereLib\vector.h
;	COMDAT ??0Vector3d@@QAE@XZ
_TEXT	SEGMENT
??0Vector3d@@QAE@XZ PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 26   : 	Vector3d(void) { };  // null constructor, does not inialize point.

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0Vector3d@@QAE@XZ ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 798  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]
  0000b	0f 57 c9	 xorps	 xmm1, xmm1

; 799  :             return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	83 ec 08	 sub	 esp, 8
  00014	66 0f 2e c8	 ucomisd xmm1, xmm0
  00018	77 16		 ja	 SHORT $LN3@sqrtf
  0001a	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  0001e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00022	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv71[esp+8], xmm0
  00028	d9 44 24 04	 fld	 DWORD PTR tv71[esp+8]

; 800  :         }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN3@sqrtf:

; 799  :             return (float)sqrt(_X);

  00030	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00035	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00039	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv71[esp+8], xmm0
  0003f	d9 44 24 04	 fld	 DWORD PTR tv71[esp+8]

; 800  :         }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv187 = -4						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00006	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00009	83 ec 08	 sub	 esp, 8
  0000c	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00011	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00015	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001a	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0001e	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00022	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00026	f3 0f 58 d1	 addss	 xmm2, xmm1
  0002a	0f 57 c9	 xorps	 xmm1, xmm1
  0002d	f3 0f 58 d0	 addss	 xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 799  :             return (float)sqrt(_X);

  00031	0f 5a c2	 cvtps2pd xmm0, xmm2
  00034	66 0f 2e c8	 ucomisd xmm1, xmm0
  00038	77 16		 ja	 SHORT $LN5@D3DXVec3Le
  0003a	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  0003e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00042	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv187[esp+8], xmm0
  00048	d9 44 24 04	 fld	 DWORD PTR tv187[esp+8]

; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN5@D3DXVec3Le:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 799  :             return (float)sqrt(_X);

  00050	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00055	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00059	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv187[esp+8], xmm0
  0005f	d9 44 24 04	 fld	 DWORD PTR tv187[esp+8]

; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv69 = -8						; size = 8
tv75 = -8						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 724  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 725  :             return (float)floor(_X);

  0000e	83 ec 08	 sub	 esp, 8
  00011	0f 5a c0	 cvtps2pd xmm0, xmm0
  00014	f2 0f 11 44 24
	40		 movsd	 QWORD PTR tv69[esp+72], xmm0
  0001a	dd 44 24 40	 fld	 QWORD PTR tv69[esp+72]
  0001e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00021	e8 00 00 00 00	 call	 _floor
  00026	d9 5c 24 40	 fstp	 DWORD PTR tv75[esp+72]
  0002a	d9 44 24 40	 fld	 DWORD PTR tv75[esp+72]
  0002e	83 c4 08	 add	 esp, 8

; 726  :         }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT
; ___$ReturnUdt$ = ecx
; _f$ = xmm1s
; _v$ = edx

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00000	0f 28 c1	 movaps	 xmm0, xmm1
  00003	8b c1		 mov	 eax, ecx
  00005	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00009	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0000d	0f 28 c1	 movaps	 xmm0, xmm1
  00010	f3 0f 59 42 04	 mulss	 xmm0, DWORD PTR [edx+4]
  00015	f3 0f 59 4a 08	 mulss	 xmm1, DWORD PTR [edx+8]

; 181  :     y = fy;

  0001a	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 182  :     z = fz;

  0001f	f3 0f 11 49 08	 movss	 DWORD PTR [ecx+8], xmm1

; 284  : }

  00024	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
END
