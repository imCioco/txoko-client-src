; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35217.0 

	TITLE	d:\_m2work\txoko-m2-work\txoko-client-src\vs_files\userinterface\distribute\markimage.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@ ; `string'
PUBLIC	??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@ ; `string'
PUBLIC	??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@ ; `string'
PUBLIC	??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@ ; `string'
PUBLIC	??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDa@ ; `string'
PUBLIC	??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6@ ; `string'
PUBLIC	??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@ ; `string'
PUBLIC	??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@ ; `string'
PUBLIC	??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks@ ; `string'
PUBLIC	??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@ ; `string'
PUBLIC	??_R2CGuildMarkImage@@8				; CGuildMarkImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGuildMarkImage@@8		; CGuildMarkImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CGuildMarkImage@@8				; CGuildMarkImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCGuildMarkImage@@@8			; CGuildMarkImage `RTTI Type Descriptor'
PUBLIC	??_R4CGuildMarkImage@@6B@			; CGuildMarkImage::`RTTI Complete Object Locator'
PUBLIC	?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A	; CSingleton<CLZO>::ms_singleton
PUBLIC	??_7CGuildMarkImage@@6B@			; CGuildMarkImage::`vftable'
EXTRN	_lzo1x_999_compress:PROC
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	?GetWorkMemory@CLZO@@QAEPAEXZ:PROC		; CLZO::GetWorkMemory
EXTRN	_lzo1x_decompress_safe:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	__imp__ilSetPixels@36:PROC
EXTRN	_free:PROC
EXTRN	__imp__ilTexImage@28:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__ilSave@8:PROC
;	COMDAT ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A DD 01H DUP (?) ; CSingleton<CLZO>::ms_singleton
_BSS	ENDS
;	COMDAT ??_7CGuildMarkImage@@6B@
CONST	SEGMENT
??_7CGuildMarkImage@@6B@ DD FLAT:??_R4CGuildMarkImage@@6B@ ; CGuildMarkImage::`vftable'
	DD	FLAT:??_ECGuildMarkImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CGuildMarkImage@@6B@
rdata$r	SEGMENT
??_R4CGuildMarkImage@@6B@ DD 00H			; CGuildMarkImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGuildMarkImage@@@8
	DD	FLAT:??_R3CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGuildMarkImage@@@8
data$rs	SEGMENT
??_R0?AVCGuildMarkImage@@@8 DD FLAT:??_7type_info@@6B@	; CGuildMarkImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGuildMarkImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CGuildMarkImage@@8
rdata$r	SEGMENT
??_R3CGuildMarkImage@@8 DD 00H				; CGuildMarkImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGuildMarkImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGuildMarkImage@@8 DD FLAT:??_R0?AVCGuildMarkImage@@@8 ; CGuildMarkImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CGuildMarkImage@@8
rdata$r	SEGMENT
??_R2CGuildMarkImage@@8 DD FLAT:??_R1A@?0A@EA@CGuildMarkImage@@8 ; CGuildMarkImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@
CONST	SEGMENT
??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@ DB 'SGuildMarkBlo'
	DB	'ck::Compress: Error! %u > %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks@
CONST	SEGMENT
??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks@ DB 'CGuildMarkImage'
	DB	'::BuildAllBlocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@
CONST	SEGMENT
??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@ DB 'CGuildMarkImage'
	DB	'::CopyBlockFromCompressedData: image corrupted, decompressed '
	DB	'size = %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@
CONST	SEGMENT
??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@ DB 'CGuildMarkImage'
	DB	'::CopyBlockFromCompressedData: cannot decompress, compressed '
	DB	'size = %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6@
CONST	SEGMENT
??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6@ DB 'PutMark pos %u'
	DB	' %ux%u', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDa@
CONST	SEGMENT
??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDa@ DB 'CGuildMarkImage'
	DB	'::CopyMarkFromData: Invalid mark position %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@
CONST	SEGMENT
??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@ DB 'CGuildMark'
	DB	'Image: %s height must be %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@
CONST	SEGMENT
??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@ DB 'CGuildMar'
	DB	'kImage: %s width must be %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@
CONST	SEGMENT
??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@ DB 'CGuildMarkIma'
	DB	'ge: cannot open file for writing %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@
CONST	SEGMENT
??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@ DB 'CGuildMarkImag'
	DB	'e: cannot initialize image', 00H		; `string'
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	??R?$less@E@std@@QBE_NABE0@Z			; std::less<unsigned char>::operator()
PUBLIC	?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ	; CSingleton<CLZO>::Instance
PUBLIC	?Compress@SGuildMarkBlock@@QAEXPBK@Z		; SGuildMarkBlock::Compress
PUBLIC	?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z		; SGuildMarkBlock::CopyFrom
PUBLIC	?GetCRC@SGuildMarkBlock@@QBEKXZ			; SGuildMarkBlock::GetCRC
PUBLIC	?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z	; CGuildMarkImage::GetBlockCRCList
PUBLIC	?BuildAllBlocks@CGuildMarkImage@@AAEXXZ		; CGuildMarkImage::BuildAllBlocks
PUBLIC	?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z ; CGuildMarkImage::SaveBlockFromCompressedData
PUBLIC	?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z		; CGuildMarkImage::GetData
PUBLIC	?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z		; CGuildMarkImage::PutData
PUBLIC	?Load@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Load
PUBLIC	?Build@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Build
PUBLIC	?Save@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Save
PUBLIC	?Create@CGuildMarkImage@@QAEXXZ			; CGuildMarkImage::Create
PUBLIC	?Destroy@CGuildMarkImage@@QAEXXZ		; CGuildMarkImage::Destroy
PUBLIC	??1CGuildMarkImage@@UAE@XZ			; CGuildMarkImage::~CGuildMarkImage
PUBLIC	??_GCGuildMarkImage@@UAEPAXI@Z			; CGuildMarkImage::`scalar deleting destructor'
PUBLIC	??0CGuildMarkImage@@QAE@XZ			; CGuildMarkImage::CGuildMarkImage
EXTRN	??_ECGuildMarkImage@@UAEPAXI@Z:PROC		; CGuildMarkImage::`vector deleting destructor'
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ??0CGuildMarkImage@@QAE@XZ
_TEXT	SEGMENT
??0CGuildMarkImage@@QAE@XZ PROC				; CGuildMarkImage::CGuildMarkImage, COMDAT
; _this$ = ecx

; 28   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGuildMarkImage@@6B@

; 29   : 	m_uImg = INVALID_HANDLE;
; 30   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 81 c4 07 5f
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+6227908], -1
  00012	c3		 ret	 0
??0CGuildMarkImage@@QAE@XZ ENDP				; CGuildMarkImage::CGuildMarkImage
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCGuildMarkImage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGuildMarkImage@@UAEPAXI@Z PROC			; CGuildMarkImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGuildMarkImage@@UAE@XZ ; CGuildMarkImage::~CGuildMarkImage
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 c8 07 5f 00	 push	 6227912			; 005f07c8H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCGuildMarkImage@@UAEPAXI@Z ENDP			; CGuildMarkImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ??1CGuildMarkImage@@UAE@XZ
_TEXT	SEGMENT
??1CGuildMarkImage@@UAE@XZ PROC				; CGuildMarkImage::~CGuildMarkImage, COMDAT
; _this$ = ecx

; 33   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGuildMarkImage@@6B@

; 34   : 	Destroy();

  00006	e9 00 00 00 00	 jmp	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy
??1CGuildMarkImage@@UAE@XZ ENDP				; CGuildMarkImage::~CGuildMarkImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?Destroy@CGuildMarkImage@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CGuildMarkImage@@QAEXXZ PROC			; CGuildMarkImage::Destroy, COMDAT
; _this$ = ecx

; 39   : 	if (INVALID_HANDLE == m_uImg)

  00000	83 b9 c4 07 5f
	00 ff		 cmp	 DWORD PTR [ecx+6227908], -1
  00007	56		 push	 esi
  00008	8d b1 c4 07 5f
	00		 lea	 esi, DWORD PTR [ecx+6227908]
  0000e	74 0f		 je	 SHORT $LN1@Destroy

; 40   : 		return;
; 41   : 
; 42   : 	ilDeleteImages(1, &m_uImg);

  00010	56		 push	 esi
  00011	6a 01		 push	 1
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilDeleteImages@8

; 43   : 	m_uImg = INVALID_HANDLE;

  00019	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN1@Destroy:

; 44   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?Destroy@CGuildMarkImage@@QAEXXZ ENDP			; CGuildMarkImage::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?Create@CGuildMarkImage@@QAEXXZ
_TEXT	SEGMENT
?Create@CGuildMarkImage@@QAEXXZ PROC			; CGuildMarkImage::Create, COMDAT
; _this$ = ecx

; 48   : 	if (INVALID_HANDLE != m_uImg)

  00000	81 c1 c4 07 5f
	00		 add	 ecx, 6227908		; 005f07c4H
  00006	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00009	75 09		 jne	 SHORT $LN1@Create

; 49   : 		return;
; 50   : 
; 51   : 	ilGenImages(1, &m_uImg);

  0000b	51		 push	 ecx
  0000c	6a 01		 push	 1
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGenImages@8
$LN1@Create:

; 52   : }

  00014	c3		 ret	 0
?Create@CGuildMarkImage@@QAEXXZ ENDP			; CGuildMarkImage::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?Save@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Save@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Save, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 56   : 	ilEnable(IL_FILE_OVERWRITE);

  00004	68 20 06 00 00	 push	 1568			; 00000620H
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 57   : 	ilBindImage(m_uImg);

  00011	ff b6 c4 07 5f
	00		 push	 DWORD PTR [esi+6227908]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 58   : 
; 59   : 	if (!ilSave(IL_TGA, (const ILstring)c_szFileName))

  0001d	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00020	68 2d 04 00 00	 push	 1069			; 0000042dH
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSave@8
  0002b	84 c0		 test	 al, al

; 60   : 		return false;

  0002d	5e		 pop	 esi
  0002e	0f 95 c0	 setne	 al

; 61   : 
; 62   : 	return true;
; 63   : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?Save@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Save
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?Build@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Build@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Build, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 67   : 	Destroy();

  00006	e8 00 00 00 00	 call	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy

; 68   : 	Create();

  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ?Create@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Create

; 69   : 
; 70   : 	ilBindImage(m_uImg);

  00012	ff b6 c4 07 5f
	00		 push	 DWORD PTR [esi+6227908]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 71   : 	ilEnable(IL_ORIGIN_SET);

  0001e	68 00 06 00 00	 push	 1536			; 00000600H
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 72   : 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

  00029	68 02 06 00 00	 push	 1538			; 00000602H
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilOriginFunc@4

; 73   : 
; 74   : 	BYTE * data = (BYTE *) malloc(sizeof(Pixel) * WIDTH * HEIGHT);

  00034	68 00 00 10 00	 push	 1048576			; 00100000H
  00039	e8 00 00 00 00	 call	 _malloc

; 75   : 	memset(data, 0, sizeof(Pixel) * WIDTH * HEIGHT);

  0003e	68 00 00 10 00	 push	 1048576			; 00100000H
  00043	8b f0		 mov	 esi, eax
  00045	6a 00		 push	 0
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 76   : 
; 77   : 	if (!ilTexImage(WIDTH, HEIGHT, 1, 4, IL_BGRA, IL_UNSIGNED_BYTE, data))

  00050	56		 push	 esi
  00051	68 01 14 00 00	 push	 5121			; 00001401H
  00056	68 e1 80 00 00	 push	 32993			; 000080e1H
  0005b	6a 04		 push	 4
  0005d	6a 01		 push	 1
  0005f	68 00 02 00 00	 push	 512			; 00000200H
  00064	68 00 02 00 00	 push	 512			; 00000200H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilTexImage@28
  0006f	84 c0		 test	 al, al
  00071	75 14		 jne	 SHORT $LN2@Build

; 78   : 	{
; 79   : 		sys_err("CGuildMarkImage: cannot initialize image");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@
  00078	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007d	83 c4 04	 add	 esp, 4

; 80   : 		return false;

  00080	32 c0		 xor	 al, al
  00082	5e		 pop	 esi

; 88   : 		return false;
; 89   : 
; 90   : 	return true;
; 91   : }

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN2@Build:

; 81   : 	}
; 82   : 
; 83   : 	free(data);

  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _free
  0008d	83 c4 04	 add	 esp, 4

; 84   : 
; 85   : 	ilEnable(IL_FILE_OVERWRITE);

  00090	68 20 06 00 00	 push	 1568			; 00000620H
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 86   : 
; 87   : 	if (!ilSave(IL_TGA, (const ILstring)c_szFileName))

  0009b	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0009e	68 2d 04 00 00	 push	 1069			; 0000042dH
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSave@8
  000a9	84 c0		 test	 al, al
  000ab	5e		 pop	 esi
  000ac	0f 95 c0	 setne	 al

; 88   : 		return false;
; 89   : 
; 90   : 	return true;
; 91   : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
?Build@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Build
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?Load@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Load@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Load, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 95   : 	Destroy();

  00007	e8 00 00 00 00	 call	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy

; 96   : 	Create();	

  0000c	8b cf		 mov	 ecx, edi
  0000e	e8 00 00 00 00	 call	 ?Create@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Create

; 97   : 
; 98   : 	ilBindImage(m_uImg);

  00013	ff b7 c4 07 5f
	00		 push	 DWORD PTR [edi+6227908]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 99   : 	ilEnable(IL_ORIGIN_SET);

  0001f	68 00 06 00 00	 push	 1536			; 00000600H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 100  : 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

  0002a	68 02 06 00 00	 push	 1538			; 00000602H
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilOriginFunc@4

; 101  : 
; 102  : 	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring) c_szFileName))

  00035	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
  00038	56		 push	 esi
  00039	6a 00		 push	 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilLoad@8
  00041	84 c0		 test	 al, al
  00043	75 2a		 jne	 SHORT $LN3@Load

; 103  : 	{
; 104  : 		Build(c_szFileName);

  00045	56		 push	 esi
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?Build@CGuildMarkImage@@QAE_NPBD@Z ; CGuildMarkImage::Build

; 105  : 		
; 106  : 		if (!Load(c_szFileName))

  0004d	56		 push	 esi
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?Load@CGuildMarkImage@@QAE_NPBD@Z ; CGuildMarkImage::Load
  00055	84 c0		 test	 al, al
  00057	75 16		 jne	 SHORT $LN3@Load

; 107  : 		{
; 108  : 			sys_err("CGuildMarkImage: cannot open file for writing %s", c_szFileName);

  00059	56		 push	 esi
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@
  0005f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00064	83 c4 08	 add	 esp, 8

; 109  : 			return false;

  00067	32 c0		 xor	 al, al
  00069	5f		 pop	 edi

; 129  : }

  0006a	5e		 pop	 esi
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN3@Load:

; 110  : 		}
; 111  : 	}
; 112  : 
; 113  : 	if (ilGetInteger(IL_IMAGE_WIDTH) != WIDTH)	

  0006f	68 e4 0d 00 00	 push	 3556			; 00000de4H
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGetInteger@4
  0007a	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0007f	74 1b		 je	 SHORT $LN4@Load

; 114  : 	{
; 115  : 		sys_err("CGuildMarkImage: %s width must be %u", c_szFileName, WIDTH);

  00081	68 00 02 00 00	 push	 512			; 00000200H
  00086	56		 push	 esi
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@
  0008c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 		return false;

  00094	32 c0		 xor	 al, al
  00096	5f		 pop	 edi

; 129  : }

  00097	5e		 pop	 esi
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
$LN4@Load:

; 117  : 	}
; 118  : 
; 119  : 	if (ilGetInteger(IL_IMAGE_HEIGHT) != HEIGHT)

  0009c	68 e5 0d 00 00	 push	 3557			; 00000de5H
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGetInteger@4
  000a7	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000ac	74 1b		 je	 SHORT $LN5@Load

; 120  : 	{
; 121  : 		sys_err("CGuildMarkImage: %s height must be %u", c_szFileName, HEIGHT);

  000ae	68 00 02 00 00	 push	 512			; 00000200H
  000b3	56		 push	 esi
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@
  000b9	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  : 		return false;

  000c1	32 c0		 xor	 al, al
  000c3	5f		 pop	 edi

; 129  : }

  000c4	5e		 pop	 esi
  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
$LN5@Load:

; 123  : 	}
; 124  : 
; 125  : 	ilConvertImage(IL_BGRA, IL_UNSIGNED_BYTE);

  000c9	68 01 14 00 00	 push	 5121			; 00001401H
  000ce	68 e1 80 00 00	 push	 32993			; 000080e1H
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilConvertImage@8

; 126  : 
; 127  : 	BuildAllBlocks();

  000d9	8b cf		 mov	 ecx, edi
  000db	e8 00 00 00 00	 call	 ?BuildAllBlocks@CGuildMarkImage@@AAEXXZ ; CGuildMarkImage::BuildAllBlocks
  000e0	5f		 pop	 edi

; 128  : 	return true;

  000e1	b0 01		 mov	 al, 1

; 129  : }

  000e3	5e		 pop	 esi
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
?Load@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$dead$ = 16					; size = 4
_height$dead$ = 20					; size = 4
_data$ = 24						; size = 4
?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z PROC		; CGuildMarkImage::PutData, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 	ilBindImage(m_uImg);

  00003	ff b1 c4 07 5f
	00		 push	 DWORD PTR [ecx+6227908]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 134  : 	ilSetPixels(x, y, 0, width, height, 1, IL_BGRA, IL_UNSIGNED_BYTE, data);

  0000f	ff 75 18	 push	 DWORD PTR _data$[ebp]
  00012	68 01 14 00 00	 push	 5121			; 00001401H
  00017	68 e1 80 00 00	 push	 32993			; 000080e1H
  0001c	6a 01		 push	 1
  0001e	6a 30		 push	 48			; 00000030H
  00020	6a 40		 push	 64			; 00000040H
  00022	6a 00		 push	 0
  00024	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSetPixels@36

; 135  : }

  00030	5d		 pop	 ebp
  00031	c2 14 00	 ret	 20			; 00000014H
?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z ENDP		; CGuildMarkImage::PutData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$dead$ = 16					; size = 4
_height$dead$ = 20					; size = 4
_data$ = 24						; size = 4
?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z PROC		; CGuildMarkImage::GetData, COMDAT
; _this$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	ilBindImage(m_uImg);

  00003	ff b1 c4 07 5f
	00		 push	 DWORD PTR [ecx+6227908]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 140  : 	ilCopyPixels(x, y, 0, width, height, 1, IL_BGRA, IL_UNSIGNED_BYTE, data);	

  0000f	ff 75 18	 push	 DWORD PTR _data$[ebp]
  00012	68 01 14 00 00	 push	 5121			; 00001401H
  00017	68 e1 80 00 00	 push	 32993			; 000080e1H
  0001c	6a 01		 push	 1
  0001e	6a 30		 push	 48			; 00000030H
  00020	6a 40		 push	 64			; 00000040H
  00022	6a 00		 push	 0
  00024	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilCopyPixels@36

; 141  : }

  00030	5d		 pop	 ebp
  00031	c2 14 00	 ret	 20			; 00000014H
?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z ENDP		; CGuildMarkImage::GetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -12300				; size = 4
_sizeBuf$ = -12296					; size = 4
_apxBuf$ = -12292					; size = 12288
__$ArrayPad$ = -4					; size = 4
_posBlock$ = 8						; size = 4
_pbComp$ = 12						; size = 4
_dwCompSize$ = 16					; size = 4
?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z PROC ; CGuildMarkImage::SaveBlockFromCompressedData, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 30 00 00	 mov	 eax, 12300		; 0000300cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _pbComp$[ebp]
  0001b	57		 push	 edi

; 184  : 	if (posBlock >= BLOCK_TOTAL_COUNT)

  0001c	8b 7d 08	 mov	 edi, DWORD PTR _posBlock$[ebp]
  0001f	89 8d f4 cf ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00025	83 ff 50	 cmp	 edi, 80			; 00000050H
  00028	72 14		 jb	 SHORT $LN2@SaveBlockF

; 185  : 		return false;

  0002a	5f		 pop	 edi
  0002b	32 c0		 xor	 al, al

; 208  : 	return true;
; 209  : }

  0002d	5b		 pop	 ebx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00031	33 cd		 xor	 ecx, ebp
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SaveBlockF:

; 186  : 
; 187  : 	Pixel apxBuf[SGuildMarkBlock::SIZE];
; 188  : 	size_t sizeBuf = sizeof(apxBuf);
; 189  : 
; 190  : 	if (LZO_E_OK != lzo1x_decompress_safe(pbComp, dwCompSize, (BYTE *) apxBuf, (lzo_uint*) &sizeBuf, CLZO::Instance().GetWorkMemory()))

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00044	56		 push	 esi
  00045	c7 85 f8 cf ff
	ff 00 30 00 00	 mov	 DWORD PTR _sizeBuf$[ebp], 12288 ; 00003000H
  0004f	e8 00 00 00 00	 call	 ?GetWorkMemory@CLZO@@QAEPAEXZ ; CLZO::GetWorkMemory
  00054	8b 75 10	 mov	 esi, DWORD PTR _dwCompSize$[ebp]
  00057	50		 push	 eax
  00058	8d 85 f8 cf ff
	ff		 lea	 eax, DWORD PTR _sizeBuf$[ebp]
  0005e	50		 push	 eax
  0005f	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	53		 push	 ebx
  00068	e8 00 00 00 00	 call	 _lzo1x_decompress_safe
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	85 c0		 test	 eax, eax
  00072	74 23		 je	 SHORT $LN3@SaveBlockF

; 191  : 	{
; 192  : 		sys_err("CGuildMarkImage::CopyBlockFromCompressedData: cannot decompress, compressed size = %u", dwCompSize);

  00074	56		 push	 esi
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@
  0007a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007f	83 c4 08	 add	 esp, 8

; 193  : 		return false;

  00082	32 c0		 xor	 al, al
  00084	5e		 pop	 esi
  00085	5f		 pop	 edi

; 208  : 	return true;
; 209  : }

  00086	5b		 pop	 ebx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SaveBlockF:

; 194  : 	}
; 195  : 
; 196  : 	if (sizeBuf != sizeof(apxBuf))

  00097	8b 85 f8 cf ff
	ff		 mov	 eax, DWORD PTR _sizeBuf$[ebp]
  0009d	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  000a2	74 23		 je	 SHORT $LN4@SaveBlockF

; 197  : 	{
; 198  : 		sys_err("CGuildMarkImage::CopyBlockFromCompressedData: image corrupted, decompressed size = %u", sizeBuf);

  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@
  000aa	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000af	83 c4 08	 add	 esp, 8

; 199  : 		return false;

  000b2	32 c0		 xor	 al, al
  000b4	5e		 pop	 esi
  000b5	5f		 pop	 edi

; 208  : 	return true;
; 209  : }

  000b6	5b		 pop	 ebx
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SaveBlockF:

; 200  : 	}
; 201  : 
; 202  : 	DWORD rowBlock = posBlock / BLOCK_COL_COUNT;
; 203  : 	DWORD colBlock = posBlock % BLOCK_COL_COUNT;
; 204  : 
; 205  : 	PutData(colBlock * SGuildMarkBlock::WIDTH, rowBlock * SGuildMarkBlock::HEIGHT, SGuildMarkBlock::WIDTH, SGuildMarkBlock::HEIGHT, apxBuf);

  000c7	8b 8d f4 cf ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000cd	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  000d3	50		 push	 eax
  000d4	8b c7		 mov	 eax, edi
  000d6	83 ec 08	 sub	 esp, 8
  000d9	c1 e8 03	 shr	 eax, 3
  000dc	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000df	c1 e0 04	 shl	 eax, 4
  000e2	50		 push	 eax
  000e3	8b c7		 mov	 eax, edi
  000e5	83 e0 07	 and	 eax, 7
  000e8	c1 e0 06	 shl	 eax, 6
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z ; CGuildMarkImage::PutData

; 206  : 
; 207  : 	m_aakBlock[rowBlock][colBlock].CopyFrom(pbComp, dwCompSize, GetCRC32((const char *) apxBuf, sizeof(Pixel) * SGuildMarkBlock::SIZE));

  000f1	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  000f7	68 00 30 00 00	 push	 12288			; 00003000H
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  00102	8b 8d f4 cf ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00108	83 c4 08	 add	 esp, 8
  0010b	83 c1 04	 add	 ecx, 4
  0010e	50		 push	 eax
  0010f	69 c7 4c 63 00
	00		 imul	 eax, edi, 25420
  00115	56		 push	 esi
  00116	53		 push	 ebx
  00117	03 c8		 add	 ecx, eax
  00119	e8 00 00 00 00	 call	 ?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z ; SGuildMarkBlock::CopyFrom

; 208  : 	return true;
; 209  : }

  0011e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	b0 01		 mov	 al, 1
  00123	5e		 pop	 esi
  00124	5f		 pop	 edi
  00125	33 cd		 xor	 ecx, ebp
  00127	5b		 pop	 ebx
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 0c 00	 ret	 12			; 0000000cH
?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z ENDP ; CGuildMarkImage::SaveBlockFromCompressedData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?BuildAllBlocks@CGuildMarkImage@@AAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -12296				; size = 4
_apxBuf$ = -12292					; size = 12288
__$ArrayPad$ = -4					; size = 4
?BuildAllBlocks@CGuildMarkImage@@AAEXXZ PROC		; CGuildMarkImage::BuildAllBlocks, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 30 00 00	 mov	 eax, 12296		; 00003008H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b c1		 mov	 eax, ecx
  0001a	33 db		 xor	 ebx, ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 85 f8 cf ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  00024	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
$LL4@BuildAllBl:

; 217  : 		for (UINT col = 0; col < BLOCK_COL_COUNT; ++col)

  00027	33 f6		 xor	 esi, esi
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@BuildAllBl:

; 218  : 		{
; 219  : 			GetData(col * SGuildMarkBlock::WIDTH, row * SGuildMarkBlock::HEIGHT, SGuildMarkBlock::WIDTH, SGuildMarkBlock::HEIGHT, apxBuf);

  00030	8d 8d fc cf ff
	ff		 lea	 ecx, DWORD PTR _apxBuf$[ebp]
  00036	51		 push	 ecx
  00037	83 ec 08	 sub	 esp, 8
  0003a	8b c8		 mov	 ecx, eax
  0003c	53		 push	 ebx
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z ; CGuildMarkImage::GetData

; 220  : 			m_aakBlock[row][col].Compress(apxBuf);

  00043	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?Compress@SGuildMarkBlock@@QAEXPBK@Z ; SGuildMarkBlock::Compress
  00051	8b 85 f8 cf ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00057	83 c6 40	 add	 esi, 64			; 00000040H
  0005a	81 c7 4c 63 00
	00		 add	 edi, 25420		; 0000634cH
  00060	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00066	72 c8		 jb	 SHORT $LL7@BuildAllBl

; 213  : 	Pixel apxBuf[SGuildMarkBlock::SIZE];
; 214  : 	sys_log(0, "CGuildMarkImage::BuildAllBlocks");
; 215  : 
; 216  : 	for (UINT row = 0; row < BLOCK_ROW_COUNT; ++row)

  00068	83 c3 30	 add	 ebx, 48			; 00000030H
  0006b	81 fb e0 01 00
	00		 cmp	 ebx, 480		; 000001e0H
  00071	72 b4		 jb	 SHORT $LL4@BuildAllBl

; 221  : 		}
; 222  : }

  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	33 cd		 xor	 ecx, ebp
  0007a	5b		 pop	 ebx
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?BuildAllBlocks@CGuildMarkImage@@AAEXXZ ENDP		; CGuildMarkImage::BuildAllBlocks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z
_TEXT	SEGMENT
_crcList$ = 8						; size = 4
?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z PROC	; CGuildMarkImage::GetBlockCRCList, COMDAT
; _this$ = ecx

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 260  : 	for (DWORD row = 0; row < BLOCK_ROW_COUNT; ++row)

  00003	8b 55 08	 mov	 edx, DWORD PTR _crcList$[ebp]
  00006	83 c1 04	 add	 ecx, 4
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL4@GetBlockCR:

; 261  : 		for (DWORD col = 0; col < BLOCK_COL_COUNT; ++col)

  00010	be 08 00 00 00	 mov	 esi, 8
$LL7@GetBlockCR:

; 262  : 			*(crcList++) = m_aakBlock[row][col].GetCRC();

  00015	e8 00 00 00 00	 call	 ?GetCRC@SGuildMarkBlock@@QBEKXZ ; SGuildMarkBlock::GetCRC
  0001a	89 02		 mov	 DWORD PTR [edx], eax
  0001c	81 c1 4c 63 00
	00		 add	 ecx, 25420		; 0000634cH
  00022	83 c2 04	 add	 edx, 4
  00025	83 ee 01	 sub	 esi, 1
  00028	75 eb		 jne	 SHORT $LL7@GetBlockCR

; 260  : 	for (DWORD row = 0; row < BLOCK_ROW_COUNT; ++row)

  0002a	83 ef 01	 sub	 edi, 1
  0002d	75 e1		 jne	 SHORT $LL4@GetBlockCR
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 263  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z ENDP	; CGuildMarkImage::GetBlockCRCList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?GetCRC@SGuildMarkBlock@@QBEKXZ
_TEXT	SEGMENT
?GetCRC@SGuildMarkBlock@@QBEKXZ PROC			; SGuildMarkBlock::GetCRC, COMDAT
; _this$ = ecx

; 284  : 	return m_crc;

  00000	8b 81 48 63 00
	00		 mov	 eax, DWORD PTR [ecx+25416]

; 285  : }

  00006	c3		 ret	 0
?GetCRC@SGuildMarkBlock@@QBEKXZ ENDP			; SGuildMarkBlock::GetCRC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z
_TEXT	SEGMENT
_pbCompBuf$ = 8						; size = 4
_dwCompSize$ = 12					; size = 4
_crc$ = 16						; size = 4
?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z PROC		; SGuildMarkBlock::CopyFrom, COMDAT
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	if (dwCompSize > MAX_COMP_SIZE)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwCompSize$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d 43 33 00 00	 cmp	 eax, 13123		; 00003343H
  0000e	77 22		 ja	 SHORT $LN1@CopyFrom

; 290  : 		return;
; 291  : 
; 292  : 	m_sizeCompBuf = dwCompSize;
; 293  : 	thecore_memcpy(m_abCompBuf, pbCompBuf, dwCompSize);

  00010	50		 push	 eax
  00011	ff 75 08	 push	 DWORD PTR _pbCompBuf$[ebp]
  00014	89 86 44 63 00
	00		 mov	 DWORD PTR [esi+25412], eax
  0001a	8d 86 00 30 00
	00		 lea	 eax, DWORD PTR [esi+12288]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memcpy

; 294  : 	m_crc = crc;

  00026	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	89 86 48 63 00
	00		 mov	 DWORD PTR [esi+25416], eax
$LN1@CopyFrom:
  00032	5e		 pop	 esi

; 295  : 	//printf("SGuildMarkBlock::CopyFrom: %u > %u crc %u\n", sizeof(Pixel) * SGuildMarkBlock::SIZE, m_sizeCompBuf, m_crc);
; 296  : }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z ENDP		; SGuildMarkBlock::CopyFrom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\UserInterface\MarkImage.cpp
;	COMDAT ?Compress@SGuildMarkBlock@@QAEXPBK@Z
_TEXT	SEGMENT
_pxBuf$ = 8						; size = 4
?Compress@SGuildMarkBlock@@QAEXPBK@Z PROC		; SGuildMarkBlock::Compress, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 300  : 	m_sizeCompBuf = MAX_COMP_SIZE;

  00007	8d b7 44 63 00
	00		 lea	 esi, DWORD PTR [edi+25412]
  0000d	c7 06 43 33 00
	00		 mov	 DWORD PTR [esi], 13123	; 00003343H

; 301  : 
; 302  : 	if (LZO_E_OK != lzo1x_999_compress((const BYTE *) pxBuf,

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00019	e8 00 00 00 00	 call	 ?GetWorkMemory@CLZO@@QAEPAEXZ ; CLZO::GetWorkMemory
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	8d 87 00 30 00
	00		 lea	 eax, DWORD PTR [edi+12288]
  00026	50		 push	 eax
  00027	68 00 30 00 00	 push	 12288			; 00003000H
  0002c	ff 75 08	 push	 DWORD PTR _pxBuf$[ebp]
  0002f	e8 00 00 00 00	 call	 _lzo1x_999_compress
  00034	83 c4 14	 add	 esp, 20			; 00000014H
  00037	85 c0		 test	 eax, eax
  00039	74 1a		 je	 SHORT $LN2@Compress

; 303  : 		sizeof(Pixel) * SGuildMarkBlock::SIZE, m_abCompBuf,
; 304  : 		(lzo_uint*) &m_sizeCompBuf,
; 305  : 		CLZO::Instance().GetWorkMemory()))
; 306  : 	{
; 307  : 		sys_err("SGuildMarkBlock::Compress: Error! %u > %u", sizeof(Pixel) * SGuildMarkBlock::SIZE, m_sizeCompBuf);

  0003b	ff 36		 push	 DWORD PTR [esi]
  0003d	68 00 30 00 00	 push	 12288			; 00003000H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@
  00047	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	5f		 pop	 edi

; 313  : }

  00050	5e		 pop	 esi
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN2@Compress:

; 308  : 		return;
; 309  : 	}
; 310  : 
; 311  : 	//sys_log(0, "SGuildMarkBlock::Compress %u > %u", sizeof(Pixel) * SGuildMarkBlock::SIZE, m_sizeCompBuf);
; 312  : 	m_crc = GetCRC32((const char *) pxBuf, sizeof(Pixel) * SGuildMarkBlock::SIZE);

  00055	68 00 30 00 00	 push	 12288			; 00003000H
  0005a	ff 75 08	 push	 DWORD PTR _pxBuf$[ebp]
  0005d	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  00062	83 c4 08	 add	 esp, 8
  00065	89 87 48 63 00
	00		 mov	 DWORD PTR [edi+25416], eax
  0006b	5f		 pop	 edi

; 313  : }

  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?Compress@SGuildMarkBlock@@QAEXPBK@Z ENDP		; SGuildMarkBlock::Compress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\txoko-m2-work\txoko-client-src\source\eterBase\Singleton.h
;	COMDAT ?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ PROC	; CSingleton<CLZO>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ ENDP	; CSingleton<CLZO>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??R?$less@E@std@@QBE_NABE0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@E@std@@QBE_NABE0@Z PROC			; std::less<unsigned char>::operator(), COMDAT
; _this$dead$ = ecx

; 2379 :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2380 :         return _Left < _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000d	0f 92 c0	 setb	 al

; 2381 :     }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??R?$less@E@std@@QBE_NABE0@Z ENDP			; std::less<unsigned char>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vfprintf_l PROC					; COMDAT
; __Stream$ = ecx
; __Format$ = edx

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00006	ff 75 0c	 push	 DWORD PTR __ArgList$[ebp]
  00009	6a 00		 push	 0
  0000b	52		 push	 edx
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00012	ff 70 04	 push	 DWORD PTR [eax+4]
  00015	ff 30		 push	 DWORD PTR [eax]
  00017	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001c	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000e	83 c4 04	 add	 esp, 4
  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00014	8b d6		 mov	 edx, esi
  00016	51		 push	 ecx
  00017	51		 push	 ecx
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 __vfprintf_l
  0001f	83 c4 08	 add	 esp, 8

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;
; 963  :     }

  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
END
