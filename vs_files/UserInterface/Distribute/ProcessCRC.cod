; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35217.0 

	TITLE	d:\_m2work\server client tmp4\clientvs22\vs_files\userinterface\distribute\processcrc.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__ReadProcessMemory@20:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__Module32Next@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__Module32First@8:PROC
EXTRN	?GetExcutedFileName@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetExcutedFileName
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__CreateToolhelp32Snapshot@8:PROC
?abCRCXorTable@@3PAEA DB 066H				; abCRCXorTable
	DB	01eH
	DB	0bcH
	DB	02cH
	DB	027H
	DB	0c9H
	DB	02bH
	DB	05H
PUBLIC	?GetProcessCRCMagicCubePiece@@YAEXZ		; GetProcessCRCMagicCubePiece
PUBLIC	?BuildProcessCRC@@YAXXZ				; BuildProcessCRC
PUBLIC	?__GetExeCRC@@YA_NAAK0@Z			; __GetExeCRC
PUBLIC	?GetProcessMemoryCRC@@YAKPBX@Z			; GetProcessMemoryCRC
PUBLIC	?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z ; GetProcessInformation
PUBLIC	?stristr@@YAPBDPBD0@Z				; stristr
?abCRCMagicCube@@3PAEA DB 08H DUP (?)			; abCRCMagicCube
?bMagicCubeIdx@@3EA DB 01H DUP (?)			; bMagicCubeIdx
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__GetExeCRC@@YA_NAAK0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__GetExeCRC@@YA_NAAK0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__GetExeCRC@@YA_NAAK0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetExeCRC@@YA_NAAK0@Z$0
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?stristr@@YAPBDPBD0@Z
_TEXT	SEGMENT
?stristr@@YAPBDPBD0@Z PROC				; stristr, COMDAT
; _big$ = ecx
; _little$ = edx

; 10   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b fa		 mov	 edi, edx
  00005	8b f1		 mov	 esi, ecx

; 11   : 	const char * t = big;
; 12   : 	size_t len = strlen(little) - 1;

  00007	8b cf		 mov	 ecx, edi
  00009	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000c	0f 1f 40 00	 npad	 4
$LL12@stristr:
  00010	8a 01		 mov	 al, BYTE PTR [ecx]
  00012	41		 inc	 ecx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL12@stristr
  00017	2b ca		 sub	 ecx, edx
  00019	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]

; 13   : 
; 14   : 	for (t = big; *t; ++t)

  0001c	38 06		 cmp	 BYTE PTR [esi], al
  0001e	74 15		 je	 SHORT $LN3@stristr
$LL4@stristr:

; 15   : 		if (!_strnicmp(t, little, len))

  00020	53		 push	 ebx
  00021	57		 push	 edi
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 __strnicmp
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	85 c0		 test	 eax, eax
  0002d	74 0c		 je	 SHORT $LN8@stristr

; 13   : 
; 14   : 	for (t = big; *t; ++t)

  0002f	46		 inc	 esi
  00030	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00033	75 eb		 jne	 SHORT $LL4@stristr
$LN3@stristr:
  00035	5f		 pop	 edi

; 17   : 
; 18   : 	return NULL;
; 19   : }

  00036	5e		 pop	 esi
  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx
  0003a	c3		 ret	 0
$LN8@stristr:
  0003b	5f		 pop	 edi

; 16   : 			return t;

  0003c	8b c6		 mov	 eax, esi

; 17   : 
; 18   : 	return NULL;
; 19   : }

  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	c3		 ret	 0
?stristr@@YAPBDPBD0@Z ENDP				; stristr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
_TEXT	SEGMENT
_ppvAddress$GSCopy$1$ = -608				; size = 4
_exeFileName$GSCopy$1$ = -604				; size = 4
_me32$2 = -600						; size = 548
_filename$3 = -44					; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z PROC ; GetProcessInformation, COMDAT
; _exeFileName$ = ecx
; _ppvAddress$ = edx

; 22   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 95 a0 fd ff
	ff		 mov	 DWORD PTR _ppvAddress$GSCopy$1$[ebp], edx
  00047	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _exeFileName$GSCopy$1$[ebp], ecx

; 23   : 	HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00053	50		 push	 eax
  00054	6a 08		 push	 8
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateToolhelp32Snapshot@8
  0005c	8b f0		 mov	 esi, eax

; 24   : 	if (hModuleSnap != INVALID_HANDLE_VALUE) 

  0005e	83 fe ff	 cmp	 esi, -1
  00061	0f 84 68 01 00
	00		 je	 $LN96@GetProcess
  00067	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _filename$3[ebp+16], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00071	0f 11 45 d4	 movups	 XMMWORD PTR _filename$3[ebp], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00075	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _filename$3[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0007c	c6 45 d4 00	 mov	 BYTE PTR _filename$3[ebp], 0
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 28   : 		GetExcutedFileName(filename);

  00080	8d 45 d4	 lea	 eax, DWORD PTR _filename$3[ebp]
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?GetExcutedFileName@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetExcutedFileName

; 29   : 
; 30   : 		MODULEENTRY32 me32;
; 31   : 		memset(&me32, 0, sizeof(me32));

  00090	68 20 02 00 00	 push	 544			; 00000220H
  00095	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _me32$2[ebp+4]
  0009b	6a 00		 push	 0
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _memset
  000a3	83 c4 10	 add	 esp, 16			; 00000010H

; 32   : 		me32.dwSize = sizeof(MODULEENTRY32);

  000a6	c7 85 a8 fd ff
	ff 24 02 00 00	 mov	 DWORD PTR _me32$2[ebp], 548 ; 00000224H

; 33   : 
; 34   : 		BOOL bRet = Module32First(hModuleSnap, &me32);

  000b0	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _me32$2[ebp]
  000b6	50		 push	 eax
  000b7	56		 push	 esi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Module32First@8

; 35   : 
; 36   : 		while (bRet) 

  000be	85 c0		 test	 eax, eax
  000c0	74 55		 je	 SHORT $LN3@GetProcess
  000c2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Module32Next@8
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000d0	83 7d e8 0f	 cmp	 DWORD PTR _filename$3[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  000d4	8d 55 d4	 lea	 edx, DWORD PTR _filename$3[ebp]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 38   : 			if (stristr(me32.szExePath, filename.c_str()))

  000d7	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _me32$2[ebp+288]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  000dd	0f 47 55 d4	 cmova	 edx, DWORD PTR _filename$3[ebp]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 38   : 			if (stristr(me32.szExePath, filename.c_str()))

  000e1	e8 00 00 00 00	 call	 ?stristr@@YAPBDPBD0@Z	; stristr
  000e6	85 c0		 test	 eax, eax
  000e8	75 68		 jne	 SHORT $LN111@GetProcess

; 44   : 			}
; 45   : 
; 46   : 			ZeroMemory(&me32, sizeof(MODULEENTRY32));

  000ea	68 20 02 00 00	 push	 544			; 00000220H
  000ef	50		 push	 eax
  000f0	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _me32$2[ebp+4]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _memset
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 			me32.dwSize = sizeof(MODULEENTRY32);

  000ff	c7 85 a8 fd ff
	ff 24 02 00 00	 mov	 DWORD PTR _me32$2[ebp], 548 ; 00000224H

; 48   : 
; 49   : 			bRet = Module32Next(hModuleSnap, &me32);

  00109	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _me32$2[ebp]
  0010f	50		 push	 eax
  00110	56		 push	 esi
  00111	ff d7		 call	 edi
  00113	85 c0		 test	 eax, eax
  00115	75 b9		 jne	 SHORT $LL2@GetProcess
$LN3@GetProcess:

; 50   : 		}
; 51   : 
; 52   : 		CloseHandle(hModuleSnap);

  00117	56		 push	 esi
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0011e	8b 4d e8	 mov	 ecx, DWORD PTR _filename$3[ebp+20]
  00121	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00124	0f 86 a5 00 00
	00		 jbe	 $LN96@GetProcess
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012a	8b 55 d4	 mov	 edx, DWORD PTR _filename$3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0012d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00130	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00136	0f 82 89 00 00
	00		 jb	 $LN104@GetProcess

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0013c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0013f	83 c1 23	 add	 ecx, 35			; 00000023H
  00142	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00144	83 c0 fc	 add	 eax, -4			; fffffffcH
  00147	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0014a	0f 87 9f 00 00
	00		 ja	 $LN103@GetProcess
  00150	eb 73		 jmp	 SHORT $LN104@GetProcess
$LN111@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00152	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _me32$2[ebp+288]
  00158	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  0015b	0f 1f 44 00 00	 npad	 5
$LL115@GetProcess:
  00160	8a 02		 mov	 al, BYTE PTR [edx]
  00162	42		 inc	 edx
  00163	84 c0		 test	 al, al
  00165	75 f9		 jne	 SHORT $LL115@GetProcess
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00167	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _exeFileName$GSCopy$1$[ebp]
  0016d	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _me32$2[ebp+288]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00173	2b d7		 sub	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00175	52		 push	 edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 41   : 				*ppvAddress = me32.modBaseAddr;

  0017c	8b 8d a0 fd ff
	ff		 mov	 ecx, DWORD PTR _ppvAddress$GSCopy$1$[ebp]
  00182	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _me32$2[ebp+20]

; 42   : 				CloseHandle(hModuleSnap);

  00188	56		 push	 esi
  00189	89 01		 mov	 DWORD PTR [ecx], eax
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00191	8b 4d e8	 mov	 ecx, DWORD PTR _filename$3[ebp+20]
  00194	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00197	76 28		 jbe	 SHORT $LN63@GetProcess
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00199	8b 55 d4	 mov	 edx, DWORD PTR _filename$3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0019c	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019d	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0019f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001a5	72 10		 jb	 SHORT $LN71@GetProcess

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001a7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001aa	83 c1 23	 add	 ecx, 35			; 00000023H
  001ad	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001af	83 c0 fc	 add	 eax, -4			; fffffffcH
  001b2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001b5	77 38		 ja	 SHORT $LN103@GetProcess
$LN71@GetProcess:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001b7	51		 push	 ecx
  001b8	52		 push	 edx
  001b9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001be	83 c4 08	 add	 esp, 8
$LN63@GetProcess:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 43   : 				return true;

  001c1	b0 01		 mov	 al, 1
  001c3	eb 0c		 jmp	 SHORT $LN1@GetProcess
$LN104@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  001c5	51		 push	 ecx
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001cc	83 c4 08	 add	 esp, 8
$LN96@GetProcess:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 55   : 	return false;

  001cf	32 c0		 xor	 al, al
$LN1@GetProcess:

; 56   : }

  001d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001db	59		 pop	 ecx
  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	33 cd		 xor	 ecx, ebp
  001e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	8b e3		 mov	 esp, ebx
  001ed	5b		 pop	 ebx
  001ee	c3		 ret	 0
$LN103@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ef	6a 00		 push	 0
  001f1	6a 00		 push	 0
  001f3	6a 00		 push	 0
  001f5	6a 00		 push	 0
  001f7	6a 00		 push	 0
  001f9	e8 00 00 00 00	 call	 __invoke_watson
$LN117@GetProcess:
  001fe	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _filename$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a a0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-608]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z ENDP ; GetProcessInformation
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?GetProcessMemoryCRC@@YAKPBX@Z
_TEXT	SEGMENT
_dwBytesRead$ = -4					; size = 4
?GetProcessMemoryCRC@@YAKPBX@Z PROC			; GetProcessMemoryCRC, COMDAT
; _c_pvBaseAddress$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 60   : 	HANDLE hProcess = GetCurrentProcess();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0

; 61   : 	char * pBuf = new char[1024*1024];

  0000f	68 00 00 10 00	 push	 1048576			; 00100000H
  00014	8b f0		 mov	 esi, eax
  00016	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b d8		 mov	 ebx, eax

; 62   : 	DWORD dwBytesRead;
; 63   : 
; 64   : 	BOOL bRet = ReadProcessMemory(hProcess, c_pvBaseAddress, pBuf, 1024*1024, &dwBytesRead);

  00020	8d 45 fc	 lea	 eax, DWORD PTR _dwBytesRead$[ebp]
  00023	50		 push	 eax
  00024	68 00 00 10 00	 push	 1048576			; 00100000H
  00029	53		 push	 ebx
  0002a	57		 push	 edi
  0002b	56		 push	 esi
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20

; 65   : 
; 66   : 	if (!bRet && GetLastError() == ERROR_PARTIAL_COPY)

  00032	85 c0		 test	 eax, eax
  00034	75 1f		 jne	 SHORT $LN5@GetProcess
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003c	3d 2b 01 00 00	 cmp	 eax, 299		; 0000012bH
  00041	74 12		 je	 SHORT $LN5@GetProcess

; 74   : 	}
; 75   : 
; 76   : 	delete [] pBuf;

  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00049	83 c4 04	 add	 esp, 4

; 77   : 	return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5f		 pop	 edi

; 78   : }

  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN5@GetProcess:

; 67   : 		bRet = true;
; 68   : 
; 69   : 	if (bRet)
; 70   : 	{
; 71   : 		DWORD dwCRC = GetCRC32(pBuf, dwBytesRead);

  00055	ff 75 fc	 push	 DWORD PTR _dwBytesRead$[ebp]
  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32

; 72   : 		delete [] pBuf;

  0005e	53		 push	 ebx
  0005f	8b f0		 mov	 esi, eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   : 		return dwCRC;

  00069	8b c6		 mov	 eax, esi
  0006b	5f		 pop	 edi

; 78   : }

  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?GetProcessMemoryCRC@@YAKPBX@Z ENDP			; GetProcessMemoryCRC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?__GetExeCRC@@YA_NAAK0@Z
_TEXT	SEGMENT
_c_pvBaseAddress$ = -48					; size = 4
_exeFileName$ = -44					; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?__GetExeCRC@@YA_NAAK0@Z PROC				; __GetExeCRC, COMDAT
; _r_dwProcCRC$ = ecx
; _r_dwFileCRC$ = edx

; 81   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?__GetExeCRC@@YA_NAAK0@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 20	 sub	 esp, 32			; 00000020H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	56		 push	 esi
  00033	57		 push	 edi
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	8b fa		 mov	 edi, edx
  00040	8b f1		 mov	 esi, ecx
  00042	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _exeFileName$[ebp+16], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0004c	0f 11 45 d4	 movups	 XMMWORD PTR _exeFileName$[ebp], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00050	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _exeFileName$[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00057	c6 45 d4 00	 mov	 BYTE PTR _exeFileName$[ebp], 0
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 85   : 	GetExcutedFileName(exeFileName);

  0005b	8d 45 d4	 lea	 eax, DWORD PTR _exeFileName$[ebp]
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?GetExcutedFileName@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetExcutedFileName
  0006b	83 c4 04	 add	 esp, 4

; 86   : 
; 87   : 	if (GetProcessInformation(exeFileName, &c_pvBaseAddress))

  0006e	8d 55 d0	 lea	 edx, DWORD PTR _c_pvBaseAddress$[ebp]
  00071	8d 4d d4	 lea	 ecx, DWORD PTR _exeFileName$[ebp]
  00074	e8 00 00 00 00	 call	 ?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z ; GetProcessInformation
  00079	84 c0		 test	 al, al
  0007b	74 0a		 je	 SHORT $LN2@GetExeCRC

; 88   : 		r_dwProcCRC = GetProcessMemoryCRC(c_pvBaseAddress);

  0007d	8b 4d d0	 mov	 ecx, DWORD PTR _c_pvBaseAddress$[ebp]
  00080	e8 00 00 00 00	 call	 ?GetProcessMemoryCRC@@YAKPBX@Z ; GetProcessMemoryCRC
  00085	eb 02		 jmp	 SHORT $LN3@GetExeCRC
$LN2@GetExeCRC:

; 89   : 	else
; 90   : 		r_dwProcCRC = 0;

  00087	33 c0		 xor	 eax, eax
$LN3@GetExeCRC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 2356 :         return _Mypair._Myval2._Myptr();

  00089	89 06		 mov	 DWORD PTR [esi], eax

; 444  :         const value_type* _Result = _Bx._Buf;

  0008b	8d 45 d4	 lea	 eax, DWORD PTR _exeFileName$[ebp]

; 453  :         return _Myres > _Small_string_capacity;

  0008e	83 7d e8 0f	 cmp	 DWORD PTR _exeFileName$[ebp+20], 15 ; 0000000fH

; 445  :         if (_Large_mode_engaged()) {

  00092	0f 47 45 d4	 cmova	 eax, DWORD PTR _exeFileName$[ebp]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 92   : 	r_dwFileCRC = GetFileCRC32(exeFileName.c_str());

  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?GetFileCRC32@@YAKPBD@Z	; GetFileCRC32
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0009c	8b 4d e8	 mov	 ecx, DWORD PTR _exeFileName$[ebp+20]
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 92   : 	r_dwFileCRC = GetFileCRC32(exeFileName.c_str());

  0009f	83 c4 04	 add	 esp, 4
  000a2	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000a4	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  000a7	76 28		 jbe	 SHORT $LN54@GetExeCRC
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a9	8b 55 d4	 mov	 edx, DWORD PTR _exeFileName$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000ac	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ad	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000af	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b5	72 10		 jb	 SHORT $LN62@GetExeCRC

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000ba	83 c1 23	 add	 ecx, 35			; 00000023H
  000bd	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bf	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c5	77 2a		 ja	 SHORT $LN72@GetExeCRC
$LN62@GetExeCRC:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000c7	51		 push	 ecx
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ce	83 c4 08	 add	 esp, 8
$LN54@GetExeCRC:
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp

; 93   : 	return true;

  000d1	b0 01		 mov	 al, 1

; 94   : }

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	8b e3		 mov	 esp, ebx
  000ef	5b		 pop	 ebx
  000f0	c3		 ret	 0
$LN72@GetExeCRC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f1	6a 00		 push	 0
  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	e8 00 00 00 00	 call	 __invoke_watson
$LN70@GetExeCRC:
  00100	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__GetExeCRC@@YA_NAAK0@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _exeFileName$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__GetExeCRC@@YA_NAAK0@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__GetExeCRC@@YA_NAAK0@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__GetExeCRC@@YA_NAAK0@Z ENDP				; __GetExeCRC
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?BuildProcessCRC@@YAXXZ
_TEXT	SEGMENT
_dwFileCRC$ = -8					; size = 4
_dwProcCRC$ = -4					; size = 4
?BuildProcessCRC@@YAXXZ PROC				; BuildProcessCRC, COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 98   : 	if (LocaleService_IsHONGKONG() || LocaleService_IsTAIWAN())

  00006	e8 00 00 00 00	 call	 ?LocaleService_IsHONGKONG@@YA_NXZ ; LocaleService_IsHONGKONG
  0000b	84 c0		 test	 al, al
  0000d	75 6f		 jne	 SHORT $LN3@BuildProce
  0000f	e8 00 00 00 00	 call	 ?LocaleService_IsTAIWAN@@YA_NXZ ; LocaleService_IsTAIWAN
  00014	84 c0		 test	 al, al
  00016	75 66		 jne	 SHORT $LN3@BuildProce

; 99   : 	{
; 100  : 		memset(abCRCMagicCube, 0, sizeof(abCRCMagicCube));
; 101  : 		bMagicCubeIdx = 0;
; 102  : 		return;
; 103  : 	}
; 104  : 	
; 105  : 	DWORD dwProcCRC, dwFileCRC;
; 106  : 
; 107  : 	if (__GetExeCRC(dwProcCRC, dwFileCRC))

  00018	8d 55 f8	 lea	 edx, DWORD PTR _dwFileCRC$[ebp]
  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _dwProcCRC$[ebp]
  0001e	e8 00 00 00 00	 call	 ?__GetExeCRC@@YA_NAAK0@Z ; __GetExeCRC
  00023	84 c0		 test	 al, al
  00025	74 69		 je	 SHORT $LN4@BuildProce

; 108  : 	{
; 109  : 		abCRCMagicCube[0] = BYTE(dwProcCRC & 0x000000ff);

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _dwProcCRC$[ebp]

; 110  : 		abCRCMagicCube[1] = BYTE(dwFileCRC & 0x000000ff);
; 111  : 		abCRCMagicCube[2] = BYTE( (dwProcCRC & 0x0000ff00) >> 8 );

  0002a	8b c1		 mov	 eax, ecx
  0002c	8b 55 f8	 mov	 edx, DWORD PTR _dwFileCRC$[ebp]
  0002f	c1 e8 08	 shr	 eax, 8
  00032	a2 02 00 00 00	 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+2, al

; 112  : 		abCRCMagicCube[3] = BYTE( (dwFileCRC & 0x0000ff00) >> 8 );

  00037	8b c2		 mov	 eax, edx
  00039	c1 e8 08	 shr	 eax, 8
  0003c	a2 03 00 00 00	 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+3, al

; 113  : 		abCRCMagicCube[4] = BYTE( (dwProcCRC & 0x00ff0000) >> 16 );

  00041	8b c1		 mov	 eax, ecx
  00043	c1 e8 10	 shr	 eax, 16			; 00000010H
  00046	a2 04 00 00 00	 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+4, al

; 114  : 		abCRCMagicCube[5] = BYTE( (dwFileCRC & 0x00ff0000) >> 16 );

  0004b	8b c2		 mov	 eax, edx
  0004d	88 0d 00 00 00
	00		 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA, cl
  00053	c1 e8 10	 shr	 eax, 16			; 00000010H

; 115  : 		abCRCMagicCube[6] = BYTE( (dwProcCRC & 0xff000000) >> 24 );

  00056	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00059	88 15 01 00 00
	00		 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+1, dl

; 116  : 		abCRCMagicCube[7] = BYTE( (dwFileCRC & 0xff000000) >> 24 );

  0005f	c1 ea 18	 shr	 edx, 24			; 00000018H
  00062	a2 05 00 00 00	 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+5, al
  00067	88 0d 06 00 00
	00		 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+6, cl
  0006d	88 15 07 00 00
	00		 mov	 BYTE PTR ?abCRCMagicCube@@3PAEA+7, dl

; 117  : 
; 118  : 		bMagicCubeIdx = 0;
; 119  : 	}
; 120  : }

  00073	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?bMagicCubeIdx@@3EA, 0
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN3@BuildProce:
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?bMagicCubeIdx@@3EA, 0
  00088	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?abCRCMagicCube@@3PAEA, xmm0
$LN4@BuildProce:
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?BuildProcessCRC@@YAXXZ ENDP				; BuildProcessCRC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\_m2work\Server Client TMP4\ClientVS22\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?GetProcessCRCMagicCubePiece@@YAEXZ
_TEXT	SEGMENT
?GetProcessCRCMagicCubePiece@@YAEXZ PROC		; GetProcessCRCMagicCubePiece, COMDAT

; 124  : 	BYTE bPiece = BYTE(abCRCMagicCube[bMagicCubeIdx] ^ abCRCXorTable[bMagicCubeIdx]);

  00000	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?bMagicCubeIdx@@3EA
  00006	0f b6 ca	 movzx	 ecx, dl

; 125  : 
; 126  : 	if (!(++bMagicCubeIdx & 7))

  00009	fe c2		 inc	 dl
  0000b	88 15 00 00 00
	00		 mov	 BYTE PTR ?bMagicCubeIdx@@3EA, dl
  00011	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?abCRCXorTable@@3PAEA[ecx]
  00017	32 81 00 00 00
	00		 xor	 al, BYTE PTR ?abCRCMagicCube@@3PAEA[ecx]
  0001d	f6 c2 07	 test	 dl, 7
  00020	75 07		 jne	 SHORT $LN2@GetProcess

; 127  : 		bMagicCubeIdx = 0;

  00022	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?bMagicCubeIdx@@3EA, 0
$LN2@GetProcess:

; 128  : 
; 129  : 	return bPiece;
; 130  : }

  00029	c3		 ret	 0
?GetProcessCRCMagicCubePiece@@YAEXZ ENDP		; GetProcessCRCMagicCubePiece
_TEXT	ENDS
END
